---
title: 'Capítulo 5: Soporte técnico de Azure RTOS LevelX NOR'
description: La memoria flash NOR se compone de bloques que normalmente se pueden dividir de forma uniforme por 512 bytes. Azure RTOS LevelX divide cada bloque flash NOR en bloques lógicos de 512 bytes.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 3a0c73c2b45c32bf3f1ef56de684fa83c334b59e
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 03/22/2021
ms.locfileid: "104814893"
---
# <a name="chapter-5---azure-rtos-levelx-nor-support"></a><span data-ttu-id="8c7bd-104">Capítulo 5: Soporte técnico de Azure RTOS LevelX NOR</span><span class="sxs-lookup"><span data-stu-id="8c7bd-104">Chapter 5 - Azure RTOS LevelX NOR support</span></span>

<span data-ttu-id="8c7bd-105">La memoria flash NOR se compone de *bloques* que normalmente se pueden dividir de forma uniforme por 512 bytes.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-105">NOR flash memory is composed of *blocks* that are typically evenly divisible by 512 bytes.</span></span> <span data-ttu-id="8c7bd-106">No existe el concepto de una *página* flash en la memoria flash NOR.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-106">There are no concept of a flash *page* in NOR flash memory.</span></span> <span data-ttu-id="8c7bd-107">Además, no hay bytes de *reserva* en la memoria flash NOR, por lo que Azure RTOS LevelX debe usar la propia memoria flash NOR para toda la información de administración.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-107">Also, there are no *spare* bytes in NOR flash memory, hence Azure RTOS LevelX must use the NOR flash memory itself for all management information.</span></span> <span data-ttu-id="8c7bd-108">El acceso de lectura directo es posible en la memoria flash NOR.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-108">Direct read access is possible in NOR flash memory.</span></span> <span data-ttu-id="8c7bd-109">Normalmente, el acceso de escritura requiere una secuencia especial de operaciones.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-109">Write access typically requires a special sequence of operations.</span></span> <span data-ttu-id="8c7bd-110">La memoria flash NOR se puede escribir varias veces, siempre que se borren los bits.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-110">NOR flash memory may be written to multiple times, providing that bits are being cleared.</span></span> <span data-ttu-id="8c7bd-111">Los bits en la memoria flash NOR solo se pueden establecer una vez, a través de la operación de borrado de bloque.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-111">Bits in NOR flash memory can only be set once, via the erase block operation.</span></span>

<span data-ttu-id="8c7bd-112">LevelX divide cada bloque flash NOR en *sectores* lógicos de 512 bytes.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-112">LevelX divides each NOR flash block into 512-byte logical *sectors*.</span></span> <span data-ttu-id="8c7bd-113">Además, LevelX usa los primeros sectores "n" de cada bloque flash NOR para almacenar información de administración.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-113">Furthermore, LevelX uses the first "n" sectors of each NOR flash block to store management information.</span></span> <span data-ttu-id="8c7bd-114">El formato de la información de administración de la memoria flash NOR LevelX es:</span><span class="sxs-lookup"><span data-stu-id="8c7bd-114">The format of the LevelX NOR flash memory management information is:</span></span>

<span data-ttu-id="8c7bd-115">**Formato de bloque NOR LevelX**</span><span class="sxs-lookup"><span data-stu-id="8c7bd-115">**LevelX NOR Block Format**</span></span>

| <span data-ttu-id="8c7bd-116">Desplazamiento de byte</span><span class="sxs-lookup"><span data-stu-id="8c7bd-116">Byte Offset</span></span>  | <span data-ttu-id="8c7bd-117">Contenido</span><span class="sxs-lookup"><span data-stu-id="8c7bd-117">Contents</span></span>                     |
| ------------ | ---------------------------- |
| <span data-ttu-id="8c7bd-118">0</span><span class="sxs-lookup"><span data-stu-id="8c7bd-118">0</span></span>            | <span data-ttu-id="8c7bd-119">[Recuento de borrado de bloques]</span><span class="sxs-lookup"><span data-stu-id="8c7bd-119">[Block Erase Count]</span></span>          |
| <span data-ttu-id="8c7bd-120">4</span><span class="sxs-lookup"><span data-stu-id="8c7bd-120">4</span></span>            | <span data-ttu-id="8c7bd-121">[Minimum Mapped Sector]</span><span class="sxs-lookup"><span data-stu-id="8c7bd-121">[Minimum Mapped Sector]</span></span>      |
| <span data-ttu-id="8c7bd-122">8</span><span class="sxs-lookup"><span data-stu-id="8c7bd-122">8</span></span>            | <span data-ttu-id="8c7bd-123">[Maximum Mapped Sector]</span><span class="sxs-lookup"><span data-stu-id="8c7bd-123">[Maximum Mapped Sector]</span></span>      |
| <span data-ttu-id="8c7bd-124">12</span><span class="sxs-lookup"><span data-stu-id="8c7bd-124">12</span></span>           | <span data-ttu-id="8c7bd-125">[Mapa de bits del sector libre]</span><span class="sxs-lookup"><span data-stu-id="8c7bd-125">[Free Sector Bit Map]</span></span>        |
| <span data-ttu-id="8c7bd-126">m</span><span class="sxs-lookup"><span data-stu-id="8c7bd-126">m</span></span>            | <span data-ttu-id="8c7bd-127">[Entrada de asignación de sector 0]</span><span class="sxs-lookup"><span data-stu-id="8c7bd-127">[Sector 0 Mapping Entry]</span></span>     |
|              | <span data-ttu-id="8c7bd-128">…</span><span class="sxs-lookup"><span data-stu-id="8c7bd-128">…</span></span>                            |
| <span data-ttu-id="8c7bd-129">m+4\*(n-1)</span><span class="sxs-lookup"><span data-stu-id="8c7bd-129">m+4\*(n-1)</span></span>    | <span data-ttu-id="8c7bd-130">[Entrada de asignación de sector "n"]</span><span class="sxs-lookup"><span data-stu-id="8c7bd-130">[Sector "n" Mapping Entry]</span></span>   |
|              | <span data-ttu-id="8c7bd-131">…</span><span class="sxs-lookup"><span data-stu-id="8c7bd-131">…</span></span>                            |
| <span data-ttu-id="8c7bd-132">s</span><span class="sxs-lookup"><span data-stu-id="8c7bd-132">s</span></span>            | <span data-ttu-id="8c7bd-133">[Contenido del sector 0]</span><span class="sxs-lookup"><span data-stu-id="8c7bd-133">[Sector 0 Contents]</span></span>          |
|              | <span data-ttu-id="8c7bd-134">…</span><span class="sxs-lookup"><span data-stu-id="8c7bd-134">…</span></span>                            |
| <span data-ttu-id="8c7bd-135">s+512\*(n-1)</span><span class="sxs-lookup"><span data-stu-id="8c7bd-135">s+512\*(n-1)</span></span> | <span data-ttu-id="8c7bd-136">[Contenido del sector "n"]</span><span class="sxs-lookup"><span data-stu-id="8c7bd-136">[Sector "n" Contents]</span></span>         |

<span data-ttu-id="8c7bd-137">El *recuento de borrado de bloques* de 32 bits contiene el número de veces que se ha borrado el bloque.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-137">The 32-bit *Block Erase Count* contains the number of times the block has been erased.</span></span> <span data-ttu-id="8c7bd-138">El objetivo principal de LevelX es mantener el número de borrado de todos los bloques relativamente cerca para ayudar a evitar que un bloque no se conserve prematuramente.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-138">The main goal of LevelX is to keep the erase count of all blocks relatively close to help prevent any one block from wearing out prematurely.</span></span> <span data-ttu-id="8c7bd-139">Los campos de 32 bits del *sector asignado mínimo* y del *sector asignado máximo* solo se escriben cuando se han asignado y escrito todos los sectores lógicos del bloque.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-139">The 32-bit *Minimum Mapped Sector* and *Maximum Mapped Sector* fields are written only when all the logical sectors in the block have been mapped and written to.</span></span> <span data-ttu-id="8c7bd-140">Estos campos son útiles para la optimización de la operación de lectura del sector.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-140">These fields are useful for optimization of the sector read operation.</span></span> <span data-ttu-id="8c7bd-141">La entrada de *mapa de bits del sector libre* es un mapa de bits en el que cada bit establecido corresponde a un sector sin asignar del bloque.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-141">The *Free Sector Bit Map* entry is a bit map where each set bit corresponds to an unmapped sector in the block.</span></span> <span data-ttu-id="8c7bd-142">Este campo se usa para hacer que la búsqueda del sector libre sea más eficiente.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-142">This field is used to make the free sector search more efficient.</span></span> <span data-ttu-id="8c7bd-143">Se trata de un campo de longitud variable que requiere una palabra por cada 32 sectores del bloque.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-143">This is a variable length field that requires one word for every 32 sectors in the block.</span></span> <span data-ttu-id="8c7bd-144">La matriz de la *entrada de asignación de sectores* contiene información de asignación para cada sector del bloque.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-144">The *Sector Mapping Entry* array contains mapping information for each sector in the block.</span></span> <span data-ttu-id="8c7bd-145">Cada entrada tiene los siguientes datos:</span><span class="sxs-lookup"><span data-stu-id="8c7bd-145">Each entry has the following format:</span></span>

<span data-ttu-id="8c7bd-146">**Entrada de asignación de sectores**</span><span class="sxs-lookup"><span data-stu-id="8c7bd-146">**Sector Mapping Entry**</span></span>

| <span data-ttu-id="8c7bd-147">Bit(s)</span><span class="sxs-lookup"><span data-stu-id="8c7bd-147">Bit(s)</span></span> | <span data-ttu-id="8c7bd-148">Significado</span><span class="sxs-lookup"><span data-stu-id="8c7bd-148">Meaning</span></span>  |
| ------ | -------- |
| <span data-ttu-id="8c7bd-149">31</span><span class="sxs-lookup"><span data-stu-id="8c7bd-149">31</span></span>     | <span data-ttu-id="8c7bd-150">Marca válida.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-150">Valid flag.</span></span> <span data-ttu-id="8c7bd-151">Cuando se establece un sector lógico, no todos indican que la asignación es válida</span><span class="sxs-lookup"><span data-stu-id="8c7bd-151">When set and logical sector not all ones indicates mapping is valid</span></span> |
| <span data-ttu-id="8c7bd-152">30</span><span class="sxs-lookup"><span data-stu-id="8c7bd-152">30</span></span>     | <span data-ttu-id="8c7bd-153">Marca obsoleta.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-153">Obsolete flag.</span></span> <span data-ttu-id="8c7bd-154">Cuando está desactivada, esta asignación es obsoleta o está en proceso de ser obsoleta.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-154">When clear, this mapping is either obsolete or is in the process of becoming obsolete.</span></span> |
| <span data-ttu-id="8c7bd-155">29</span><span class="sxs-lookup"><span data-stu-id="8c7bd-155">29</span></span>     | <span data-ttu-id="8c7bd-156">La escritura de entradas de asignación se completa cuando este bit es 0</span><span class="sxs-lookup"><span data-stu-id="8c7bd-156">Mapping entry write is complete when this bit is 0</span></span> |
| <span data-ttu-id="8c7bd-157">0-28</span><span class="sxs-lookup"><span data-stu-id="8c7bd-157">0-28</span></span>   | <span data-ttu-id="8c7bd-158">Sector lógico asignado a este sector físico: no todos.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-158">Logical sector mapped to this physical sector—when not all ones.</span></span> |

<span data-ttu-id="8c7bd-159">El bit superior del campo de 32 bits (bit 31) se usa para indicar que la asignación del sector lógico es válida.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-159">The upper bit of the 32-bit field (bit 31) is used to indicate the logical sector mapping is valid.</span></span> <span data-ttu-id="8c7bd-160">Si este bit es 0, la información de esta entrada (y el contenido del sector correspondiente) ya no es válida.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-160">If this bit is 0, the information in this entry (and corresponding sector contents) is no longer valid.</span></span> <span data-ttu-id="8c7bd-161">El siguiente bit (bit 30) se usa para indicar que este sector está en proceso de ser obsoleto y se está escribiendo un nuevo sector.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-161">The next bit - bit 30 - is used to indicate this sector is in the process of becoming obsolete and a new sector is being written.</span></span> <span data-ttu-id="8c7bd-162">El bit 29 se usa para indicar cuándo se ha completado la escritura de la entrada de asignación.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-162">Bit 29 is used to indicate when the mapping entry write is complete.</span></span> <span data-ttu-id="8c7bd-163">Si el bit 29 es 0, se completa la escritura de la entrada de asignación.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-163">If bit 29 is 0, the mapping entry write is complete.</span></span> <span data-ttu-id="8c7bd-164">Si se establece el bit 29, la entrada de asignación estaba en proceso de escritura.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-164">If bit 29 is set, the mapping entry was in the process of being written.</span></span> <span data-ttu-id="8c7bd-165">Los bits 30 y 29 se usan para recuperarse de una posible pérdida de energía mientras se actualiza una nueva asignación de sectores.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-165">Bits 30 and 29 are used in recovering from a potential power loss while updating a new sector mapping.</span></span> <span data-ttu-id="8c7bd-166">Por último, los 29 bits inferiores (28-0) contienen el número de sector lógico del sector.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-166">Finally, the lower 29-bits (28-0) contain the logical sector number for the sector.</span></span> <span data-ttu-id="8c7bd-167">Si un sector no se ha asignado, se establecerán todos los bits, es decir, tendrá un valor de 0xFFFFFFFF.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-167">If a sector has not been mapped, all bits will be set, i.e., it will have a value of 0xFFFFFFFF.</span></span>

## <a name="nor-driver-requirements"></a><span data-ttu-id="8c7bd-168">Requisitos para controladores NOR</span><span class="sxs-lookup"><span data-stu-id="8c7bd-168">NOR Driver Requirements</span></span>

<span data-ttu-id="8c7bd-169">LevelX requiere un controlador flash NOR subyacente que sea específico de la parte flash subyacente y de la implementación de hardware.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-169">LevelX requires an underlying NOR flash driver that is specific to the underlying flash part and hardware implementation.</span></span> <span data-ttu-id="8c7bd-170">El controlador se especifica en LevelX durante la inicialización a través de la API ***lx_nor_flash_open***.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-170">The driver is specified to LevelX during initialization via the API ***lx_nor_flash_open***.</span></span> <span data-ttu-id="8c7bd-171">El prototipo del controlador LevelX es:</span><span class="sxs-lookup"><span data-stu-id="8c7bd-171">The prototype of the LevelX driver is:</span></span>

```c
INT nor_driver_initialize(LX_NOR_FLASH *instance);
```

<span data-ttu-id="8c7bd-172">El parámetro "*instancia*" el bloque de control LevelX NOR.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-172">The "*instance*" parameter specifies the LevelX NOR control block.</span></span> <span data-ttu-id="8c7bd-173">La función de inicialización de controladores es responsable de configurar todos los demás servicios de nivel de controlador para la instancia de LevelX asociada.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-173">The driver initialization function is responsible for setting up all the other driver-level services for the associated LevelX instance.</span></span> <span data-ttu-id="8c7bd-174">Los servicios necesarios para cada instancia LevelX NOR son:</span><span class="sxs-lookup"><span data-stu-id="8c7bd-174">The services required for each LevelX NOR instance are:</span></span>

- <span data-ttu-id="8c7bd-175">Leer sector</span><span class="sxs-lookup"><span data-stu-id="8c7bd-175">Read Sector</span></span>
- <span data-ttu-id="8c7bd-176">Escribir sector</span><span class="sxs-lookup"><span data-stu-id="8c7bd-176">Write Sector</span></span>
- <span data-ttu-id="8c7bd-177">Borrado de bloque</span><span class="sxs-lookup"><span data-stu-id="8c7bd-177">Block Erase</span></span>
- <span data-ttu-id="8c7bd-178">Comprobación de bloque borrado</span><span class="sxs-lookup"><span data-stu-id="8c7bd-178">Block Erased Verify</span></span>
- <span data-ttu-id="8c7bd-179">Controlador de errores del sistema</span><span class="sxs-lookup"><span data-stu-id="8c7bd-179">System Error Handler</span></span>

## <a name="driver-initialization"></a><span data-ttu-id="8c7bd-180">Inicialización del controlador</span><span class="sxs-lookup"><span data-stu-id="8c7bd-180">Driver Initialization</span></span>

<span data-ttu-id="8c7bd-181">Estos servicios se configuran mediante el establecimiento de punteros de función en la instancia de **LX_NOR_FLASH** dentro de la función de inicialización del controlador.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-181">These services are setup via setting function pointers in the **LX_NOR_FLASH** instance within the driver's initialization function.</span></span> <span data-ttu-id="8c7bd-182">La función de inicialización del controlador también es responsable de:</span><span class="sxs-lookup"><span data-stu-id="8c7bd-182">The driver initialization function also is responsible for:</span></span>

1. <span data-ttu-id="8c7bd-183">Especificar la dirección base del flash.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-183">Specifying the base address of the flash.</span></span>
1. <span data-ttu-id="8c7bd-184">Especificar el número total de bloques y el número de palabras por bloque.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-184">Specifying the total number of blocks and the number of words per block.</span></span>
1. <span data-ttu-id="8c7bd-185">Un búfer de RAM para leer un sector de flash (512 bytes) y alineado para el acceso ULONG.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-185">A RAM buffer for reading one sector of flash (512 bytes) and aligned for ULONG access.</span></span>

<span data-ttu-id="8c7bd-186">La función de inicialización del controlador también realiza tareas adicionales de inicialización específicas del dispositivo o de la implementación antes de devolver **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-186">The driver initialization function likely also performs additional device and/or implementation-specific initialization duties before returning **LX_SUCCESS**.</span></span>

## <a name="driver-read-sector"></a><span data-ttu-id="8c7bd-187">Sector de lectura del controlador</span><span class="sxs-lookup"><span data-stu-id="8c7bd-187">Driver Read Sector</span></span>

<span data-ttu-id="8c7bd-188">El servicio de "sector de lectura" del controlador LevelX NOR es responsable de leer un sector específico en un bloque específico de la memoria flash NOR.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-188">The LevelX NOR driver "read sector" service is responsible for reading a specific sector in a specific block of the NOR flash.</span></span> <span data-ttu-id="8c7bd-189">Todas las comprobaciones de errores y la lógica de corrección son responsabilidad del servicio de controlador.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-189">All error checking and correcting logic is the responsibility of the driver service.</span></span> <span data-ttu-id="8c7bd-190">Si se realiza correctamente, el controlador LevelX NOR devuelve **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-190">If successful, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="8c7bd-191">Si no se realiza correctamente, el controlador LevelX NOR devuelve *LX_ERROR*.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-191">If not successful, the LevelX NOR driver returns *LX_ERROR*.</span></span> <span data-ttu-id="8c7bd-192">El prototipo del servicio de "sector de lectura" del controlador LevelX NOR es:</span><span class="sxs-lookup"><span data-stu-id="8c7bd-192">The prototype of the LevelX NOR driver "read sector" service is:</span></span>

```c
INT nor_driver_read_sector(
    ULONG *flash_address,
    ULONG *destination, 
    ULONG words);
```

<span data-ttu-id="8c7bd-193">Donde "*flash_address*" especifica la dirección de un sector lógico dentro de un bloque de memoria flash NOR y "*destino*" y "*palabras*" especifican dónde colocar el contenido del sector y cuántas palabras de 32 bits se van a leer.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-193">Where "*flash_address*" specifies the address of a logical sector within a NOR flash block of memory and "*destination*" and "*words*" specify where to place the sector contents and how many 32-bit words to read.</span></span>

## <a name="driver-write-sector"></a><span data-ttu-id="8c7bd-194">Sector de escritura de controladores</span><span class="sxs-lookup"><span data-stu-id="8c7bd-194">Driver Write Sector</span></span>

<span data-ttu-id="8c7bd-195">El servicio de "sector de escritura" del controlador LevelX NOR es responsable de escribir un sector específico en un bloque de la memoria flash NOR.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-195">The LevelX NOR driver "write sector" service is responsible for writing a specific sector into a block of the NOR flash.</span></span> <span data-ttu-id="8c7bd-196">La comprobación de errores es responsabilidad del servicio de controlador.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-196">All error checking is the responsibility of the driver service.</span></span> <span data-ttu-id="8c7bd-197">Si se realiza correctamente, el controlador LevelX NOR devuelve **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-197">If successful, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="8c7bd-198">Si no se realiza correctamente, el controlador LevelX NOR devuelve **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-198">If not successful, the LevelX NOR driver returns **LX_ERROR**.</span></span> <span data-ttu-id="8c7bd-199">El prototipo del servicio de "sector de escritura" del controlador LevelX NOR es:</span><span class="sxs-lookup"><span data-stu-id="8c7bd-199">The prototype of the LevelX NOR driver "write sector" service is:</span></span>

```c
INT nor_driver_write_sector(
    ULONG *flash_address,
    ULONG *source, 
    ULONG words);
```

<span data-ttu-id="8c7bd-200">Donde "*flash_address*" especifica la dirección de un sector lógico dentro de un bloque de memoria flash NOR y "*origen*" y "*palabras*" especifican el origen de la escritura y el número de palabras de 32 bits que se van a escribir.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-200">Where "*flash_address*" specifies the address of a logical sector within a NOR flash block of memory and "*source*" and "*words*" specify the source of the write and how many 32-bit words to write.</span></span>

> [!NOTE]
> <span data-ttu-id="8c7bd-201">LevelX se basa en el controlador para comprobar que el sector de escritura se ha realizado correctamente.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-201">LevelX relies on the driver to verify that the write sector was successful.</span></span> <span data-ttu-id="8c7bd-202">Normalmente, esto se realiza leyendo el valor programado para asegurarse de que coincida con el valor solicitado que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-202">This is typically done by reading back the programmed value to ensure it matches the requested value to be written.</span></span>

## <a name="driver-block-erase"></a><span data-ttu-id="8c7bd-203">Borrado de bloque de controlador</span><span class="sxs-lookup"><span data-stu-id="8c7bd-203">Driver Block Erase</span></span>

<span data-ttu-id="8c7bd-204">El servicio de "borrado de bloques" del controlador LevelX NOR es responsable de borrar el bloque especificado de la memoria flash NOR.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-204">The LevelX NOR driver "block erase" service is responsible for erasing the specified block of the NOR flash.</span></span> <span data-ttu-id="8c7bd-205">Si se realiza correctamente, el controlador LevelX NOR devuelve **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-205">If successful, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="8c7bd-206">Si no se realiza correctamente, el controlador LevelX NOR devuelve **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-206">If not successful, the LevelX NOR driver returns **LX_ERROR**.</span></span> <span data-ttu-id="8c7bd-207">El prototipo del servicio de "borrado de bloques" del controlador LevelX NOR es:</span><span class="sxs-lookup"><span data-stu-id="8c7bd-207">The prototype of the LevelX NOR driver "block erase" service is:</span></span>

```c
INT nor_driver_block_erase(ULONG block,  
    ULONG erase_count);
```

<span data-ttu-id="8c7bd-208">Donde "*bloque*" identifica el bloque NOR que se va a borrar.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-208">Where "*block*" identifies which NOR block to erase.</span></span> <span data-ttu-id="8c7bd-209">El parámetro "*erase_count*" se proporciona con fines de diagnóstico.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-209">The parameter "*erase_count*" is provided for diagnostic purposes.</span></span> <span data-ttu-id="8c7bd-210">Por ejemplo, el controlador puede querer alertar a otra parte del software de la aplicación cuando el recuento de borrado supera un umbral específico.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-210">For example, the driver may want to alert another portion of the application software when the erase count exceeds a specific threshold.</span></span>

> [!NOTE]
> <span data-ttu-id="8c7bd-211">LevelX se basa en el controlador para examinar todos los bytes del bloque con el fin de asegurarse de que se borran (contienen todos).</span><span class="sxs-lookup"><span data-stu-id="8c7bd-211">LevelX relies on the driver to examine all bytes of the block to ensure they are erased (contain all ones).</span></span>

## <a name="driver-block-erased-verify"></a><span data-ttu-id="8c7bd-212">Comprobación de borrado de bloque de controlador</span><span class="sxs-lookup"><span data-stu-id="8c7bd-212">Driver Block Erased Verify</span></span>

<span data-ttu-id="8c7bd-213">El servicio de "comprobación de borrado de bloque" del controlador LevelX NOR es responsable de verificar que se borre el bloque especificado de la memoria flash NOR.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-213">The LevelX NOR driver "block erased verify" service is responsible for verifying that the specified block of the NOR flash is erased.</span></span> <span data-ttu-id="8c7bd-214">Si se borra, el controlador LevelX NOR devuelve **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-214">If it is erased, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="8c7bd-215">Si no se borra el bloque, el controlador LevelX NOR devuelve **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-215">If the block is not erased, the LevelX NOR driver returns **LX_ERROR**.</span></span> <span data-ttu-id="8c7bd-216">El prototipo del servicio de "comprobación de borrado de bloque" del controlador LevelX NOR es:</span><span class="sxs-lookup"><span data-stu-id="8c7bd-216">The prototype of the LevelX NOR driver "block erased verify" service is:</span></span>

```c
INT nor_driver_block_erased_verify(ULONG block);
```

<span data-ttu-id="8c7bd-217">Donde "*bloque*" especifica el bloque que se va a comprobar que se ha borrado.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-217">Where "*block*" specifies which block to verify that it is erased.</span></span>

> [!NOTE]
> <span data-ttu-id="8c7bd-218">LevelX se basa en el controlador para examinar todos los bytes del especificado para asegurarse de que se borran (contienen todos).</span><span class="sxs-lookup"><span data-stu-id="8c7bd-218">LevelX relies on the driver to examine all bytes of the specified to ensure they are erased (contain all ones).</span></span>

## <a name="driver-system-error"></a><span data-ttu-id="8c7bd-219">Error del sistema de controladores</span><span class="sxs-lookup"><span data-stu-id="8c7bd-219">Driver System Error</span></span>

<span data-ttu-id="8c7bd-220">El servicio "controlador de errores del sistema" del controlador LevelX NOR es responsable de configurar el manejo de errores del sistema detectados por LevelX.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-220">The LevelX NOR driver "system error handler" service is responsible for setting handling system errors detected by LevelX.</span></span> <span data-ttu-id="8c7bd-221">El procesamiento en esta rutina depende de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-221">The processing in this routine is application dependent.</span></span> <span data-ttu-id="8c7bd-222">Si se realiza correctamente, el controlador LevelX NOR devuelve **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-222">If it is successful, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="8c7bd-223">Si no se realiza correctamente, el controlador LevelX NOR devuelve **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-223">If it is not successful, the LevelX NOR driver returns **LX_ERROR**.</span></span> <span data-ttu-id="8c7bd-224">El prototipo del servicio de "error del sistema" del controlador LevelX NOR es:</span><span class="sxs-lookup"><span data-stu-id="8c7bd-224">The prototype of the LevelX NOR driver "system error" service is:</span></span>

```c
INT nor_driver_system_error(UINT error_code);
```

<span data-ttu-id="8c7bd-225">Donde "*error_code*" representa el error que se ha producido.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-225">Where "*error_code*" represents the error that occurred.</span></span>

## <a name="nor-simulated-driver"></a><span data-ttu-id="8c7bd-226">Controlador simulado NOR</span><span class="sxs-lookup"><span data-stu-id="8c7bd-226">NOR Simulated Driver</span></span>

<span data-ttu-id="8c7bd-227">LevelX proporciona un controlador flash NOR simulado que simplemente usa RAM para simular el funcionamiento de una parte flash NOR.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-227">LevelX provides a simulated NOR flash driver that simply uses RAM to simulate the operation of a NOR flash part.</span></span> <span data-ttu-id="8c7bd-228">De manera predeterminada, el controlador simulado NOR proporciona 8 bloques flash NOR con 16 sectores de 512 bytes por bloque.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-228">By default, the NOR simulated driver provides 8 NOR flash blocks with 16 512-byte sectors per block.</span></span>

<span data-ttu-id="8c7bd-229">La función de inicialización del controlador flash NOR simulado es \***lx_nor_flash_simulator_initialize** _ y está definida en _ \*_lx_nor_flash_simulator.c_\*\*.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-229">The simulated NOR flash driver initialization function is ***lx_nor_flash_simulator_initialize** _ and is defined in _*_lx_nor_flash_simulator.c_\*\*.</span></span> <span data-ttu-id="8c7bd-230">Este controlador también proporciona una buena plantilla para escribir controladores de flash NOR específicos.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-230">This driver also provides a good template for writing specific NOR flash drivers.</span></span>

## <a name="nor-filex-integration"></a><span data-ttu-id="8c7bd-231">Integración de FileX NOR</span><span class="sxs-lookup"><span data-stu-id="8c7bd-231">NOR FileX Integration</span></span>

<span data-ttu-id="8c7bd-232">Como se mencionó anteriormente, LevelX no se basa en FileX para su funcionamiento.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-232">As mentioned earlier, LevelX does not rely on FileX for operation.</span></span> <span data-ttu-id="8c7bd-233">El software de la aplicación puede llamar directamente a todas las API de LevelX para almacenar o recuperar datos sin procesar en los sectores lógicos proporcionados por LevelX.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-233">All the LevelX APIs may be called directly by the application software to store/retrieve raw data to the logical sectors provided by LevelX.</span></span> <span data-ttu-id="8c7bd-234">Sin embargo, LevelX también admite FileX.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-234">However, LevelX also supports FileX.</span></span>

<span data-ttu-id="8c7bd-235">El archivo ***fx_nor_flash_simulated_driver. c*** contiene un controlador de FileX de ejemplo para su uso con la simulación flash NOR.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-235">The file ***fx_nor_flash_simulated_driver.c*** contains an example FileX driver for use with the NOR flash simulation.</span></span> <span data-ttu-id="8c7bd-236">El controlador NOR flash FileX para LevelX proporciona un buen punto de partida para escribir controladores FileX personalizados.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-236">The NOR flash FileX driver for LevelX provides a good starting point for writing custom FileX drivers.</span></span>

> [!NOTE]
> <span data-ttu-id="8c7bd-237">El formato flash FileX NOR debe tener un tamaño de bloque completo de sectores menos de lo que proporciona el flash NOR.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-237">The FileX NOR flash format should be one full block size of sectors less than the NOR flash provides.</span></span> <span data-ttu-id="8c7bd-238">Esto le ayudará a garantizar el mejor rendimiento durante el procesamiento de nivel de desgaste.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-238">This will help ensure best performance during the wear level processing.</span></span> <span data-ttu-id="8c7bd-239">Las técnicas adicionales para mejorar el rendimiento de escritura en el algoritmo de nivelación de desgaste de LevelX incluyen:</span><span class="sxs-lookup"><span data-stu-id="8c7bd-239">Additional techniques to improve write performance in the LevelX wear leveling algorithm include:</span></span>
> 1. <span data-ttu-id="8c7bd-240">Asegúrese de que todas las escrituras tienen exactamente uno o más clústeres de tamaño y comience en los límites exactos del clúster.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-240">Ensure that all writes are exactly one or more clusters in size and start on exact cluster boundaries.</span></span>
> 2. <span data-ttu-id="8c7bd-241">Asigne previamente los clústeres antes de realizar operaciones de escritura de archivos grandes a través de la clase de FileX ***fx_file_allocate*** de las API.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-241">Pre-allocate clusters before performing large file write operations via the FileX ***fx_file_allocate*** class of APIs.</span></span>
> 3.  <span data-ttu-id="8c7bd-242">Uso periódico de ***lx_nor_flash_defragment*** para liberar tantos como bloques NOR como sea posible y mejorar el rendimiento de escritura.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-242">Periodic use of ***lx_nor_flash_defragment*** to free up as many NOR blocks as possible and thus improve write performance.</span></span>
> 4. <span data-ttu-id="8c7bd-243">Asegúrese de que el controlador FileX está habilitado para recibir información del sector de la versión y que las solicitudes realizadas al controlador para liberar sectores se controlen en el controlador mediante una llamada a ***lx_nor_flash_sector_release***.</span><span class="sxs-lookup"><span data-stu-id="8c7bd-243">Ensure the FileX driver is enabled to receive release sector information and requests made to the driver to release sectors are handled in the driver by calling ***lx_nor_flash_sector_release***.</span></span>
