---
title: Compatibilidad con Azure RTOS LevelX NAND
description: La memoria flash NAND se utiliza normalmente dentro de LevelX para el almacenamiento de datos de gran tamaño, que es habitual en los sistemas de archivos.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 3286e4ea7f16b28ff55fc95a87a1e0c313ec4240
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 03/22/2021
ms.locfileid: "104814898"
---
# <a name="chapter-3---azure-rtos-levelx-nand-support"></a><span data-ttu-id="95f09-103">Capítulo 3: Compatibilidad con Azure RTOS LevelX NAND</span><span class="sxs-lookup"><span data-stu-id="95f09-103">Chapter 3 - Azure RTOS LevelX NAND support</span></span>

<span data-ttu-id="95f09-104">La memoria flash NAND se utiliza normalmente para el almacenamiento de datos de gran tamaño, que es habitual en los sistemas de archivos.</span><span class="sxs-lookup"><span data-stu-id="95f09-104">NAND flash memory is commonly utilized for large data storage, which is typical of file systems.</span></span> <span data-ttu-id="95f09-105">La memoria NAND consta de *bloques*.</span><span class="sxs-lookup"><span data-stu-id="95f09-105">NAND memory consists of *blocks*.</span></span> <span data-ttu-id="95f09-106">Dentro de cada bloque NAND hay una serie de *páginas*.</span><span class="sxs-lookup"><span data-stu-id="95f09-106">Within each NAND block is a series of *pages*.</span></span> <span data-ttu-id="95f09-107">Los bloques NAND se pueden borrar, lo que significa que todas las páginas del bloque NAND se borran (se establecen en todas).</span><span class="sxs-lookup"><span data-stu-id="95f09-107">NAND blocks are erasable, which means that all pages within the NAND block are erased (set to all ones).</span></span> <span data-ttu-id="95f09-108">Cada página de bloque NAND tiene un conjunto de *bytes de reserva* que usa Azure RTOS LevelX para la contabilidad, la administración de bloques defectuosa y la detección de errores.</span><span class="sxs-lookup"><span data-stu-id="95f09-108">Each NAND block page has a set of *spare bytes* that are utilized by Azure RTOS LevelX for bookkeeping, bad block management, and error detection.</span></span> <span data-ttu-id="95f09-109">Las páginas de bloque NAND están disponibles en varios tamaños.</span><span class="sxs-lookup"><span data-stu-id="95f09-109">NAND block pages are available in a variety of sizes.</span></span> <span data-ttu-id="95f09-110">Los tamaños de página más comunes son:</span><span class="sxs-lookup"><span data-stu-id="95f09-110">The most common page sizes are:</span></span> 

| <span data-ttu-id="95f09-111">**Tamaño de página**</span><span class="sxs-lookup"><span data-stu-id="95f09-111">**Page Size**</span></span> | <span data-ttu-id="95f09-112">**Bytes de reserva**</span><span class="sxs-lookup"><span data-stu-id="95f09-112">**Spare Bytes**</span></span> |
| ------------- | --------------- |
| <span data-ttu-id="95f09-113">256</span><span class="sxs-lookup"><span data-stu-id="95f09-113">256</span></span>           | <span data-ttu-id="95f09-114">8</span><span class="sxs-lookup"><span data-stu-id="95f09-114">8</span></span>               |
| <span data-ttu-id="95f09-115">512</span><span class="sxs-lookup"><span data-stu-id="95f09-115">512</span></span>           | <span data-ttu-id="95f09-116">16</span><span class="sxs-lookup"><span data-stu-id="95f09-116">16</span></span>              |
| <span data-ttu-id="95f09-117">2048</span><span class="sxs-lookup"><span data-stu-id="95f09-117">2048</span></span>          | <span data-ttu-id="95f09-118">64</span><span class="sxs-lookup"><span data-stu-id="95f09-118">64</span></span>              |

<span data-ttu-id="95f09-119">La memoria NAND se diferencia de la memoria NOR en que no hay acceso directo, es decir, la memoria NAND no se puede leer directamente desde el procesador como la memoria NOR.</span><span class="sxs-lookup"><span data-stu-id="95f09-119">NAND memory differs from NOR memory in that there is no direct access, i.e., NAND memory cannot be read directly from the processor like NOR memory.</span></span> <span data-ttu-id="95f09-120">La memoria NAND solo se puede escribir después de un borrado un número limitado de veces.</span><span class="sxs-lookup"><span data-stu-id="95f09-120">NAND memory can only be written to after an erase a limited number of times.</span></span> <span data-ttu-id="95f09-121">Nuevamente, esto difiere de la memoria NOR que se puede escribir un número ilimitado de veces siempre que la solicitud de escritura borre los bits establecidos.</span><span class="sxs-lookup"><span data-stu-id="95f09-121">Again, this differs from NOR memory that can be written an unlimited number of times providing the write request is clearing set bits.</span></span> <span data-ttu-id="95f09-122">Por último, los bytes de reserva asociados a cada página son únicos en flash NAND.</span><span class="sxs-lookup"><span data-stu-id="95f09-122">Finally, the spare bytes associated with each page are unique to NAND flash.</span></span> <span data-ttu-id="95f09-123">Las configuraciones de bytes de reserva típicas son como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="95f09-123">Typical spare byte configurations are as shown in the table below.</span></span>

| <span data-ttu-id="95f09-124">**Bytes de reserva**</span><span class="sxs-lookup"><span data-stu-id="95f09-124">**Spare Bytes**</span></span> | <span data-ttu-id="95f09-125">**Números de bytes**</span><span class="sxs-lookup"><span data-stu-id="95f09-125">**Byte numbers**</span></span> | <span data-ttu-id="95f09-126">**Configuración**</span><span class="sxs-lookup"><span data-stu-id="95f09-126">**Configuration**</span></span>     |
| ------------------------- | -------------- | --------------------- |
| <span data-ttu-id="95f09-127">8</span><span class="sxs-lookup"><span data-stu-id="95f09-127">8</span></span>                         | <span data-ttu-id="95f09-128">Bytes 0-2:</span><span class="sxs-lookup"><span data-stu-id="95f09-128">Bytes 0-2:</span></span>     | <span data-ttu-id="95f09-129">Bytes ECC</span><span class="sxs-lookup"><span data-stu-id="95f09-129">ECC bytes</span></span>             |
|                           | <span data-ttu-id="95f09-130">Bytes 3,4,6,7:</span><span class="sxs-lookup"><span data-stu-id="95f09-130">Bytes 3,4,6,7:</span></span> | <span data-ttu-id="95f09-131">Asignación del sector LevelX</span><span class="sxs-lookup"><span data-stu-id="95f09-131">LevelX Sector Mapping</span></span> |
|                           | <span data-ttu-id="95f09-132">Byte 5:</span><span class="sxs-lookup"><span data-stu-id="95f09-132">Byte 5:</span></span>        | <span data-ttu-id="95f09-133">Marca de bloque incorrecto</span><span class="sxs-lookup"><span data-stu-id="95f09-133">Bad block flag</span></span>        |
| <span data-ttu-id="95f09-134">16</span><span class="sxs-lookup"><span data-stu-id="95f09-134">16</span></span>                        | <span data-ttu-id="95f09-135">Bytes 0-3,6-7:</span><span class="sxs-lookup"><span data-stu-id="95f09-135">Bytes 0-3,6-7:</span></span> | <span data-ttu-id="95f09-136">Bytes ECC</span><span class="sxs-lookup"><span data-stu-id="95f09-136">ECC bytes</span></span>             |
|                           | <span data-ttu-id="95f09-137">Bytes 8-11:</span><span class="sxs-lookup"><span data-stu-id="95f09-137">Bytes 8-11:</span></span>    | <span data-ttu-id="95f09-138">Asignación del sector LevelX</span><span class="sxs-lookup"><span data-stu-id="95f09-138">LevelX Sector Mapping</span></span> |
|                           | <span data-ttu-id="95f09-139">Bytes 12-15:</span><span class="sxs-lookup"><span data-stu-id="95f09-139">Bytes 12-15:</span></span>   | <span data-ttu-id="95f09-140">No utilizado</span><span class="sxs-lookup"><span data-stu-id="95f09-140">Unused</span></span>                |
|                           | <span data-ttu-id="95f09-141">Byte 5:</span><span class="sxs-lookup"><span data-stu-id="95f09-141">Byte 5:</span></span>        | <span data-ttu-id="95f09-142">Marca de bloque incorrecto</span><span class="sxs-lookup"><span data-stu-id="95f09-142">Bad block flag</span></span>        |
| <span data-ttu-id="95f09-143">64</span><span class="sxs-lookup"><span data-stu-id="95f09-143">64</span></span>                        | <span data-ttu-id="95f09-144">Byte 0:</span><span class="sxs-lookup"><span data-stu-id="95f09-144">Byte 0:</span></span>        | <span data-ttu-id="95f09-145">Marca de bloque incorrecto</span><span class="sxs-lookup"><span data-stu-id="95f09-145">Bad block flag</span></span>        |
|                           | <span data-ttu-id="95f09-146">Bytes 2-5:</span><span class="sxs-lookup"><span data-stu-id="95f09-146">Bytes 2-5:</span></span>     | <span data-ttu-id="95f09-147">Asignación del sector LevelX</span><span class="sxs-lookup"><span data-stu-id="95f09-147">LevelX Sector Mapping</span></span> |
|                           | <span data-ttu-id="95f09-148">Bytes 6-39:</span><span class="sxs-lookup"><span data-stu-id="95f09-148">Bytes 6-39:</span></span>    | <span data-ttu-id="95f09-149">No utilizado</span><span class="sxs-lookup"><span data-stu-id="95f09-149">Unused</span></span>                |
|                           | <span data-ttu-id="95f09-150">Bytes 40-63:</span><span class="sxs-lookup"><span data-stu-id="95f09-150">Bytes 40-63:</span></span>   | <span data-ttu-id="95f09-151">Bytes ECC</span><span class="sxs-lookup"><span data-stu-id="95f09-151">ECC bytes</span></span>             |

<span data-ttu-id="95f09-152">LevelX emplea 4 de los bytes de reserva de cada página NAND para realizar un seguimiento del sector lógico asignado a la página física NAND.</span><span class="sxs-lookup"><span data-stu-id="95f09-152">LevelX Utilizes 4 of the spare bytes of each NAND page for keeping track of the logical sector mapped to the physical NAND page.</span></span> <span data-ttu-id="95f09-153">Estos 4 bytes se utilizan para implementar un entero sin signo de 32 bits con un formato de propietario LevelX.</span><span class="sxs-lookup"><span data-stu-id="95f09-153">These 4 bytes are used to implement a 32-bit unsigned integer with a LevelX proprietary format.</span></span> <span data-ttu-id="95f09-154">El bit superior del campo de 32 bits (bit 31) se usa para indicar que la asignación de sector a página lógica es válida.</span><span class="sxs-lookup"><span data-stu-id="95f09-154">The upper bit of the 32-bit field (bit 31) is used to indicate the logical sector-to-page mapping is valid.</span></span> <span data-ttu-id="95f09-155">Si este bit es 0, la información de esta página ya no es válida.</span><span class="sxs-lookup"><span data-stu-id="95f09-155">If this bit is 0, the information in this page is no longer valid.</span></span> <span data-ttu-id="95f09-156">El siguiente bit (bit 30) se usa para indicar que esta página está en proceso de ser obsoleta y se está escribiendo un nuevo sector.</span><span class="sxs-lookup"><span data-stu-id="95f09-156">The next bit—bit 30—is used to indicate this page is in the process of becoming obsolete and a new sector is being written.</span></span> <span data-ttu-id="95f09-157">El bit 29 se usa para indicar cuándo se ha completado la escritura de la entrada de asignación.</span><span class="sxs-lookup"><span data-stu-id="95f09-157">Bit 29 is used to indicate when the mapping entry write is complete.</span></span> <span data-ttu-id="95f09-158">Si el bit 29 es 0, se completa la escritura de la entrada de asignación.</span><span class="sxs-lookup"><span data-stu-id="95f09-158">If bit 29 is 0, the mapping entry write is complete.</span></span> <span data-ttu-id="95f09-159">Si se establece el bit 29, la entrada de asignación estaba en proceso de escritura.</span><span class="sxs-lookup"><span data-stu-id="95f09-159">If bit 29 is set, the mapping entry was in the process of being written.</span></span> <span data-ttu-id="95f09-160">Los bits 30 y 29 se usan para recuperarse de una posible pérdida de energía mientras se actualiza una nueva página Flash.</span><span class="sxs-lookup"><span data-stu-id="95f09-160">Bits 30 and 29 are used in recovering from a potential power loss while updating a new flash page.</span></span> <span data-ttu-id="95f09-161">Por último, los 29 bits inferiores (28-0) contienen el número de sector lógico de la página.</span><span class="sxs-lookup"><span data-stu-id="95f09-161">Finally, the lower 29-bits (28-0) contain the logical sector number for the page.</span></span>

<span data-ttu-id="95f09-162">**Entrada de asignación LevelX**</span><span class="sxs-lookup"><span data-stu-id="95f09-162">**LevelX Mapping Entry**</span></span>

| <span data-ttu-id="95f09-163">Bit(s)</span><span class="sxs-lookup"><span data-stu-id="95f09-163">Bit(s)</span></span> | <span data-ttu-id="95f09-164">Significado</span><span class="sxs-lookup"><span data-stu-id="95f09-164">Meaning</span></span> |
| ------ | ------- |
| <span data-ttu-id="95f09-165">31</span><span class="sxs-lookup"><span data-stu-id="95f09-165">31</span></span>     | <span data-ttu-id="95f09-166">Marca válida.</span><span class="sxs-lookup"><span data-stu-id="95f09-166">Valid flag.</span></span> <span data-ttu-id="95f09-167">Cuando se establece y el sector lógico no son todos, indica que la asignación es válida</span><span class="sxs-lookup"><span data-stu-id="95f09-167">When set and logical sector is not all ones indicates mapping is valid</span></span> |
| <span data-ttu-id="95f09-168">30</span><span class="sxs-lookup"><span data-stu-id="95f09-168">30</span></span>     | <span data-ttu-id="95f09-169">Marca obsoleta.</span><span class="sxs-lookup"><span data-stu-id="95f09-169">Obsolete flag.</span></span> <span data-ttu-id="95f09-170">Cuando está desactivada, esta asignación es obsoleta o está en proceso de ser obsoleta.</span><span class="sxs-lookup"><span data-stu-id="95f09-170">When clear, this mapping is either obsolete or is in the process of becoming obsolete.</span></span> |
| <span data-ttu-id="95f09-171">29</span><span class="sxs-lookup"><span data-stu-id="95f09-171">29</span></span>     | <span data-ttu-id="95f09-172">La escritura de entradas de asignación se completa cuando este bit es 0</span><span class="sxs-lookup"><span data-stu-id="95f09-172">Mapping entry write is complete when this bit is 0</span></span> |
| <span data-ttu-id="95f09-173">0-28</span><span class="sxs-lookup"><span data-stu-id="95f09-173">0-28</span></span>   | <span data-ttu-id="95f09-174">Sector lógico asignado a esta página física: no todos.</span><span class="sxs-lookup"><span data-stu-id="95f09-174">Logical sector mapped to this physical page—when not all ones.</span></span> |

<span data-ttu-id="95f09-175">LevelX también emplea la primera página de cada bloque NAND para el recuento de borrado de bloques, así como la lista de páginas asignadas cuando el bloque está lleno.</span><span class="sxs-lookup"><span data-stu-id="95f09-175">LevelX also utilizes the first page of each NAND block for the block erase count as well as the list of mapped pages when the block is full.</span></span> <span data-ttu-id="95f09-176">A continuación se muestra el formato de la primera página de un bloque NAND en LevelX:</span><span class="sxs-lookup"><span data-stu-id="95f09-176">The format of the first page of a NAND block in LevelX is shown below:</span></span>

| <span data-ttu-id="95f09-177">LevelX formato de página 0 de bloque</span><span class="sxs-lookup"><span data-stu-id="95f09-177">LevelX Block Page 0 Format</span></span> |
|:--------------------------:|
| <span data-ttu-id="95f09-178">[Recuento de borrado de bloques]</span><span class="sxs-lookup"><span data-stu-id="95f09-178">[Block Erase Count]</span></span>        |
| <span data-ttu-id="95f09-179">[Asignación del sector de la página 1]</span><span class="sxs-lookup"><span data-stu-id="95f09-179">[Page 1 Sector Mapping]</span></span>    |
| <span data-ttu-id="95f09-180">...</span><span class="sxs-lookup"><span data-stu-id="95f09-180">...</span></span>                        |
| <span data-ttu-id="95f09-181">[Asignación del sector de la página "n"]</span><span class="sxs-lookup"><span data-stu-id="95f09-181">[Page "n" Sector Mapping]</span></span>  |
| <span data-ttu-id="95f09-182">[0xF0F0F0F0]</span><span class="sxs-lookup"><span data-stu-id="95f09-182">[0xF0F0F0F0]</span></span>               |

> [!NOTE]
> <span data-ttu-id="95f09-183">La información de asignación de páginas solo se escribe cuando el bloque está lleno, es decir, se han escrito todas las páginas del bloque.</span><span class="sxs-lookup"><span data-stu-id="95f09-183">The page mapping information is only written when the block is full, i.e., all the pages of the block have been written to.</span></span> <span data-ttu-id="95f09-184">Esto permite una búsqueda más rápida de páginas gratuitas y la asignación de sectores lógicos durante el tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="95f09-184">This enables faster search for free pages and logical sector mapping during run-time.</span></span>

## <a name="nand-bad-block-support"></a><span data-ttu-id="95f09-185">Compatibilidad con bloques erróneos NAND</span><span class="sxs-lookup"><span data-stu-id="95f09-185">NAND Bad Block Support</span></span>

<span data-ttu-id="95f09-186">La memoria NAND tiene también más probabilidades de tener bloques no válidos que la memoria NOR.</span><span class="sxs-lookup"><span data-stu-id="95f09-186">NAND memory is also more likely to have bad blocks than NOR memory.</span></span> <span data-ttu-id="95f09-187">Esto se debe en gran medida a que los fabricantes de la NAND pueden aumentar la suspensión, ya que permiten bloques incorrectos y requieren software para solucionar estos bloques incorrectos.</span><span class="sxs-lookup"><span data-stu-id="95f09-187">This is largely because NAND manufacturers can increase yield by allowing bad blocks and requiring software to work-around such bad blocks.</span></span> <span data-ttu-id="95f09-188">LevelX manipula la administración de bloques erróneos NAND simplemente mediante la asignación de bloques no válidos.</span><span class="sxs-lookup"><span data-stu-id="95f09-188">LevelX handles NAND bad block management by simply mapping around bad blocks.</span></span>

<span data-ttu-id="95f09-189">LevelX también proporciona API para códigos de corrección de errores de Hamming (ECC) de 256 bytes para que el controlador LevelX subyacente los utilice para calcular nuevos códigos ECC o para realizar una corrección de errores de 1 bit en la lectura de la página dentro de cada sección de 256 bytes de la página.</span><span class="sxs-lookup"><span data-stu-id="95f09-189">LevelX also provides APIs for 256-byte Hamming Error Correction Codes (ECC) for the underlying LevelX driver to utilize for calculating new ECC codes or to perform 1-bit error correction on page reading within each 256-byte section of the page.</span></span>

## <a name="nand-driver-requirements"></a><span data-ttu-id="95f09-190">Requisitos para controladores NAND</span><span class="sxs-lookup"><span data-stu-id="95f09-190">NAND Driver Requirements</span></span>

<span data-ttu-id="95f09-191">LevelX requiere un controlador flash NAND subyacente que sea específico de la parte Flash subyacente y de la implementación de hardware.</span><span class="sxs-lookup"><span data-stu-id="95f09-191">LevelX requires an underlying NAND flash driver that is specific to the underlying flash part and hardware implementation.</span></span> <span data-ttu-id="95f09-192">El controlador se especifica en LevelX durante la inicialización a través de la API ***lx_nand_flash_open***.</span><span class="sxs-lookup"><span data-stu-id="95f09-192">The driver is specified to LevelX during initialization via the API ***lx_nand_flash_open***.</span></span> <span data-ttu-id="95f09-193">El prototipo del controlador LevelX es el siguiente.</span><span class="sxs-lookup"><span data-stu-id="95f09-193">The prototype of the LevelX driver is as follows.</span></span>

```c
INT nand_driver_initialize(LX_NAND_FLASH *instance);
```

<span data-ttu-id="95f09-194">El parámetro *instancia* especifica el bloque de control de LevelX NAND.</span><span class="sxs-lookup"><span data-stu-id="95f09-194">The *instance* parameter specifies the LevelX NAND control block.</span></span> <span data-ttu-id="95f09-195">La función de inicialización de controladores es responsable de configurar todos los demás servicios de nivel de controlador para la instancia de LevelX asociada.</span><span class="sxs-lookup"><span data-stu-id="95f09-195">The driver initialization function is responsible for setting up all the other driver-level services for the associated LevelX instance.</span></span> <span data-ttu-id="95f09-196">Los servicios necesarios para cada instancia de LevelX NAND se muestran en la lista siguiente.</span><span class="sxs-lookup"><span data-stu-id="95f09-196">The services required for each LevelX NAND instance are shown in the list below.</span></span>

- <span data-ttu-id="95f09-197">Leer página</span><span class="sxs-lookup"><span data-stu-id="95f09-197">Read Page</span></span>
- <span data-ttu-id="95f09-198">Escribir página</span><span class="sxs-lookup"><span data-stu-id="95f09-198">Write Page</span></span>
- <span data-ttu-id="95f09-199">Borrado de bloque</span><span class="sxs-lookup"><span data-stu-id="95f09-199">Block Erase</span></span>
- <span data-ttu-id="95f09-200">Comprobación de bloque borrado</span><span class="sxs-lookup"><span data-stu-id="95f09-200">Block Erased Verify</span></span>
- <span data-ttu-id="95f09-201">Comprobación de página borrada</span><span class="sxs-lookup"><span data-stu-id="95f09-201">Page Erased Verify</span></span>
- <span data-ttu-id="95f09-202">Estado de bloque get</span><span class="sxs-lookup"><span data-stu-id="95f09-202">Block Status Get</span></span>
- <span data-ttu-id="95f09-203">Estado de bloque set</span><span class="sxs-lookup"><span data-stu-id="95f09-203">Block Status Set</span></span>
- <span data-ttu-id="95f09-204">Bytes adicionales del bloque get</span><span class="sxs-lookup"><span data-stu-id="95f09-204">Block Extra Bytes Get</span></span>
- <span data-ttu-id="95f09-205">Bytes adicionales del bloque set</span><span class="sxs-lookup"><span data-stu-id="95f09-205">Block Extra Bytes Set</span></span>
- <span data-ttu-id="95f09-206">Controlador de errores del sistema</span><span class="sxs-lookup"><span data-stu-id="95f09-206">System Error Handler</span></span>

## <a name="driver-initialization"></a><span data-ttu-id="95f09-207">Inicialización del controlador</span><span class="sxs-lookup"><span data-stu-id="95f09-207">Driver Initialization</span></span>

<span data-ttu-id="95f09-208">Estos servicios se configuran mediante el establecimiento de punteros de función en la instancia de **LX_NAND_FLASH** dentro de la función de inicialización del controlador.</span><span class="sxs-lookup"><span data-stu-id="95f09-208">These services are setup via setting function pointers in the **LX_NAND_FLASH** instance within the driver's initialization function.</span></span> <span data-ttu-id="95f09-209">La función de inicialización del controlador también especifica el número total de bloques, páginas por bloque, bytes por página y un área de RAM lo suficientemente grande como para leer una página en la memoria.</span><span class="sxs-lookup"><span data-stu-id="95f09-209">The driver initialization function also specifies the total number of block, pages per block, bytes per page, and a RAM area large enough to read one page into memory.</span></span> <span data-ttu-id="95f09-210">La función de inicialización del controlador también realiza tareas adicionales de inicialización específicas del dispositivo o de la implementación antes de devolver **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="95f09-210">The driver initialization function likely also performs additional device and/or implementation-specific initialization duties before returning **LX_SUCCESS**.</span></span>

## <a name="driver-read-page"></a><span data-ttu-id="95f09-211">Página de lectura del controlador</span><span class="sxs-lookup"><span data-stu-id="95f09-211">Driver Read Page</span></span>

<span data-ttu-id="95f09-212">El servicio "página de lectura" del controlador NAND LevelX es responsable de leer una página específica en un bloque específico del flash NAND.</span><span class="sxs-lookup"><span data-stu-id="95f09-212">The LevelX NAND driver "read page" service is responsible for reading a specific page in a specific block of the NAND flash.</span></span> <span data-ttu-id="95f09-213">Todas las comprobaciones de errores y la lógica de corrección son responsabilidad del servicio de controlador.</span><span class="sxs-lookup"><span data-stu-id="95f09-213">All error checking and correcting logic is the responsibility of the driver service.</span></span> <span data-ttu-id="95f09-214">Si se realiza correctamente, el controlador LevelX NAND devuelve **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="95f09-214">If successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="95f09-215">Si no se realiza correctamente, el controlador LevelX NAND devuelve **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="95f09-215">If not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="95f09-216">A continuación se proporciona el prototipo del servicio "leer página" del controlador LevelX NAND.</span><span class="sxs-lookup"><span data-stu-id="95f09-216">The prototype of the LevelX NAND driver "read page" service is given below.</span></span>

```c
INT nand_driver_read_page(
    ULONG block,
    ULONG page,
    ULONG *destination, 
    ULONG words);
```

<span data-ttu-id="95f09-217">Donde el *bloque* y la *página* identifican la página que se va a leer y el *destino*, y las *palabras* especifican dónde se debe colocar el contenido de la página y cuántas palabras de 32 bits se van a leer.</span><span class="sxs-lookup"><span data-stu-id="95f09-217">Where *block* and *page* identify which page to read and *destination* and *words* specify where to place the page contents and how many 32-bit words to read.</span></span>

## <a name="driver-write-page"></a><span data-ttu-id="95f09-218">Página de escritura del controlador</span><span class="sxs-lookup"><span data-stu-id="95f09-218">Driver Write Page</span></span>

<span data-ttu-id="95f09-219">El servicio "página de escritura" del controlador NAND LevelX es responsable de escribir una página específica en el bloque especificado del flash NAND.</span><span class="sxs-lookup"><span data-stu-id="95f09-219">The LevelX NAND driver "write page" service is responsible for writing a specific page into the specified block of the NAND flash.</span></span> <span data-ttu-id="95f09-220">La comprobación de errores y el cálculo ECC son responsabilidad del servicio de controlador.</span><span class="sxs-lookup"><span data-stu-id="95f09-220">All error checking and ECC computation is the responsibility of the driver service.</span></span> <span data-ttu-id="95f09-221">Si se realiza correctamente, el controlador LevelX NAND devuelve **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="95f09-221">If successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="95f09-222">Si no se realiza correctamente, el controlador LevelX NAND devuelve **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="95f09-222">If not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="95f09-223">A continuación se muestra el prototipo del servicio "página de escritura" del controlador LevelX NAND.</span><span class="sxs-lookup"><span data-stu-id="95f09-223">The prototype of the LevelX NAND driver "write page" service is shown below.</span></span>

```c
INT nand_driver_write_page(
    ULONG block, 
    ULONG page,
    ULONG *source, 
    ULONG words);
```

<span data-ttu-id="95f09-224">Donde el *bloque* y la *página* identifican la página que se va a escribir y el *origen* y las *palabras* especifican el origen de la escritura y el número de palabras de 32 bits que se van a escribir.</span><span class="sxs-lookup"><span data-stu-id="95f09-224">Where *block* and *page* identify which page to write and *source* and *words* specify the source of the write and how many 32-bit words to write.</span></span>

> [!NOTE]
> <span data-ttu-id="95f09-225">LevelX se basa en el controlador para la detección de errores de bajo nivel al escribir en la página Flash, lo que normalmente implica volver a leer la página y compararla con el búfer de escritura para asegurarse de que la escritura se realizó correctamente.</span><span class="sxs-lookup"><span data-stu-id="95f09-225">LevelX relies on the driver for low-level error detection when writing to the flash page, which typically involves reading back the page and comparing with the write buffer to ensure the write was successful.</span></span>

## <a name="driver-block-erase"></a><span data-ttu-id="95f09-226">Borrado de bloque de controlador</span><span class="sxs-lookup"><span data-stu-id="95f09-226">Driver Block Erase</span></span>

<span data-ttu-id="95f09-227">El servicio "eliminación de bloques" del controlador NAND LevelX es responsable de borrar el bloque especificado del flash NAND.</span><span class="sxs-lookup"><span data-stu-id="95f09-227">The LevelX NAND driver "block erase" service is responsible for erasing the specified block of the NAND flash.</span></span> <span data-ttu-id="95f09-228">Si se realiza correctamente, el controlador LevelX NAND devuelve **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="95f09-228">If successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="95f09-229">Si no se realiza correctamente, el controlador LevelX NAND devuelve **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="95f09-229">If not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="95f09-230">El prototipo del servicio "borrado de bloque" de LevelX NAND es el siguiente.</span><span class="sxs-lookup"><span data-stu-id="95f09-230">The prototype of the LevelX NAND driver "block erase" service is as follows.</span></span>

```c
INT nand_driver_block_erase(ULONG block,  
    ULONG erase_count);
```

<span data-ttu-id="95f09-231">Donde *bloque* identifica el bloque que se va a borrar.</span><span class="sxs-lookup"><span data-stu-id="95f09-231">Where *block* identifies which block to erase.</span></span> <span data-ttu-id="95f09-232">El parámetro *erase_count* se proporciona con fines de diagnóstico.</span><span class="sxs-lookup"><span data-stu-id="95f09-232">The parameter *erase_count* is provided for diagnostic purposes.</span></span> <span data-ttu-id="95f09-233">Por ejemplo, el controlador puede querer alertar a otra parte del software de la aplicación cuando el recuento de borrado supera un umbral específico.</span><span class="sxs-lookup"><span data-stu-id="95f09-233">For example, the driver may want to alert another portion of the application software when the erase count exceeds a specific threshold.</span></span>

> [!NOTE]
> <span data-ttu-id="95f09-234">LevelX se basa en el controlador para la detección de errores de bajo nivel cuando se borra el bloque, lo que normalmente implica asegurarse de que todas las páginas del bloque son todas.</span><span class="sxs-lookup"><span data-stu-id="95f09-234">LevelX relies on the driver for low-level error detection when the block is erased, which typically involves ensuring that all pages of the block are all ones.</span></span>

## <a name="driver-block-erased-verify"></a><span data-ttu-id="95f09-235">Comprobación de borrado de bloque de controlador</span><span class="sxs-lookup"><span data-stu-id="95f09-235">Driver Block Erased Verify</span></span>

<span data-ttu-id="95f09-236">El servicio "comprobación de borrado de bloque" del controlador LevelX es responsable de comprobar que se borra el bloque especificado del flash NAND.</span><span class="sxs-lookup"><span data-stu-id="95f09-236">The LevelX NAND driver "block erased verify" service is responsible for verifying that the specified block of the NAND flash is erased.</span></span> <span data-ttu-id="95f09-237">Si se borra, el controlador LevelX NAND devuelve **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="95f09-237">If it is erased, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="95f09-238">Si no se borra el bloque, el controlador LevelX NAND devuelve **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="95f09-238">If the block is not erased, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="95f09-239">El prototipo del servicio "comprobación de borrado de bloque" del controlador LevelX NAND es el siguiente:</span><span class="sxs-lookup"><span data-stu-id="95f09-239">The prototype of the LevelX NAND driver "block erased verify" service is:</span></span>

```c
INT nand_driver_block_erased_verify(ULONG block);
```

<span data-ttu-id="95f09-240">Donde *bloque* especifica el bloque que se va a comprobar que se ha borrado.</span><span class="sxs-lookup"><span data-stu-id="95f09-240">Where *block* specifies which block to verify that it is erased.</span></span>

> [!NOTE]
> <span data-ttu-id="95f09-241">LevelX se basa en el controlador para examinar todas las páginas y todos los bytes de cada página, incluidos los bytes de reserva y de datos, para asegurarse de que se borran (contienen todos ellos).</span><span class="sxs-lookup"><span data-stu-id="95f09-241">LevelX relies on the driver to examine all pages and all bytes of each page – including spare and data bytes – to ensure they are erased (contain all ones).</span></span>

## <a name="driver-page-erased-verify"></a><span data-ttu-id="95f09-242">Comprobación de borrado de la página del controlador</span><span class="sxs-lookup"><span data-stu-id="95f09-242">Driver Page Erased Verify</span></span>

<span data-ttu-id="95f09-243">El servicio LevelX NAND "comprobación de borrado de página" es responsable de comprobar que la página especificada del bloque especificado del flash NAND está borrada.</span><span class="sxs-lookup"><span data-stu-id="95f09-243">The LevelX NAND driver "page erased verify" service is responsible for verifying that the specified page of the specified block of the NAND flash is erased.</span></span> <span data-ttu-id="95f09-244">Si se borra, el controlador LevelX NAND devuelve **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="95f09-244">If it is erased, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="95f09-245">Si la página no se borra, el controlador LevelX NAND devuelve **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="95f09-245">If the page is not erased, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="95f09-246">El prototipo del servicio LevelX NAND "comprobación de borrado de página" es:</span><span class="sxs-lookup"><span data-stu-id="95f09-246">The prototype of the LevelX NAND driver "page erased verify" service is:</span></span>

```c
INT nand_driver_page_erased_verify(
    ULONG block,  
    ULONG page);
```
<span data-ttu-id="95f09-247">Donde *bloque* especifica qué bloque y *página* especifica la página para comprobar que se ha borrado.</span><span class="sxs-lookup"><span data-stu-id="95f09-247">Where *block* specifies which block and *page* specifies the page to verify that it is erased.</span></span>

> [!NOTE]
> <span data-ttu-id="95f09-248">LevelX se basa en el controlador para examinar todos los bytes de la página especificada, incluidos los bytes de reserva y de datos, para asegurarse de que se borran (contienen todos ellos).</span><span class="sxs-lookup"><span data-stu-id="95f09-248">LevelX relies on the driver to examine all bytes of the specified page – including spare and data bytes – to ensure they are erased (contain all ones).</span></span>

## <a name="driver-block-status-get"></a><span data-ttu-id="95f09-249">Estado del bloque de controlador get</span><span class="sxs-lookup"><span data-stu-id="95f09-249">Driver Block Status Get</span></span>

<span data-ttu-id="95f09-250">El servicio "estado del bloque get" del controlador NAND LevelX es responsable de recuperar la marca de bloque incorrecto del bloque especificado del flash NAND.</span><span class="sxs-lookup"><span data-stu-id="95f09-250">The LevelX NAND driver "block status get" service is responsible for retrieving the bad block flag of the specified block of the NAND flash.</span></span> <span data-ttu-id="95f09-251">Si se realiza correctamente, el controlador LevelX NAND devuelve **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="95f09-251">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="95f09-252">Si no se realiza correctamente, el controlador LevelX NAND devuelve **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="95f09-252">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="95f09-253">El prototipo del servicio "estado del bloque get" del controlador LevelX NAND es: se muestra a continuación.</span><span class="sxs-lookup"><span data-stu-id="95f09-253">The prototype of the LevelX NAND driver "block status get" service is: shown below.</span></span>

```c
INT nand_driver_block_status_get(
    ULONG block,  
    UCHAR *bad_block_byte);
```

<span data-ttu-id="95f09-254">Donde *bloque* especifica qué bloque y *bad_block_byte* especifican el destino de la marca de bloque erróneo.</span><span class="sxs-lookup"><span data-stu-id="95f09-254">Where *block* specifies which block and *bad_block_byte* specifies the destination for the bad block flag.</span></span>

## <a name="driver-block-status-set"></a><span data-ttu-id="95f09-255">Estado de bloque del controlador set</span><span class="sxs-lookup"><span data-stu-id="95f09-255">Driver Block Status Set</span></span>

<span data-ttu-id="95f09-256">El servicio "estado de bloque set" del controlador NAND LevelX es responsable de establecer la marca de bloque erróneo del bloque especificado del flash NAND.</span><span class="sxs-lookup"><span data-stu-id="95f09-256">The LevelX NAND driver "block status set" service is responsible for setting the bad block flag of the specified block of the NAND flash.</span></span> <span data-ttu-id="95f09-257">Si se realiza correctamente, el controlador LevelX NAND devuelve **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="95f09-257">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="95f09-258">Si no se realiza correctamente, el controlador LevelX NAND devuelve **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="95f09-258">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="95f09-259">El prototipo del servicio "estado de bloque set" del controlador LevelX NAND es:</span><span class="sxs-lookup"><span data-stu-id="95f09-259">The prototype of the LevelX NAND driver "block status set" service is:</span></span>

```c
INT nand_driver_block_status_set(
    ULONG block,
    UCHAR bad_block_byte);
```

<span data-ttu-id="95f09-260">Donde *bloque* especifica qué bloque y *bad_block_byte* especifican el valor de la marca de bloque erróneo.</span><span class="sxs-lookup"><span data-stu-id="95f09-260">Where *block* specifies which block and *bad_block_byte* specifies the value of the bad block flag.</span></span>

## <a name="driver-block-extra-bytes-get"></a><span data-ttu-id="95f09-261">Bytes adicionales del bloque de controlador get</span><span class="sxs-lookup"><span data-stu-id="95f09-261">Driver Block Extra Bytes Get</span></span>

<span data-ttu-id="95f09-262">El servicio del controlador LevelX NAND "bytes adicionales del bloque get" es responsable de recuperar los bytes adicionales asociados a una página específica de un bloque específico del flash NAND.</span><span class="sxs-lookup"><span data-stu-id="95f09-262">The LevelX NAND driver "block extra bytes get" service is responsible for retrieving extra bytes associated with a specific page of a specific block of the NAND flash.</span></span> <span data-ttu-id="95f09-263">Si se realiza correctamente, el controlador LevelX NAND devuelve **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="95f09-263">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="95f09-264">Si no se realiza correctamente, el controlador LevelX NAND devuelve **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="95f09-264">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="95f09-265">El prototipo del servicio "bytes adicionales del bloque get" del controlador LevelX NAND es:</span><span class="sxs-lookup"><span data-stu-id="95f09-265">The prototype of the LevelX NAND driver "block extra bytes get" service is:</span></span>

```c
INT nand_driver_block_extra_bytes_get(
    ULONG block,  
    ULONG page, 
    UCHAR *destination, 
    UINT size);
```

<span data-ttu-id="95f09-266">Donde *bloque* especifica qué bloque, *página* especifica la página y el *destino* específicos especifican el destino de los bytes adicionales.</span><span class="sxs-lookup"><span data-stu-id="95f09-266">Where *block* specifies which block, *page* specifies the specific page and *destination* specifies the destination for the extra bytes.</span></span> <span data-ttu-id="95f09-267">El *tamaño* del parámetro especifica el número de bytes adicionales que se van a obtener.</span><span class="sxs-lookup"><span data-stu-id="95f09-267">The parameter *size* specifies how many extra bytes to get.</span></span>

## <a name="driver-block-extra-bytes-set"></a><span data-ttu-id="95f09-268">Bytes adicionales del bloque de controlador set</span><span class="sxs-lookup"><span data-stu-id="95f09-268">Driver Block Extra Bytes Set</span></span>

<span data-ttu-id="95f09-269">El servicio del controlador LevelX NAND "bytes adicionales de bloque set" es responsable de establecer bytes adicionales en una página específica de un bloque específico del flash NAND.</span><span class="sxs-lookup"><span data-stu-id="95f09-269">The LevelX NAND driver "block extra bytes set" service is responsible for setting extra bytes in a specific page of a specific block of the NAND flash.</span></span> <span data-ttu-id="95f09-270">Si se realiza correctamente, el controlador LevelX NAND devuelve **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="95f09-270">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="95f09-271">Si no se realiza correctamente, el controlador LevelX NAND devuelve **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="95f09-271">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="95f09-272">El prototipo del servicio del controlador LevelX NAND "bytes adicionales de bloque set" es:</span><span class="sxs-lookup"><span data-stu-id="95f09-272">The prototype of the LevelX NAND driver "block extra bytes set" service is:</span></span>

```c
INT nand_driver_block_extra_bytes_set(
    ULONG block,  
    ULONG page, 
    UCHAR *source, 
    UINT size);
```

<span data-ttu-id="95f09-273">Donde *bloque* especifica qué bloque, *página* especifica la página y el *origen* específicos especifican el origen de los bytes adicionales.</span><span class="sxs-lookup"><span data-stu-id="95f09-273">Where *block* specifies which block, *page* specifies the specific page and *source* specifies the source of the extra bytes.</span></span> <span data-ttu-id="95f09-274">El *tamaño* del parámetro especifica el número de bytes adicionales que se van a establecer.</span><span class="sxs-lookup"><span data-stu-id="95f09-274">The parameter *size* specifies how many extra bytes to set.</span></span>

## <a name="driver-system-error"></a><span data-ttu-id="95f09-275">Error del sistema de controladores</span><span class="sxs-lookup"><span data-stu-id="95f09-275">Driver System Error</span></span>

<span data-ttu-id="95f09-276">El servicio "errores del sistema" del controlador NAND LevelX es responsable de establecer el control de los errores del sistema detectados por LevelX.</span><span class="sxs-lookup"><span data-stu-id="95f09-276">The LevelX NAND driver "system error handler" service is responsible for setting handling system errors detected by LevelX.</span></span> <span data-ttu-id="95f09-277">El procesamiento en esta rutina depende de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="95f09-277">The processing in this routine is application dependent.</span></span> <span data-ttu-id="95f09-278">Si se realiza correctamente, el controlador LevelX NAND devuelve **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="95f09-278">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="95f09-279">Si no se realiza correctamente, el controlador LevelX NAND devuelve **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="95f09-279">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="95f09-280">El prototipo del servicio "error del sistema" del controlador NAND LevelX es:</span><span class="sxs-lookup"><span data-stu-id="95f09-280">The prototype of the LevelX NAND driver "system error" service is:</span></span>

```c
INT nand_driver_system_error(
    UINT error_code,  
    ULONG block, 
    ULONG page);
```

<span data-ttu-id="95f09-281">Donde *bloque* especifica el bloque y la *página* especifican la página específica en que se produjo el error representada por *error_code*.</span><span class="sxs-lookup"><span data-stu-id="95f09-281">Where *block* specifies which block, and *page* specifies the specific page the error represented by *error_code* occurred.</span></span>

## <a name="nand-simulated-driver"></a><span data-ttu-id="95f09-282">Controlador simulado NAND</span><span class="sxs-lookup"><span data-stu-id="95f09-282">NAND Simulated Driver</span></span>

<span data-ttu-id="95f09-283">LevelX proporciona un controlador flash NAND simulado que simplemente usa RAM para simular el funcionamiento de una parte flash NAND.</span><span class="sxs-lookup"><span data-stu-id="95f09-283">LevelX provides a simulated NAND flash driver that simply uses RAM to simulate the operation of a NAND flash part.</span></span> <span data-ttu-id="95f09-284">De manera predeterminada, el controlador simulado NAND proporciona 8 bloques flash NAND con 16 páginas por bloque y 2048 bytes por página.</span><span class="sxs-lookup"><span data-stu-id="95f09-284">By default, the NAND simulated driver provides 8 NAND flash blocks with 16 pages per block and 2048 bytes per page.</span></span>

<span data-ttu-id="95f09-285">La función de inicialización del controlador flash NAND simulado es \***lx_nand_flash_simulator_initialize** _ y se define en _ \*_lx_nand_flash_simulator.c_\*\*.</span><span class="sxs-lookup"><span data-stu-id="95f09-285">The simulated NAND flash driver initialization function is ***lx_nand_flash_simulator_initialize** _ and is defined in _*_lx_nand_flash_simulator.c_\*\*.</span></span> <span data-ttu-id="95f09-286">Este controlador también proporciona una buena plantilla para escribir controladores flash NAND específicos.</span><span class="sxs-lookup"><span data-stu-id="95f09-286">This driver also provides a good template for writing specific NAND flash drivers.</span></span>

## <a name="nand-filex-integration"></a><span data-ttu-id="95f09-287">Integración de FileX NAND</span><span class="sxs-lookup"><span data-stu-id="95f09-287">NAND FileX Integration</span></span>

<span data-ttu-id="95f09-288">Como se mencionó anteriormente, LevelX no se basa en FileX para su funcionamiento.</span><span class="sxs-lookup"><span data-stu-id="95f09-288">As mentioned earlier, LevelX does not rely on FileX for operation.</span></span> <span data-ttu-id="95f09-289">El software de la aplicación puede llamar directamente a todas las API de LevelX para almacenar o recuperar datos sin procesar en los sectores lógicos proporcionados por LevelX.</span><span class="sxs-lookup"><span data-stu-id="95f09-289">All the LevelX APIs may be called directly by the application software to store/retrieve raw data to the logical sectors provided by LevelX.</span></span> <span data-ttu-id="95f09-290">Sin embargo, LevelX también admite FileX.</span><span class="sxs-lookup"><span data-stu-id="95f09-290">However, LevelX also supports FileX.</span></span>

<span data-ttu-id="95f09-291">El archivo ***fx_nand_flash_simulated_driver.c*** contiene un controlador FileX de ejemplo para su uso con la simulación flash NAND.</span><span class="sxs-lookup"><span data-stu-id="95f09-291">The file ***fx_nand_flash_simulated_driver.c*** contains an example FileX driver for use with the NAND flash simulation.</span></span> <span data-ttu-id="95f09-292">Un aspecto interesante de este controlador es que combina los sectores lógicos de 512 bytes que usa normalmente FileX en las solicitudes de lectura y escritura de un solo sector lógico en el simulador LevelX mediante páginas de 2048 bytes.</span><span class="sxs-lookup"><span data-stu-id="95f09-292">An interesting aspect of this driver is that it combines 512-byte logical sectors typically used by FileX into single logical sector read/write requests to the LevelX simulator using 2048-byte pages.</span></span> <span data-ttu-id="95f09-293">Esto da como resultado un uso más eficaz de la memoria flash NAND.</span><span class="sxs-lookup"><span data-stu-id="95f09-293">This results in more efficient use of the NAND flash memory.</span></span> <span data-ttu-id="95f09-294">El controlador FileX flash NAND para LevelX proporciona un buen punto de partida para escribir controladores FileX personalizados.</span><span class="sxs-lookup"><span data-stu-id="95f09-294">The NAND flash FileX driver for LevelX provides a good starting point for writing custom FileX drivers.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="95f09-295">El formato Flash FileX NAND debe ser un tamaño de bloque completo de sectores inferior al que proporciona flash NAND.</span><span class="sxs-lookup"><span data-stu-id="95f09-295">The FileX NAND flash format should be one full block size of sectors less than the NAND flash provides.</span></span> <span data-ttu-id="95f09-296">Esto le ayudará a garantizar el mejor rendimiento durante el procesamiento de nivel de desgaste.</span><span class="sxs-lookup"><span data-stu-id="95f09-296">This will help ensure best performance during the wear level processing.</span></span> <span data-ttu-id="95f09-297">Las técnicas adicionales para mejorar el rendimiento de escritura en el algoritmo de nivelación de desgaste de LevelX son las siguientes.</span><span class="sxs-lookup"><span data-stu-id="95f09-297">Additional techniques to improve write performance in the LevelX wear leveling algorithm include the following.</span></span>

1. <span data-ttu-id="95f09-298">Asegúrese de que todas las escrituras tienen exactamente uno o más clústeres de tamaño y comience en los límites exactos del clúster.</span><span class="sxs-lookup"><span data-stu-id="95f09-298">Ensure that all writes are exactly one or more clusters in size and start on exact cluster boundaries.</span></span>
1. <span data-ttu-id="95f09-299">Asigne previamente los clústeres antes de realizar operaciones de escritura de archivos grandes a través de la clase de FileX ***fx_file_allocate*** de las API.</span><span class="sxs-lookup"><span data-stu-id="95f09-299">Pre-allocate clusters before performing large file write operations via the FileX ***fx_file_allocate*** class of APIs.</span></span>
1. <span data-ttu-id="95f09-300">Asegúrese de que el controlador FileX está habilitado para recibir información del sector de la versión y que las solicitudes realizadas al controlador para liberar sectores se controlen en el controlador mediante una llamada a ***lx_nor_flash_sector_release***.</span><span class="sxs-lookup"><span data-stu-id="95f09-300">Ensure the FileX driver is enabled to receive release sector information and requests made to the driver to release sectors are handled in the driver by calling ***lx_nor_flash_sector_release***.</span></span>
1. <span data-ttu-id="95f09-301">Uso periódico de ***lx_nand_flash_defragment*** para liberar tantos bloques NAND como sea posible y, por tanto, mejorar el rendimiento de escritura.</span><span class="sxs-lookup"><span data-stu-id="95f09-301">Periodic use of ***lx_nand_flash_defragment*** to free up as many NAND blocks as possible and thus improve write performance.</span></span>
1. <span data-ttu-id="95f09-302">Use la API de ***lx_nand_flash_extended_cache_enable*** para proporcionar una memoria caché de RAM de varios recursos de bloque NAND para obtener un rendimiento más rápido.</span><span class="sxs-lookup"><span data-stu-id="95f09-302">Utilize the ***lx_nand_flash_extended_cache_enable*** API to provide a RAM cache of various NAND block resources for faster performance.</span></span>
