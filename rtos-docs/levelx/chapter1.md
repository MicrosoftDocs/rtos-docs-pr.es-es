---
title: 'Capítulo 1: Información general de Azure RTOS LevelX'
description: Azure RTOS LevelX proporciona instalaciones de redistribución del uso de flash NAND y NOR en aplicaciones insertadas.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 045446fec74164f125bc0ad27e8b7a904be14ab2
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 03/22/2021
ms.locfileid: "104814902"
---
# <a name="chapter-1---overview-of-azure-rtos-levelx"></a><span data-ttu-id="925f9-103">Capítulo 1: Información general de Azure RTOS LevelX</span><span class="sxs-lookup"><span data-stu-id="925f9-103">Chapter 1 - Overview of Azure RTOS LevelX</span></span>

<span data-ttu-id="925f9-104">Azure RTOS LevelX proporciona instalaciones de redistribución del uso de flash NAND y NOR en aplicaciones insertadas.</span><span class="sxs-lookup"><span data-stu-id="925f9-104">Azure RTOS LevelX provides NAND and NOR flash wear leveling facilities to embedded applications.</span></span> <span data-ttu-id="925f9-105">Dado que la memoria flash NAND y NOR solo se puede borrar un número finito de veces, es fundamental distribuir el uso de la memoria flash uniformemente.</span><span class="sxs-lookup"><span data-stu-id="925f9-105">Since both NAND and NOR flash memory can only be erased a finite number of times, it's critical to distribute the flash memory use evenly.</span></span> <span data-ttu-id="925f9-106">Esto se suele denominar "desgaste de la nivelación" y es el objetivo de LevelX.</span><span class="sxs-lookup"><span data-stu-id="925f9-106">This is typically called "wear leveling" and is the purpose behind LevelX.</span></span>

<span data-ttu-id="925f9-107">El algoritmo que elige el bloque flash que se va a reutilizar se basa principalmente en el recuento de borrado, pero no en su totalidad.</span><span class="sxs-lookup"><span data-stu-id="925f9-107">The algorithm that chooses which flash block to reuse is primarily based on the erase count, but not entirely.</span></span> <span data-ttu-id="925f9-108">No se puede elegir el bloque con el menor número de borrado si hay otro bloque con un recuento de borrado dentro de un delta aceptable del recuento mínimo de borrados y tiene un número mayor de asignaciones obsoletas.</span><span class="sxs-lookup"><span data-stu-id="925f9-108">The block with the lowest erase count might not be chosen if there is another block that has an erase count within an acceptable delta from the minimal erase count and that has a greater number of obsolete mappings.</span></span> <span data-ttu-id="925f9-109">En tales casos, el bloque con el mayor número de asignaciones obsoletas se borrará y reutilizará, con lo que se ahorrará la sobrecarga de mover entradas de asignación válidas.</span><span class="sxs-lookup"><span data-stu-id="925f9-109">In such cases, the block with the greatest number of obsolete mappings will be erased and reused, thus saving overhead in moving valid mapping entries.</span></span>

<span data-ttu-id="925f9-110">LevelX admite varias instancias de las partes NAND o NOR, es decir, la aplicación puede usar instancias independientes de LevelX en la misma aplicación.</span><span class="sxs-lookup"><span data-stu-id="925f9-110">LevelX supports multiple instances of NAND and/or NOR parts, i.e., the application can utilize separate instances of LevelX within the same application.</span></span> <span data-ttu-id="925f9-111">Cada instancia requiere su propio bloque de control proporcionado por la aplicación, así como su propio controlador flash.</span><span class="sxs-lookup"><span data-stu-id="925f9-111">Each instance requires its own control block provided by the application as well as its own flash driver.</span></span>

<span data-ttu-id="925f9-112">LevelX presenta al usuario una matriz de sectores lógicos que se asignan a la memoria flash física dentro de LevelX.</span><span class="sxs-lookup"><span data-stu-id="925f9-112">LevelX presents to the user an array of logical sectors that are mapped to physical flash memory inside of LevelX.</span></span> <span data-ttu-id="925f9-113">Para mejorar el rendimiento, LevelX también proporciona una memoria caché de las asignaciones de sectores lógicos más recientes.</span><span class="sxs-lookup"><span data-stu-id="925f9-113">To enhance performance, LevelX also provides a cache of the most recent logical sector mappings.</span></span> <span data-ttu-id="925f9-114">El programador define el tamaño de esta memoria caché.</span><span class="sxs-lookup"><span data-stu-id="925f9-114">The size of this cache is defined by the programmer.</span></span> <span data-ttu-id="925f9-115">Las aplicaciones pueden usar LevelX junto con FileX o pueden leer o escribir sectores lógicos directamente.</span><span class="sxs-lookup"><span data-stu-id="925f9-115">Applications may use LevelX in conjunction with FileX or may read/write logical sectors directly.</span></span> <span data-ttu-id="925f9-116">LevelX no tiene ninguna dependencia en FileX y muy poca dependencia en ThreadX (solo se usan tipos de datos ThreadX primitivos).</span><span class="sxs-lookup"><span data-stu-id="925f9-116">LevelX has no dependency on FileX and very little dependency on ThreadX (only primitive ThreadX data types are used).</span></span>

<span data-ttu-id="925f9-117">LevelX está diseñado para la tolerancia a errores.</span><span class="sxs-lookup"><span data-stu-id="925f9-117">LevelX is designed for fault tolerance.</span></span> <span data-ttu-id="925f9-118">Las actualizaciones de flash se realizan en un proceso de varios pasos que se puede interrumpir en cada paso.</span><span class="sxs-lookup"><span data-stu-id="925f9-118">Flash updates are performed in a multiple-step process that can be interrupted in each step.</span></span> <span data-ttu-id="925f9-119">LevelX recupera automáticamente el estado óptimo durante la siguiente operación.</span><span class="sxs-lookup"><span data-stu-id="925f9-119">LevelX automatically recovers to the optimal state during the next operation.</span></span>

<span data-ttu-id="925f9-120">LevelX requiere un controlador flash para el acceso físico a la memoria Flash subyacente.</span><span class="sxs-lookup"><span data-stu-id="925f9-120">LevelX requires a flash driver for physical access to the underlying flash memory.</span></span> <span data-ttu-id="925f9-121">Se proporcionan los controladores de ejemplo simulados NAND y NOR, y se pueden usar como un buen punto de partida para implementar los controladores de LevelX reales.</span><span class="sxs-lookup"><span data-stu-id="925f9-121">Example NAND and NOR simulated drivers are provided and can be used as a good starting point for implementing actual LevelX drivers.</span></span> <span data-ttu-id="925f9-122">Además, los requisitos de los controladores se detallan más adelante en esta documentación.</span><span class="sxs-lookup"><span data-stu-id="925f9-122">In addition, driver requirements are detailed later in this documentation.</span></span>

<span data-ttu-id="925f9-123">En los siguientes capítulos se describe la operación funcional para la compatibilidad de LevelX con NAND y NOR.</span><span class="sxs-lookup"><span data-stu-id="925f9-123">The following chapters describe the functional operation for the NAND and NOR LevelX support.</span></span>
