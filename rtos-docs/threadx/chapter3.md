---
title: 'Capítulo 3: Componentes funcionales de Azure RTOS ThreadX'
description: Este capítulo contiene una descripción del kernel de alto rendimiento de Azure RTOS ThreadX desde una perspectiva funcional.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: aa66ad392171958e5d2cc765992fd1a9e41250a6
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 03/22/2021
ms.locfileid: "104815634"
---
# <a name="chapter-3---functional-components-of-azure-rtos-threadx"></a><span data-ttu-id="f4296-103">Capítulo 3: Componentes funcionales de Azure RTOS ThreadX</span><span class="sxs-lookup"><span data-stu-id="f4296-103">Chapter 3 - Functional Components of Azure RTOS ThreadX</span></span>

<span data-ttu-id="f4296-104">Este capítulo contiene una descripción del kernel de alto rendimiento de Azure RTOS ThreadX desde una perspectiva funcional.</span><span class="sxs-lookup"><span data-stu-id="f4296-104">This chapter contains a description of the high-performance Azure RTOS ThreadX kernel from a functional perspective.</span></span> <span data-ttu-id="f4296-105">Cada componente funcional se presenta de una forma fácil de entender.</span><span class="sxs-lookup"><span data-stu-id="f4296-105">Each functional component is presented in an easy-to-understand manner.</span></span>

## <a name="execution-overview"></a><span data-ttu-id="f4296-106">Información general sobre la ejecución</span><span class="sxs-lookup"><span data-stu-id="f4296-106">Execution Overview</span></span>

<span data-ttu-id="f4296-107">En una aplicación de ThreadX hay cuatro tipos de ejecución de programa: inicialización, ejecución de subprocesos, rutinas de servicio de interrupción (ISR) y temporizadores de aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-107">There are four types of program execution within a ThreadX application: Initialization, Thread Execution, Interrupt Service Routines (ISRs), and Application Timers.</span></span>

<span data-ttu-id="f4296-108">En la figura 2 se muestra cada tipo de ejecución de programa.</span><span class="sxs-lookup"><span data-stu-id="f4296-108">Figure 2 shows each different type of program execution.</span></span> <span data-ttu-id="f4296-109">En las secciones siguientes de este capítulo se ofrece información más detallada sobre cada uno de estos tipos.</span><span class="sxs-lookup"><span data-stu-id="f4296-109">More detailed information about each of these types is found in subsequent sections of this chapter.</span></span>

### <a name="initialization"></a><span data-ttu-id="f4296-110">Inicialización</span><span class="sxs-lookup"><span data-stu-id="f4296-110">Initialization</span></span>

<span data-ttu-id="f4296-111">Como su nombre indica, este es el primer tipo de ejecución de programa de una aplicación de ThreadX.</span><span class="sxs-lookup"><span data-stu-id="f4296-111">As the name implies, this is the first type of program execution in a ThreadX application.</span></span> <span data-ttu-id="f4296-112">La inicialización incluye toda la ejecución de programa entre el restablecimiento del procesador y el punto de entrada del *bucle de programación de subprocesos*.</span><span class="sxs-lookup"><span data-stu-id="f4296-112">Initialization includes all program execution between processor reset and the entry point of the *thread scheduling loop.*</span></span>

### <a name="thread-execution"></a><span data-ttu-id="f4296-113">Ejecución de subprocesos</span><span class="sxs-lookup"><span data-stu-id="f4296-113">Thread Execution</span></span>

<span data-ttu-id="f4296-114">Una vez que se ha completado la inicialización, ThreadX entra en su bucle de programación de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="f4296-114">After initialization is complete, ThreadX enters its thread scheduling loop.</span></span> <span data-ttu-id="f4296-115">El bucle de programación busca un subproceso de aplicación listo para ejecutarse.</span><span class="sxs-lookup"><span data-stu-id="f4296-115">The scheduling loop looks for an application thread ready for execution.</span></span> <span data-ttu-id="f4296-116">Cuando se encuentra un subproceso listo, ThreadX le transfiere el control.</span><span class="sxs-lookup"><span data-stu-id="f4296-116">When a ready thread is found, ThreadX transfers control to it.</span></span> <span data-ttu-id="f4296-117">Cuando termina el subproceso (o hay otro de mayor prioridad listo), la ejecución se vuelve a transferir al bucle de programación de subprocesos a fin de encontrar el siguiente subproceso listo de mayor prioridad.</span><span class="sxs-lookup"><span data-stu-id="f4296-117">After the thread is finished (or another higher-priority thread becomes ready), execution transfers back to the thread scheduling loop to find the next highest priority ready thread.</span></span>

<span data-ttu-id="f4296-118">Este proceso continuo de ejecución y programación de subprocesos es el tipo más común de ejecución de programa en las aplicaciones de ThreadX.</span><span class="sxs-lookup"><span data-stu-id="f4296-118">This process of continually executing and scheduling threads is the most common type of program execution in ThreadX applications.</span></span>

### <a name="interrupt-service-routines-isr"></a><span data-ttu-id="f4296-119">Rutinas de servicio de interrupción (ISR)</span><span class="sxs-lookup"><span data-stu-id="f4296-119">Interrupt Service Routines (ISR)</span></span>

<span data-ttu-id="f4296-120">Las interrupciones son la piedra angular de los sistemas en tiempo real.</span><span class="sxs-lookup"><span data-stu-id="f4296-120">Interrupts are the cornerstone of real-time systems.</span></span> <span data-ttu-id="f4296-121">Sin interrupciones, sería extremadamente difícil responder a tiempo a los cambios en el mundo exterior.</span><span class="sxs-lookup"><span data-stu-id="f4296-121">Without interrupts it would be extremely difficult to respond to changes in the external world in a timely manner.</span></span> <span data-ttu-id="f4296-122">Al detectar una interrupción, el procesador guarda información clave sobre la ejecución del programa actual (normalmente en la pila) y transfiere el control a un área de programas predefinida.</span><span class="sxs-lookup"><span data-stu-id="f4296-122">On detection of an interrupt, the processor saves key information about the current program execution (usually on the stack), then transfers control to a predefined program area.</span></span> <span data-ttu-id="f4296-123">Esta área de programas predefinida se suele denominar rutina de servicio de interrupción.</span><span class="sxs-lookup"><span data-stu-id="f4296-123">This predefined program area is commonly called an Interrupt Service Routine.</span></span> <span data-ttu-id="f4296-124">En la mayoría de los casos, las interrupciones se producen durante la ejecución de subprocesos (o en el bucle de programación de subprocesos).</span><span class="sxs-lookup"><span data-stu-id="f4296-124">In most cases, interrupts occur during thread execution (or in the thread scheduling loop).</span></span> <span data-ttu-id="f4296-125">Pero también se pueden producir dentro de una ISR en ejecución o un temporizador de aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-125">However, interrupts may also occur inside of an executing ISR or an Application Timer.</span></span>

![Tipos de ejecución de programa](./media/user-guide/types-program-execution.png)

<span data-ttu-id="f4296-127">**FIGURA 2. Tipos de ejecución de programa**</span><span class="sxs-lookup"><span data-stu-id="f4296-127">**FIGURE 2. Types of Program Execution**</span></span>

### <a name="application-timers"></a><span data-ttu-id="f4296-128">Temporizadores de aplicación</span><span class="sxs-lookup"><span data-stu-id="f4296-128">Application Timers</span></span>

<span data-ttu-id="f4296-129">Los temporizadores de aplicación son similares a las ISR, aunque la implementación de hardware (normalmente se usa una sola interrupción de hardware periódica) se oculta a la aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-129">Application Timers are similar to ISRs, except the hardware implementation (usually a single periodic hardware interrupt is used) is hidden from the application.</span></span> <span data-ttu-id="f4296-130">Las aplicaciones usan estos temporizadores para ejecutar tiempos de espera, periódicos o servicios de guardián.</span><span class="sxs-lookup"><span data-stu-id="f4296-130">Such timers are used by applications to perform time-outs, periodics, and/or watchdog services.</span></span> <span data-ttu-id="f4296-131">Al igual que las ISR, los temporizadores de aplicación suelen interrumpir la ejecución de los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="f4296-131">Just like ISRs, Application Timers most often interrupt thread execution.</span></span> <span data-ttu-id="f4296-132">Pero a diferencia de las ISR, los temporizadores de aplicación no se pueden interrumpir entre sí.</span><span class="sxs-lookup"><span data-stu-id="f4296-132">Unlike ISRs, however, Application Timers cannot interrupt each other.</span></span>

## <a name="memory-usage"></a><span data-ttu-id="f4296-133">Uso de la memoria</span><span class="sxs-lookup"><span data-stu-id="f4296-133">Memory Usage</span></span>

<span data-ttu-id="f4296-134">ThreadX reside junto al programa de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-134">ThreadX resides along with the application program.</span></span> <span data-ttu-id="f4296-135">Por eso, el uso de memoria estática (o memoria fija) de ThreadX viene determinado por las herramientas de desarrollo, por ejemplo, el compilador, el enlazador y el localizador.</span><span class="sxs-lookup"><span data-stu-id="f4296-135">As a result, the static memory (or fixed memory) usage of ThreadX is determined by the development tools; e.g., the compiler, linker, and locator.</span></span> <span data-ttu-id="f4296-136">El uso de memoria dinámica (o memoria en tiempo de ejecución) está bajo el control directo de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-136">Dynamic memory (or run-time memory) usage is under direct control of the application.</span></span>

### <a name="static-memory-usage"></a><span data-ttu-id="f4296-137">Uso de memoria estática</span><span class="sxs-lookup"><span data-stu-id="f4296-137">Static Memory Usage</span></span>

<span data-ttu-id="f4296-138">La mayoría de las herramientas de desarrollo dividen la imagen del programa de la aplicación en cinco áreas básicas: *instrucciones*, *constantes*, *datos inicializados*, *datos sin inicializar* y *pila del sistema*.</span><span class="sxs-lookup"><span data-stu-id="f4296-138">Most of the development tools divide the application program image into five basic areas: *instruction*, *constant*, *initialized data*, *uninitialized data*, and *system stack*.</span></span> <span data-ttu-id="f4296-139">En la figura 3 se muestra un ejemplo de estas áreas de memoria.</span><span class="sxs-lookup"><span data-stu-id="f4296-139">Figure 3 shows an example of these memory areas.</span></span>

<span data-ttu-id="f4296-140">Es importante entender que se trata solo de un ejemplo.</span><span class="sxs-lookup"><span data-stu-id="f4296-140">It is important to understand that this is only an example.</span></span> <span data-ttu-id="f4296-141">El diseño de memoria estática real es específico del procesador, las herramientas de desarrollo y el hardware subyacente.</span><span class="sxs-lookup"><span data-stu-id="f4296-141">The actual static memory layout is specific to the processor, development tools, and the underlying hardware.</span></span>

<span data-ttu-id="f4296-142">El área de instrucciones contiene todas las instrucciones del procesador del programa.</span><span class="sxs-lookup"><span data-stu-id="f4296-142">The instruction area contains all of the program's processor instructions.</span></span> <span data-ttu-id="f4296-143">Normalmente es el área más grande y suele encontrarse en la ROM.</span><span class="sxs-lookup"><span data-stu-id="f4296-143">This area is typically the largest and is often located in ROM.</span></span>

<span data-ttu-id="f4296-144">El área de constantes contiene varias constantes compiladas, incluidas las cadenas definidas o a las que se hace referencia en el programa.</span><span class="sxs-lookup"><span data-stu-id="f4296-144">The constant area contains various compiled constants, including strings defined or referenced within the program.</span></span> <span data-ttu-id="f4296-145">Además, esta área contiene la "copia inicial" del área de datos inicializados.</span><span class="sxs-lookup"><span data-stu-id="f4296-145">In addition, this area contains the "initial copy" of the initialized data area.</span></span> <span data-ttu-id="f4296-146">Durante el proceso de inicialización del compilador de *uso de memoria*, esta parte del área de constantes se usa para configurar el área de datos inicializados en la RAM.</span><span class="sxs-lookup"><span data-stu-id="f4296-146">During the *Memory Usage* compiler's initialization process, this portion of the constant area is used to set up the initialized data area in RAM.</span></span> <span data-ttu-id="f4296-147">El área de constantes suele seguir al área de instrucciones y encontrarse en la ROM.</span><span class="sxs-lookup"><span data-stu-id="f4296-147">The constant area usually follows the instruction area and is often located in ROM.</span></span>

<span data-ttu-id="f4296-148">Las áreas de datos inicializados y sin inicializar contienen todas las variables globales y estáticas.</span><span class="sxs-lookup"><span data-stu-id="f4296-148">The initialized data and uninitialized data areas contain all of the global and static variables.</span></span> <span data-ttu-id="f4296-149">Estas áreas siempre se encuentran en la RAM.</span><span class="sxs-lookup"><span data-stu-id="f4296-149">These areas are always located in RAM.</span></span>

<span data-ttu-id="f4296-150">La pila del sistema se suele configurar inmediatamente después de las áreas de datos inicializados y sin inicializar.</span><span class="sxs-lookup"><span data-stu-id="f4296-150">The system stack is generally set up immediately following the initialized and uninitialized data areas.</span></span>

<span data-ttu-id="f4296-151">El compilador usa la pila del sistema durante la inicialización, luego la utiliza ThreadX también durante la inicialización y, posteriormente, durante el procesamiento de ISR.</span><span class="sxs-lookup"><span data-stu-id="f4296-151">The system stack is used by the compiler during initialization, then by ThreadX during initialization and, subsequently, in ISR processing.</span></span>

![Ejemplo de área de memoria](./media/user-guide/memory-area-example.png)

<span data-ttu-id="f4296-153">**FIGURA 3. Ejemplo de área de memoria**</span><span class="sxs-lookup"><span data-stu-id="f4296-153">**FIGURE 3. Memory Area Example**</span></span>

### <a name="dynamic-memory-usage"></a><span data-ttu-id="f4296-154">Uso de memoria dinámica</span><span class="sxs-lookup"><span data-stu-id="f4296-154">Dynamic Memory Usage</span></span>

<span data-ttu-id="f4296-155">Como se ha mencionado antes, el uso de memoria dinámica está bajo el control directo de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-155">As mentioned before, dynamic memory usage is under direct control of the application.</span></span> <span data-ttu-id="f4296-156">Los bloques de control y las áreas de memoria asociados a pilas, colas y bloques de memoria se pueden colocar en cualquier ubicación del espacio de memoria del destino.</span><span class="sxs-lookup"><span data-stu-id="f4296-156">Control blocks and memory areas associated with stacks, queues, and memory pools can be placed anywhere in the target's memory space.</span></span> <span data-ttu-id="f4296-157">Se trata de una característica importante, ya que facilita el uso de diferentes tipos de memoria física.</span><span class="sxs-lookup"><span data-stu-id="f4296-157">This is an important feature because it facilitates easy utilization of different types of physical memory.</span></span>

<span data-ttu-id="f4296-158">Por ejemplo, imagine que un entorno de hardware de destino tiene memoria rápida y memoria lenta.</span><span class="sxs-lookup"><span data-stu-id="f4296-158">For example, suppose a target hardware environment has both fast memory and slow memory.</span></span> <span data-ttu-id="f4296-159">Si la aplicación necesita rendimiento adicional para un subproceso de alta prioridad, su bloque de control (TX_THREAD) y la pila se pueden colocar en el área de memoria rápida, lo que puede mejorar considerablemente el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="f4296-159">If the application needs extra performance for a high-priority thread, its control block (TX_THREAD) and stack can be placed in the fast memory area, which may greatly enhance its performance.</span></span>

## <a name="initialization"></a><span data-ttu-id="f4296-160">Inicialización</span><span class="sxs-lookup"><span data-stu-id="f4296-160">Initialization</span></span>

<span data-ttu-id="f4296-161">Es importante comprender el proceso de inicialización.</span><span class="sxs-lookup"><span data-stu-id="f4296-161">Understanding the initialization process is important.</span></span> <span data-ttu-id="f4296-162">Aquí se configura el entorno de hardware inicial.</span><span class="sxs-lookup"><span data-stu-id="f4296-162">The initial hardware environment is set up here.</span></span> <span data-ttu-id="f4296-163">Además, aquí es donde se proporciona la personalidad inicial a la aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-163">In addition, this is where the application is given its initial personality.</span></span>

> [!NOTE]
> <span data-ttu-id="f4296-164">*ThreadX intentará usar (siempre que sea posible) el proceso de inicialización completo de la herramienta de desarrollo. Esto permite que en el futuro sea más fácil hacer la actualización a nuevas versiones de las herramientas de desarrollo.*</span><span class="sxs-lookup"><span data-stu-id="f4296-164">*ThreadX attempts to utilize (whenever possible) the complete development tool's initialization process. This makes it easier to upgrade to new versions of the development tools in the future.*</span></span>

### <a name="system-reset-vector"></a><span data-ttu-id="f4296-165">Vector de restablecimiento del sistema</span><span class="sxs-lookup"><span data-stu-id="f4296-165">System Reset Vector</span></span>

<span data-ttu-id="f4296-166">Todos los microprocesadores tienen lógica de restablecimiento.</span><span class="sxs-lookup"><span data-stu-id="f4296-166">All microprocessors have reset logic.</span></span> <span data-ttu-id="f4296-167">Cuando se produce un restablecimiento (ya sea de hardware o software), la dirección del punto de entrada de la aplicación se recupera de una ubicación de memoria concreta.</span><span class="sxs-lookup"><span data-stu-id="f4296-167">When a reset occurs (either hardware or software), the address of the application's entry point is retrieved from a specific memory location.</span></span> <span data-ttu-id="f4296-168">Una vez que se ha recuperado el punto de entrada, el procesador transfiere el control a esa ubicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-168">After the entry point is retrieved, the processor transfers control to that location.</span></span> <span data-ttu-id="f4296-169">El punto de entrada de la aplicación se escribe con mucha frecuencia en el lenguaje de ensamblado nativo y normalmente lo suministran las herramientas de desarrollo (al menos en formato de plantilla).</span><span class="sxs-lookup"><span data-stu-id="f4296-169">The application entry point is quite often written in the native assembly language and is usually supplied by the development tools (at least in template form).</span></span> <span data-ttu-id="f4296-170">En algunos casos, se proporciona una versión especial del programa de entrada con ThreadX.</span><span class="sxs-lookup"><span data-stu-id="f4296-170">In some cases, a special version of the entry program is supplied with ThreadX.</span></span>

### <a name="development-tool-initialization"></a><span data-ttu-id="f4296-171">Inicialización de la herramienta de desarrollo</span><span class="sxs-lookup"><span data-stu-id="f4296-171">Development Tool Initialization</span></span>

<span data-ttu-id="f4296-172">Una vez que se completa la inicialización de bajo nivel, el control se transfiere a la inicialización de alto nivel de la herramienta de desarrollo.</span><span class="sxs-lookup"><span data-stu-id="f4296-172">After the low-level initialization is complete, control transfers to the development tool's high-level initialization.</span></span> <span data-ttu-id="f4296-173">Normalmente, es el lugar donde se configuran las variables globales y estáticas de C.</span><span class="sxs-lookup"><span data-stu-id="f4296-173">This is usually the place where initialized global and static C variables are set up.</span></span> <span data-ttu-id="f4296-174">Recuerde que sus valores iniciales se recuperan del área de constantes.</span><span class="sxs-lookup"><span data-stu-id="f4296-174">Remember their initial values are retrieved from the constant area.</span></span> <span data-ttu-id="f4296-175">El procesamiento de inicialización exacto es específico de la herramienta de desarrollo.</span><span class="sxs-lookup"><span data-stu-id="f4296-175">Exact initialization processing is development tool specific.</span></span>

### <a name="main-function"></a><span data-ttu-id="f4296-176">Función "main"</span><span class="sxs-lookup"><span data-stu-id="f4296-176">main Function</span></span>

<span data-ttu-id="f4296-177">Una vez que se ha completado la inicialización de la herramienta de desarrollo, el control se transfiere a la función *main* proporcionada por el usuario.</span><span class="sxs-lookup"><span data-stu-id="f4296-177">When the development tool initialization is complete, control transfers to the user-supplied *main* function.</span></span> <span data-ttu-id="f4296-178">En este punto, la aplicación controla lo que ocurre a continuación.</span><span class="sxs-lookup"><span data-stu-id="f4296-178">At this point, the application controls what happens next.</span></span> <span data-ttu-id="f4296-179">Para la mayoría de las aplicaciones, la función "main" simplemente llama a *tx_kernel_enter*, que es la entrada a ThreadX.</span><span class="sxs-lookup"><span data-stu-id="f4296-179">For most applications, the main function simply calls *tx_kernel_enter*, which is the entry into ThreadX.</span></span> <span data-ttu-id="f4296-180">Pero las aplicaciones pueden realizar el procesamiento preliminar (normalmente para la inicialización de hardware) antes de entrar en ThreadX.</span><span class="sxs-lookup"><span data-stu-id="f4296-180">However, applications can perform preliminary processing (usually for hardware initialization) prior to entering ThreadX.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f4296-181">*La llamada a tx_kernel_enter no devuelve valores, por lo no debe colocar ningún procesamiento después.*</span><span class="sxs-lookup"><span data-stu-id="f4296-181">*The call to tx_kernel_enter does not return, so do not place any processing after it.*</span></span>

### <a name="tx_kernel_enter"></a><span data-ttu-id="f4296-182">tx_kernel_enter</span><span class="sxs-lookup"><span data-stu-id="f4296-182">tx_kernel_enter</span></span>

<span data-ttu-id="f4296-183">La función de entrada coordina la inicialización de varias estructuras de datos internas de ThreadX y, después, llama a la función de definición ***tx_application_define*** de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-183">The entry function coordinates initialization of various internal ThreadX data structures and then calls the application's definition function ***tx_application_define***.</span></span>

<span data-ttu-id="f4296-184">Cuando ***tx_application_define*** devuelve un valor, el control se transfiere al bucle de programación de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="f4296-184">When ***tx_application_define*** returns, control is transferred to the thread scheduling loop.</span></span> <span data-ttu-id="f4296-185">Esto marca el final de la inicialización.</span><span class="sxs-lookup"><span data-stu-id="f4296-185">This marks the end of initialization.</span></span>

### <a name="application-definition-function"></a><span data-ttu-id="f4296-186">Función de definición de aplicación</span><span class="sxs-lookup"><span data-stu-id="f4296-186">Application Definition Function</span></span>

<span data-ttu-id="f4296-187">La función ***tx_application_define*** define todos los subprocesos, colas, semáforos, exclusiones mutuas, marcas de eventos, grupos de memoria y temporizadores de la aplicación inicial.</span><span class="sxs-lookup"><span data-stu-id="f4296-187">The ***tx_application_define*** function defines all of the initial application threads, queues, semaphores, mutexes, event flags, memory pools, and timers.</span></span> <span data-ttu-id="f4296-188">También es posible crear y eliminar recursos del sistema desde subprocesos durante el funcionamiento normal de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-188">It is also possible to create and delete system resources from threads during the normal operation of the application.</span></span> <span data-ttu-id="f4296-189">Pero aquí se definen todos los recursos iniciales de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-189">However, all initial application resources are defined here.</span></span>

<span data-ttu-id="f4296-190">La función \***tx_application_define** _ tiene un único parámetro de entrada que merece la pena mencionar.</span><span class="sxs-lookup"><span data-stu-id="f4296-190">The \***tx_application_define** _ function has a single input parameter and it is certainly worth mentioning.</span></span> <span data-ttu-id="f4296-191">La dirección RAM _first-available\* es el único parámetro de entrada de esta función.</span><span class="sxs-lookup"><span data-stu-id="f4296-191">The _first-available\* RAM address is the sole input parameter to this function.</span></span> <span data-ttu-id="f4296-192">Normalmente se usa como punto de partida para las asignaciones de memoria iniciales en tiempo de ejecución de pilas de subprocesos, colas y grupos de memoria.</span><span class="sxs-lookup"><span data-stu-id="f4296-192">It is typically used as a starting point for initial run-time memory allocations of thread stacks, queues, and memory pools.</span></span>

> [!NOTE]
> <span data-ttu-id="f4296-193">*Una vez que se ha completado la inicialización, solo un subproceso en ejecución puede crear y eliminar recursos del sistema, incluidos otros subprocesos. Por tanto, durante la inicialización se debe crear al menos un subproceso.*</span><span class="sxs-lookup"><span data-stu-id="f4296-193">*After initialization is complete, only an executing thread can create and delete system resources— including other threads. Therefore, at least one thread must be created during initialization.*</span></span>

### <a name="interrupts"></a><span data-ttu-id="f4296-194">Interrupciones</span><span class="sxs-lookup"><span data-stu-id="f4296-194">Interrupts</span></span>

<span data-ttu-id="f4296-195">Las interrupciones se dejan deshabilitadas durante todo el proceso de inicialización.</span><span class="sxs-lookup"><span data-stu-id="f4296-195">Interrupts are left disabled during the entire initialization process.</span></span> <span data-ttu-id="f4296-196">Si la aplicación habilita alguna interrupción, se puede producir un comportamiento impredecible.</span><span class="sxs-lookup"><span data-stu-id="f4296-196">If the application somehow enables interrupts, unpredictable behavior may occur.</span></span> <span data-ttu-id="f4296-197">En la figura 4 se muestra el proceso de inicialización completo, desde el restablecimiento del sistema hasta la inicialización específica de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-197">Figure 4 shows the entire initialization process, from system reset through application-specific initialization.</span></span>

## <a name="thread-execution"></a><span data-ttu-id="f4296-198">Ejecución de subprocesos</span><span class="sxs-lookup"><span data-stu-id="f4296-198">Thread Execution</span></span>

<span data-ttu-id="f4296-199">La programación y ejecución de subprocesos de aplicación es la actividad más importante de ThreadX.</span><span class="sxs-lookup"><span data-stu-id="f4296-199">Scheduling and executing application threads is the most important activity of ThreadX.</span></span> <span data-ttu-id="f4296-200">Un subproceso se define normalmente como un segmento de programa semiindependiente con un propósito dedicado.</span><span class="sxs-lookup"><span data-stu-id="f4296-200">A thread is typically defined as a semi-independent program segment with a dedicated purpose.</span></span> <span data-ttu-id="f4296-201">El procesamiento combinado de todos los subprocesos crea una aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-201">The combined processing of all threads makes an application.</span></span>

<span data-ttu-id="f4296-202">Los subprocesos se crean de forma dinámica mediante una llamada a \***tx_thread_create** _ durante la inicialización o durante la ejecución del subproceso.</span><span class="sxs-lookup"><span data-stu-id="f4296-202">Threads are created dynamically by calling \***tx_thread_create** _ during initialization or during thread execution.</span></span> <span data-ttu-id="f4296-203">Los subprocesos se crean en un estado _listo\* o *suspendido*.</span><span class="sxs-lookup"><span data-stu-id="f4296-203">Threads are created in either a _ready\* or *suspended* state.</span></span>

![Proceso de inicialización](./media/user-guide/initialization-process.png)

<span data-ttu-id="f4296-205">**FIGURA 4. Proceso de inicialización**</span><span class="sxs-lookup"><span data-stu-id="f4296-205">**FIGURE 4. Initialization Process**</span></span>

### <a name="thread-execution-states"></a><span data-ttu-id="f4296-206">Estados de ejecución de subprocesos</span><span class="sxs-lookup"><span data-stu-id="f4296-206">Thread Execution States</span></span>

<span data-ttu-id="f4296-207">Comprender los distintos estados de procesamiento de los subprocesos es un factor clave para entender todo el entorno multiproceso.</span><span class="sxs-lookup"><span data-stu-id="f4296-207">Understanding the different processing states of threads is a key ingredient to understanding the entire multithreaded environment.</span></span> <span data-ttu-id="f4296-208">En ThreadX hay cinco estados de subproceso distintos: *listo*, *suspendido*, *en ejecución*, *finalizado* y *completado*.</span><span class="sxs-lookup"><span data-stu-id="f4296-208">In ThreadX there are five distinct thread states: *ready*, *suspended*, *executing*, *terminated*, and *completed*.</span></span> <span data-ttu-id="f4296-209">En la figura 5 se muestra el diagrama de transición de estado de subprocesos de ThreadX.</span><span class="sxs-lookup"><span data-stu-id="f4296-209">Figure 5 shows the thread state transition diagram for ThreadX.</span></span>

![Transición de estado de subprocesos](./media/user-guide/thread-state-transition.png)

<span data-ttu-id="f4296-211">**FIGURA 5. Transición de estado de subprocesos**</span><span class="sxs-lookup"><span data-stu-id="f4296-211">**FIGURE 5. Thread State Transition**</span></span>

<span data-ttu-id="f4296-212">Un subproceso está en un estado *listo* cuando está listo para su ejecución.</span><span class="sxs-lookup"><span data-stu-id="f4296-212">A thread is in a *ready* state when it is ready for execution.</span></span> <span data-ttu-id="f4296-213">Un subproceso listo no se ejecuta hasta que es el subproceso de prioridad más alta en estado listo.</span><span class="sxs-lookup"><span data-stu-id="f4296-213">A ready thread is not executed until it is the highest priority thread in ready state.</span></span> <span data-ttu-id="f4296-214">Cuando esto sucede, ThreadX ejecuta el subproceso, que cambia su estado a *en ejecución*.</span><span class="sxs-lookup"><span data-stu-id="f4296-214">When this happens, ThreadX executes the thread, which then changes its state to *executing*.</span></span>

<span data-ttu-id="f4296-215">Si un subproceso de prioridad más alta está listo, el subproceso en ejecución vuelve a un estado *listo*.</span><span class="sxs-lookup"><span data-stu-id="f4296-215">If a higher-priority thread becomes ready, the executing thread reverts back to a *ready* state.</span></span> <span data-ttu-id="f4296-216">Después, se ejecuta el subproceso de alta prioridad recién preparado, que cambia su estado lógico a *en ejecución*.</span><span class="sxs-lookup"><span data-stu-id="f4296-216">The newly ready high-priority thread is then executed, which changes its logical state to *executing*.</span></span> <span data-ttu-id="f4296-217">Esta transición entre los estados *listo* y *en ejecución* se produce cada vez que tiene lugar el adelantamiento de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="f4296-217">This transition between *ready* and *executing* states occurs every time thread preemption occurs.</span></span>

<span data-ttu-id="f4296-218">En un momento dado, solo hay un subproceso en un estado *en ejecución*.</span><span class="sxs-lookup"><span data-stu-id="f4296-218">At any given moment, only one thread is in an *executing* state.</span></span> <span data-ttu-id="f4296-219">Esto se debe a que un subproceso en el estado *en ejecución* tiene el control del procesador subyacente.</span><span class="sxs-lookup"><span data-stu-id="f4296-219">This is because a thread in the *executing* state has control of the underlying processor.</span></span>

<span data-ttu-id="f4296-220">Los subprocesos en un estado *suspendido* no son válidos para la ejecución.</span><span class="sxs-lookup"><span data-stu-id="f4296-220">Threads in a *suspended* state are not eligible for execution.</span></span> <span data-ttu-id="f4296-221">Entre los motivos para estar en un estado *suspendido* se incluyen la suspensión de tiempo, mensajes de cola, semáforos, exclusiones mutuas, marcas de eventos, memoria y suspensión básica de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="f4296-221">Reasons for being in a *suspended* state include suspension for time, queue messages, semaphores, mutexes, event flags, memory, and basic thread suspension.</span></span> <span data-ttu-id="f4296-222">Una vez que se elimina la causa de la suspensión, el subproceso se vuelve a colocar en un estado *listo*.</span><span class="sxs-lookup"><span data-stu-id="f4296-222">After the cause for suspension is removed, the thread is placed back in a *ready* state.</span></span>

<span data-ttu-id="f4296-223">Un subproceso en un estado *completado* es el que ha completado su procesamiento y se ha devuelto desde su función de entrada.</span><span class="sxs-lookup"><span data-stu-id="f4296-223">A thread in a *completed* state is a thread that has completed its processing and returned from its entry function.</span></span> <span data-ttu-id="f4296-224">La función de entrada se especifica durante la creación del subproceso.</span><span class="sxs-lookup"><span data-stu-id="f4296-224">The entry function is specified during thread creation.</span></span> <span data-ttu-id="f4296-225">No se puede volver a ejecutar un subproceso en un estado *completado*.</span><span class="sxs-lookup"><span data-stu-id="f4296-225">A thread in a *completed* state cannot execute again.</span></span>

<span data-ttu-id="f4296-226">Un subproceso está en un estado *completado* porque otro subproceso o el propio subproceso ha llamado al servicio *tx_thread_terminate*.</span><span class="sxs-lookup"><span data-stu-id="f4296-226">A thread is in a *terminated* state because another thread or the thread itself called the *tx_thread_terminate* service.</span></span> <span data-ttu-id="f4296-227">Un subproceso en un estado *completado* no se puede volver a ejecutar.</span><span class="sxs-lookup"><span data-stu-id="f4296-227">A thread in a *terminated* state cannot execute again.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f4296-228">*Si se quiere volver a iniciar un subproceso completado o finalizado, la aplicación debe eliminar primero el subproceso. Después, se podrá volver a crear y reiniciar.*</span><span class="sxs-lookup"><span data-stu-id="f4296-228">*If re-starting a completed or terminated thread is desired, the application must first delete the thread. It can then be re-created and re-started.*</span></span>

### <a name="thread-entryexit-notification"></a><span data-ttu-id="f4296-229">Entrada de subprocesos/Notificación de salida</span><span class="sxs-lookup"><span data-stu-id="f4296-229">Thread Entry/Exit Notification</span></span>

<span data-ttu-id="f4296-230">Es posible que para algunas aplicaciones sea una ventaja recibir notificaciones cuando se entra por primera vez en un subproceso concreto, cuando se completa o cuando se finaliza.</span><span class="sxs-lookup"><span data-stu-id="f4296-230">Some applications may find it advantageous to be notified when a specific thread is entered for the first time, when it completes, or is terminated.</span></span> <span data-ttu-id="f4296-231">ThreadX proporciona esta función por medio del servicio ***tx_thread_entry_exit_notify***.</span><span class="sxs-lookup"><span data-stu-id="f4296-231">ThreadX provides this ability through the ***tx_thread_entry_exit_notify*** service.</span></span> <span data-ttu-id="f4296-232">Este servicio registra una función de notificación de aplicación para un subproceso concreto, al que llama ThreadX cada vez que el subproceso empieza a ejecutarse, se completa o finaliza.</span><span class="sxs-lookup"><span data-stu-id="f4296-232">This service registers an application notification function for a specific thread, which is called by ThreadX whenever the thread starts running, completes, or is terminated.</span></span> <span data-ttu-id="f4296-233">Después de invocarse, la función de notificación de la aplicación puede realizar el procesamiento específico de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-233">After being invoked, the application notification function can perform the application-specific processing.</span></span> <span data-ttu-id="f4296-234">Normalmente, esto implica informar a otro subproceso de aplicación del evento por medio de una primitiva de sincronización de ThreadX.</span><span class="sxs-lookup"><span data-stu-id="f4296-234">This typically involves informing another application thread of the event via a ThreadX synchronization primitive.</span></span>

### <a name="thread-priorities"></a><span data-ttu-id="f4296-235">Prioridades de subprocesos</span><span class="sxs-lookup"><span data-stu-id="f4296-235">Thread Priorities</span></span>

<span data-ttu-id="f4296-236">Como se ha mencionado antes, un subproceso es un segmento de programa semiindependiente con un propósito dedicado.</span><span class="sxs-lookup"><span data-stu-id="f4296-236">As mentioned before, a thread is a semi-independent program segment with a dedicated purpose.</span></span> <span data-ttu-id="f4296-237">Pero no todos los subprocesos se crean de la misma forma.</span><span class="sxs-lookup"><span data-stu-id="f4296-237">However, all threads are not created equal!</span></span> <span data-ttu-id="f4296-238">El propósito dedicado de algunos subprocesos es mucho más importante que el de otros.</span><span class="sxs-lookup"><span data-stu-id="f4296-238">The dedicated purpose of some threads is much more important than others.</span></span> <span data-ttu-id="f4296-239">Este tipo heterogéneo de importancia del subproceso es un sello de las aplicaciones en tiempo real insertadas.</span><span class="sxs-lookup"><span data-stu-id="f4296-239">This heterogeneous type of thread importance is a hallmark of embedded realtime applications.</span></span>

<span data-ttu-id="f4296-240">ThreadX determina la importancia de un subproceso al crearlo asignándole un valor numérico que representa su *prioridad*.</span><span class="sxs-lookup"><span data-stu-id="f4296-240">ThreadX determines a thread's importance when the thread is created by assigning a numerical value representing its *priority*.</span></span> <span data-ttu-id="f4296-241">El número máximo de prioridades de ThreadX se puede configurar de 32 a 1024 en incrementos de 32.</span><span class="sxs-lookup"><span data-stu-id="f4296-241">The maximum number of ThreadX priorities is configurable from 32 through 1024 in increments of 32.</span></span> <span data-ttu-id="f4296-242">El número máximo real de prioridades viene determinado por la constante **TX_MAX_PRIORITIES** durante la compilación de la biblioteca de ThreadX.</span><span class="sxs-lookup"><span data-stu-id="f4296-242">The actual maximum number of priorities is determined by the **TX_MAX_PRIORITIES** constant during compilation of the ThreadX library.</span></span> <span data-ttu-id="f4296-243">Tener un número mayor de prioridades no aumenta significativamente la sobrecarga de procesamiento.</span><span class="sxs-lookup"><span data-stu-id="f4296-243">Having a larger number of priorities does not significantly increase processing overhead.</span></span> <span data-ttu-id="f4296-244">Pero para cada grupo de niveles de prioridad 32 se necesitan 128 bytes de RAM adicionales para administrarlos.</span><span class="sxs-lookup"><span data-stu-id="f4296-244">However, for each group of 32 priority levels an additional 128 bytes of RAM is required to manage them.</span></span> <span data-ttu-id="f4296-245">Por ejemplo, los niveles de prioridad 32 necesitan 128 bytes de RAM, los de prioridad 64 necesitan 256 bytes de RAM y los de prioridad 96, 384 bytes de RAM.</span><span class="sxs-lookup"><span data-stu-id="f4296-245">For example, 32 priority levels require 128 bytes of RAM, 64 priority levels require 256 bytes of RAM, and 96 priority levels requires 384 bytes of RAM.</span></span>

<span data-ttu-id="f4296-246">De forma predeterminada, ThreadX tiene 32 niveles de prioridad, que van desde 0 hasta 31.</span><span class="sxs-lookup"><span data-stu-id="f4296-246">By default, ThreadX has 32 priority levels, ranging from priority 0 through priority 31.</span></span> <span data-ttu-id="f4296-247">Los valores numéricamente más pequeños implican una mayor prioridad.</span><span class="sxs-lookup"><span data-stu-id="f4296-247">Numerically smaller values imply higher priority.</span></span> <span data-ttu-id="f4296-248">Por tanto, la prioridad 0 representa la prioridad más alta, mientras que la prioridad (**TX_MAX_PRIORITIES**-1) representa la más baja.</span><span class="sxs-lookup"><span data-stu-id="f4296-248">Hence, priority 0 represents the highest priority, while priority (**TX_MAX_PRIORITIES**-1) represents the lowest priority.</span></span>

<span data-ttu-id="f4296-249">Varios subprocesos pueden tener la misma prioridad, que se basa en la programación cooperativa o la segmentación de tiempo.</span><span class="sxs-lookup"><span data-stu-id="f4296-249">Multiple threads can have the same priority relying on cooperative scheduling or time-slicing.</span></span> <span data-ttu-id="f4296-250">Además, las prioridades de subprocesos se pueden cambiar durante el tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="f4296-250">In addition, thread priorities can be changed during run-time.</span></span>

### <a name="thread-scheduling"></a><span data-ttu-id="f4296-251">Programación de subprocesos</span><span class="sxs-lookup"><span data-stu-id="f4296-251">Thread Scheduling</span></span>

<span data-ttu-id="f4296-252">ThreadX programa los subprocesos según su prioridad.</span><span class="sxs-lookup"><span data-stu-id="f4296-252">ThreadX schedules threads based on their priority.</span></span> <span data-ttu-id="f4296-253">Primero se ejecuta el subproceso listo con la prioridad más alta.</span><span class="sxs-lookup"><span data-stu-id="f4296-253">The ready thread with the highest priority is executed first.</span></span> <span data-ttu-id="f4296-254">Si hay varios subprocesos listos con la misma prioridad, se ejecutan de forma FIFO (*el primero en entrar es el primero en salir* ).</span><span class="sxs-lookup"><span data-stu-id="f4296-254">If multiple threads of the same priority are ready, they are executed in a *first-in-first-out* (FIFO) manner.</span></span>

### <a name="round-robin-scheduling"></a><span data-ttu-id="f4296-255">Programación round robin</span><span class="sxs-lookup"><span data-stu-id="f4296-255">Round-robin Scheduling</span></span>

<span data-ttu-id="f4296-256">ThreadX admite la programación *round robin* de varios subprocesos que tienen la misma prioridad.</span><span class="sxs-lookup"><span data-stu-id="f4296-256">ThreadX supports *round-robin* scheduling of multiple threads having the same priority.</span></span> <span data-ttu-id="f4296-257">Esto se logra mediante llamadas cooperativas a \***tx_thread_relinquish** _.</span><span class="sxs-lookup"><span data-stu-id="f4296-257">This is accomplished through cooperative calls to \***tx_thread_relinquish** _.</span></span> <span data-ttu-id="f4296-258">Este servicio proporciona a todos los demás subprocesos listos de la misma prioridad una oportunidad de ejecutarse antes de que el autor de la llamada a _ *_tx_thread_relinquish_*\* se vuelva a ejecutar.</span><span class="sxs-lookup"><span data-stu-id="f4296-258">This service gives all other ready threads of the same priority a chance to execute before the _ *_tx_thread_relinquish_*\* caller executes again.</span></span>

### <a name="time-slicing"></a><span data-ttu-id="f4296-259">Segmentación temporal</span><span class="sxs-lookup"><span data-stu-id="f4296-259">Time-Slicing</span></span>

<span data-ttu-id="f4296-260">La *segmentación temporal* es otra forma de programación round robin.</span><span class="sxs-lookup"><span data-stu-id="f4296-260">*Time-slicing* is another form of round-robin scheduling.</span></span> <span data-ttu-id="f4296-261">Un segmento temporal especifica el número máximo de tics de temporizador (interrupciones del temporizador) que un subproceso puede ejecutar sin renunciar al procesador.</span><span class="sxs-lookup"><span data-stu-id="f4296-261">A time-slice specifies the maximum number of timer ticks (timer interrupts) that a thread can execute without giving up the processor.</span></span> <span data-ttu-id="f4296-262">En ThreadX, la segmentación temporal está disponible en cada subproceso.</span><span class="sxs-lookup"><span data-stu-id="f4296-262">In ThreadX, time-slicing is available on a per-thread basis.</span></span> <span data-ttu-id="f4296-263">El segmento temporal del subproceso se asigna durante la creación y se puede modificar en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="f4296-263">The thread's time-slice is assigned during creation and can be modified during run-time.</span></span> <span data-ttu-id="f4296-264">Cuando expira un segmento temporal, todos los demás subprocesos listos del mismo nivel de prioridad tienen la oportunidad de ejecutarse antes de que se vuelva a ejecutar el subproceso con segmentación temporal.</span><span class="sxs-lookup"><span data-stu-id="f4296-264">When a time-slice expires, all other ready threads of the same priority level are given a chance to execute before the time-sliced thread executes again.</span></span>

<span data-ttu-id="f4296-265">Se asigna un nuevo segmento temporal de subproceso a un subproceso después de que se suspenda, se interrumpa, realice una llamada de servicio de ThreadX que cause el adelantamiento o que se segmente temporalmente.</span><span class="sxs-lookup"><span data-stu-id="f4296-265">A fresh thread time-slice is given to a thread after it suspends, relinquishes, makes a ThreadX service call that causes preemption, or is itself time-sliced.</span></span>

<span data-ttu-id="f4296-266">Cuando se adelante un subproceso con segmentación temporal, se reanudará antes que otros subprocesos listos de la misma prioridad para el resto de su segmento temporal.</span><span class="sxs-lookup"><span data-stu-id="f4296-266">When a time-sliced thread is preempted, it will resume before other ready threads of equal priority for the remainder of its time-slice.</span></span>

> [!NOTE]
> <span data-ttu-id="f4296-267">*El uso de segmentos temporales provoca una ligera sobrecarga del sistema. Como la segmentación temporal solo es útil cuando varios subprocesos comparten la misma prioridad, no se debe asignar un segmento temporal a los subprocesos que tienen una prioridad única.*</span><span class="sxs-lookup"><span data-stu-id="f4296-267">*Using time-slicing results in a slight amount of system overhead. Because time-slicing is only useful in cases in which multiple threads share the same priority, threads having a unique priority should not be assigned a time-slice.*</span></span>

### <a name="preemption"></a><span data-ttu-id="f4296-268">Adelantamiento</span><span class="sxs-lookup"><span data-stu-id="f4296-268">Preemption</span></span>

<span data-ttu-id="f4296-269">El adelantamiento es el proceso de interrumpir temporalmente un subproceso en ejecución en favor de un subproceso de mayor prioridad.</span><span class="sxs-lookup"><span data-stu-id="f4296-269">Preemption is the process of temporarily interrupting an executing thread in favor of a higher-priority thread.</span></span> <span data-ttu-id="f4296-270">Este proceso no es visible para el subproceso en ejecución.</span><span class="sxs-lookup"><span data-stu-id="f4296-270">This process is invisible to the executing thread.</span></span> <span data-ttu-id="f4296-271">Cuando finaliza el subproceso de mayor prioridad, el control se transfiere de nuevo al lugar exacto donde ha tenido lugar el adelantamiento.</span><span class="sxs-lookup"><span data-stu-id="f4296-271">When the higher-priority thread is finished, control is transferred back to the exact place where the preemption took place.</span></span> <span data-ttu-id="f4296-272">Se trata de una característica muy importante en los sistemas en tiempo real porque facilita la respuesta rápida a los eventos de aplicación importantes.</span><span class="sxs-lookup"><span data-stu-id="f4296-272">This is a very important feature in real-time systems because it facilitates fast response to important application events.</span></span> <span data-ttu-id="f4296-273">Aunque sea una característica muy importante, el adelantamiento también puede ser una fuente de diversos problemas, como colapsos, sobrecargas excesivas e inversión de prioridades.</span><span class="sxs-lookup"><span data-stu-id="f4296-273">Although a very important feature, preemption can also be a source of a variety of problems, including starvation, excessive overhead, and priority inversion.</span></span>

### <a name="preemption-thresholdtrade"></a><span data-ttu-id="f4296-274">Umbral de adelantamiento&trade;</span><span class="sxs-lookup"><span data-stu-id="f4296-274">Preemption Threshold&trade;</span></span>

<span data-ttu-id="f4296-275">Para aliviar algunos de los problemas inherentes del adelantamiento, ThreadX proporciona una característica única y avanzada denominada *umbral de adelantamiento*.</span><span class="sxs-lookup"><span data-stu-id="f4296-275">To ease some of the inherent problems of preemption, ThreadX provides a unique and advanced feature called *preemption-threshold*.</span></span>

<span data-ttu-id="f4296-276">Un umbral de adelantamiento permite que un subproceso especifique un *límite* de prioridad para deshabilitar el adelantamiento.</span><span class="sxs-lookup"><span data-stu-id="f4296-276">A preemption-threshold allows a thread to specify a priority *ceiling* for disabling preemption.</span></span> <span data-ttu-id="f4296-277">El adelantamiento todavía se puede permitir para los subprocesos que tienen prioridades más altas que el límite, mientras que no se permite para los de prioridades inferiores.</span><span class="sxs-lookup"><span data-stu-id="f4296-277">Threads that have higher priorities than the ceiling are still allowed to preempt, while those less than the ceiling are not allowed to preempt.</span></span>

<span data-ttu-id="f4296-278">Por ejemplo, imagine que un subproceso de prioridad 20 solo interactúa con un grupo de subprocesos con prioridades entre 15 y 20.</span><span class="sxs-lookup"><span data-stu-id="f4296-278">For example, suppose a thread of priority 20 only interacts with a group of threads that have priorities between 15 and 20.</span></span> <span data-ttu-id="f4296-279">Durante sus secciones críticas, el subproceso de prioridad 20 puede establecer su umbral de adelantamiento en 15, con lo que se evita el adelantamiento de todos los subprocesos con los que interactúa.</span><span class="sxs-lookup"><span data-stu-id="f4296-279">During its critical sections, the thread of priority 20 can set its preemption-threshold to 15, thereby preventing preemption from all of the threads that it interacts with.</span></span> <span data-ttu-id="f4296-280">Esto todavía permite que los subprocesos realmente importantes (con prioridades entre 0 y 14) adelanten a este subproceso durante su procesamiento de las secciones críticas, lo que da como resultado un procesamiento mucho más dinámico.</span><span class="sxs-lookup"><span data-stu-id="f4296-280">This still permits really important threads (priorities between 0 and 14) to preempt this thread during its critical section processing, which results in much more responsive processing.</span></span>

<span data-ttu-id="f4296-281">Por supuesto, todavía es posible que un subproceso deshabilite todos los adelantamientos si establece su umbral de adelantamiento en 0.</span><span class="sxs-lookup"><span data-stu-id="f4296-281">Of course, it is still possible for a thread to disable all preemption by setting its preemption-threshold to 0.</span></span> <span data-ttu-id="f4296-282">Además, el umbral de adelantamiento se puede cambiar durante el tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="f4296-282">In addition, preemption-threshold can be changed during run-time.</span></span>

> [!NOTE]
> <span data-ttu-id="f4296-283">*El uso del umbral de adelantamiento deshabilita la segmentación temporal para el subproceso especificado.*</span><span class="sxs-lookup"><span data-stu-id="f4296-283">*Using preemption-threshold disables time-slicing for the specified thread.*</span></span>

### <a name="priority-inheritance"></a><span data-ttu-id="f4296-284">Herencia de prioridades</span><span class="sxs-lookup"><span data-stu-id="f4296-284">Priority Inheritance</span></span>

<span data-ttu-id="f4296-285">ThreadX también admite la herencia de prioridades opcional dentro de sus servicios de exclusión mutua descritos más adelante en este capítulo.</span><span class="sxs-lookup"><span data-stu-id="f4296-285">ThreadX also supports optional priority inheritance within its mutex services described later in this chapter.</span></span> <span data-ttu-id="f4296-286">La herencia de prioridades permite que un subproceso de prioridad inferior asuma temporalmente la de un subproceso de prioridad alta que espera una exclusión mutua propiedad del subproceso de prioridad inferior.</span><span class="sxs-lookup"><span data-stu-id="f4296-286">Priority inheritance allows a lower priority thread to temporarily assume the priority of a high priority thread that is waiting for a mutex owned by the lower priority thread.</span></span> <span data-ttu-id="f4296-287">Esta funcionalidad ayuda a la aplicación a evitar la inversión de prioridades no determinista eliminando el adelantamiento de las prioridades de subprocesos intermedias.</span><span class="sxs-lookup"><span data-stu-id="f4296-287">This capability helps the application to avoid nondeterministic priority inversion by eliminating preemption of intermediate thread priorities.</span></span> <span data-ttu-id="f4296-288">Por supuesto, se puede usar el *umbral de adelantamiento* para lograr un resultado similar.</span><span class="sxs-lookup"><span data-stu-id="f4296-288">Of course, *preemption-threshold* may be used to achieve a similar result.</span></span>

### <a name="thread-creation"></a><span data-ttu-id="f4296-289">Creación de subprocesos</span><span class="sxs-lookup"><span data-stu-id="f4296-289">Thread Creation</span></span>

<span data-ttu-id="f4296-290">Los subprocesos de aplicación se crean durante la inicialización o la ejecución de otros subprocesos de aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-290">Application threads are created during initialization or during the execution of other application threads.</span></span> <span data-ttu-id="f4296-291">No existe límite en cuanto al número de subprocesos que puede crear una aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-291">There is no limit on the number of threads that can be created by an application.</span></span>

### <a name="thread-control-block-tx_thread"></a><span data-ttu-id="f4296-292">TX_THREAD: bloque de control de subprocesos</span><span class="sxs-lookup"><span data-stu-id="f4296-292">Thread Control Block TX_THREAD</span></span>

<span data-ttu-id="f4296-293">Las características de cada subproceso se encuentran en su bloque de control.</span><span class="sxs-lookup"><span data-stu-id="f4296-293">The characteristics of each thread are contained in its control block.</span></span> <span data-ttu-id="f4296-294">Esta estructura se define en el archivo ***tx_api.h***.</span><span class="sxs-lookup"><span data-stu-id="f4296-294">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="f4296-295">Los bloques de control de subproceso se pueden ubicar en cualquier parte de la memoria, pero es más común convertir el bloque de control en una estructura global definiéndolo fuera del ámbito de cualquier función.</span><span class="sxs-lookup"><span data-stu-id="f4296-295">A thread's control block can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

<span data-ttu-id="f4296-296">Para colocar el bloque de control en otras áreas se necesita más cuidado, como sucede con la memoria asignada de forma dinámica.</span><span class="sxs-lookup"><span data-stu-id="f4296-296">Locating the control block in other areas requires a bit more care, just like all dynamically-allocated memory.</span></span> <span data-ttu-id="f4296-297">Si se asigna un bloque de control dentro de una función de C, la memoria asociada al mismo formará parte de la pila del subproceso que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="f4296-297">If a control block is allocated within a C function, the memory associated with it is part of the calling thread's stack.</span></span> <span data-ttu-id="f4296-298">En general, evite usar el almacenamiento local para los bloques de control, ya que, una vez devuelta la función, se libera todo su espacio de la pila de variables local, independientemente de si otro subproceso la usa para un bloque de control.</span><span class="sxs-lookup"><span data-stu-id="f4296-298">In general, avoid using local storage for control blocks because after the function returns, all of its local variable stack space is released—regardless of whether another thread is using it for a control block.</span></span>

<span data-ttu-id="f4296-299">En la mayoría de los casos, la aplicación desconoce el contenido del bloque de control del subproceso.</span><span class="sxs-lookup"><span data-stu-id="f4296-299">In most cases, the application is oblivious to the contents of the thread's control block.</span></span> <span data-ttu-id="f4296-300">Pero en algunas situaciones, especialmente durante la depuración, resulta útil examinar determinados miembros.</span><span class="sxs-lookup"><span data-stu-id="f4296-300">However, there are some situations, especially during debug, in which looking at certain members is useful.</span></span> <span data-ttu-id="f4296-301">A continuación se muestran algunos de los miembros de bloque de control más útiles.</span><span class="sxs-lookup"><span data-stu-id="f4296-301">The following are some of the more useful control block members.</span></span>

<span data-ttu-id="f4296-302">**tx_thread_run_count** contiene un contador del número de veces que se ha programado el subproceso.</span><span class="sxs-lookup"><span data-stu-id="f4296-302">**tx_thread_run_count** contains a counter of the number of many times the thread has been scheduled.</span></span> <span data-ttu-id="f4296-303">Un contador creciente indica que el subproceso se está programando y ejecutando.</span><span class="sxs-lookup"><span data-stu-id="f4296-303">An increasing counter indicates the thread is being scheduled and executed.</span></span>

<span data-ttu-id="f4296-304">**tx_thread_state** contiene el estado del subproceso asociado.</span><span class="sxs-lookup"><span data-stu-id="f4296-304">**tx_thread_state** contains the state of the associated thread.</span></span> <span data-ttu-id="f4296-305">A continuación se enumeran los estados de subproceso posibles.</span><span class="sxs-lookup"><span data-stu-id="f4296-305">The following lists the possible thread states.</span></span>

|  <span data-ttu-id="f4296-306">Estado de subproceso</span><span class="sxs-lookup"><span data-stu-id="f4296-306">Thread state</span></span>   | <span data-ttu-id="f4296-307">Value</span><span class="sxs-lookup"><span data-stu-id="f4296-307">Value</span></span> |
| --------------- | ------ |
| <span data-ttu-id="f4296-308">TX_READY</span><span class="sxs-lookup"><span data-stu-id="f4296-308">TX_READY</span></span>       | <span data-ttu-id="f4296-309">(0x00)</span><span class="sxs-lookup"><span data-stu-id="f4296-309">(0x00)</span></span> |
| <span data-ttu-id="f4296-310">TX_COMPLETED</span><span class="sxs-lookup"><span data-stu-id="f4296-310">TX_COMPLETED</span></span>   | <span data-ttu-id="f4296-311">(0x01)</span><span class="sxs-lookup"><span data-stu-id="f4296-311">(0x01)</span></span> |
| <span data-ttu-id="f4296-312">TX_TERMINATED</span><span class="sxs-lookup"><span data-stu-id="f4296-312">TX_TERMINATED</span></span>  | <span data-ttu-id="f4296-313">(0x02)</span><span class="sxs-lookup"><span data-stu-id="f4296-313">(0x02)</span></span> |
| <span data-ttu-id="f4296-314">TX_SUSPENDED</span><span class="sxs-lookup"><span data-stu-id="f4296-314">TX_SUSPENDED</span></span>   | <span data-ttu-id="f4296-315">(0x03)</span><span class="sxs-lookup"><span data-stu-id="f4296-315">(0x03)</span></span> |
| <span data-ttu-id="f4296-316">TX_SLEEP</span><span class="sxs-lookup"><span data-stu-id="f4296-316">TX_SLEEP</span></span>       | <span data-ttu-id="f4296-317">(0x04)</span><span class="sxs-lookup"><span data-stu-id="f4296-317">(0x04)</span></span> |
| <span data-ttu-id="f4296-318">TX_QUEUE_SUSP</span><span class="sxs-lookup"><span data-stu-id="f4296-318">TX_QUEUE_SUSP</span></span> | <span data-ttu-id="f4296-319">(0x05)</span><span class="sxs-lookup"><span data-stu-id="f4296-319">(0x05)</span></span> |
| <span data-ttu-id="f4296-320">TX_SEMAPHORE_SUSP</span><span class="sxs-lookup"><span data-stu-id="f4296-320">TX_SEMAPHORE_SUSP</span></span> | <span data-ttu-id="f4296-321">(0x06)</span><span class="sxs-lookup"><span data-stu-id="f4296-321">(0x06)</span></span> |
| <span data-ttu-id="f4296-322">TX_EVENT_FLAG</span><span class="sxs-lookup"><span data-stu-id="f4296-322">TX_EVENT_FLAG</span></span>   | <span data-ttu-id="f4296-323">(0x07)</span><span class="sxs-lookup"><span data-stu-id="f4296-323">(0x07)</span></span> |
| <span data-ttu-id="f4296-324">TX_BLOCK_MEMORY</span><span class="sxs-lookup"><span data-stu-id="f4296-324">TX_BLOCK_MEMORY</span></span> | <span data-ttu-id="f4296-325">(0x08)</span><span class="sxs-lookup"><span data-stu-id="f4296-325">(0x08)</span></span> |
| <span data-ttu-id="f4296-326">TX_BYTE_MEMORY</span><span class="sxs-lookup"><span data-stu-id="f4296-326">TX_BYTE_MEMORY</span></span>  | <span data-ttu-id="f4296-327">(0x09)</span><span class="sxs-lookup"><span data-stu-id="f4296-327">(0x09)</span></span> |
| <span data-ttu-id="f4296-328">TX_MUTEX_SUSP</span><span class="sxs-lookup"><span data-stu-id="f4296-328">TX_MUTEX_SUSP</span></span>   | <span data-ttu-id="f4296-329">(0x0D)</span><span class="sxs-lookup"><span data-stu-id="f4296-329">(0x0D)</span></span> |

> [!NOTE]
> <span data-ttu-id="f4296-330">*Evidentemente, hay otros muchos campos interesantes en el bloque de control de subprocesos, entre los que se incluyen el puntero de pila, el valor del segmento temporal, las prioridades, etc. Los usuarios pueden revisar los miembros del bloque de control, pero las modificaciones están totalmente prohibidas.*</span><span class="sxs-lookup"><span data-stu-id="f4296-330">*Of course there are many other interesting fields in the thread control block, including the stack pointer, time-slice value, priorities, etc. Users are welcome to review control block members, but modifications are strictly prohibited!*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f4296-331">*No hay ninguna equivalencia con el estado "en ejecución" mencionado antes en esta sección. No es necesario porque, en un momento dado, solo hay un subproceso en ejecución. El estado de un subproceso en ejecución también es* **TX_READY**.</span><span class="sxs-lookup"><span data-stu-id="f4296-331">*There is no equate for the "executing" state mentioned earlier in this section. It is not necessary because there is only one executing thread at a given time. The state of an executing thread is also* **TX_READY**.</span></span>

### <a name="currently-executing-thread"></a><span data-ttu-id="f4296-332">Subproceso en ejecución</span><span class="sxs-lookup"><span data-stu-id="f4296-332">Currently Executing Thread</span></span>

<span data-ttu-id="f4296-333">Como se ha mencionado antes, en un momento dado solo hay un subproceso en ejecución.</span><span class="sxs-lookup"><span data-stu-id="f4296-333">As mentioned before, there is only one thread executing at any given time.</span></span> <span data-ttu-id="f4296-334">Hay varias maneras de identificar el subproceso en ejecución, en función de cuál sea el que realice la solicitud.</span><span class="sxs-lookup"><span data-stu-id="f4296-334">There are several ways to identify the executing thread, depending on which thread is making the request.</span></span>
<span data-ttu-id="f4296-335">Un segmento de programa puede obtener la dirección del bloque de control del subproceso en ejecución llamando a ***tx_thread_identify***.</span><span class="sxs-lookup"><span data-stu-id="f4296-335">A program segment can get the control block address of the executing thread by calling ***tx_thread_identify***.</span></span> <span data-ttu-id="f4296-336">Esto resulta útil en partes compartidas del código de la aplicación que se ejecutan desde varios subprocesos.</span><span class="sxs-lookup"><span data-stu-id="f4296-336">This is useful in shared portions of application code that are executed from multiple threads.</span></span>

<span data-ttu-id="f4296-337">En las sesiones de depuración, los usuarios pueden examinar el puntero de ThreadX interno ***_tx_thread_current_ptr***.</span><span class="sxs-lookup"><span data-stu-id="f4296-337">In debug sessions, users can examine the internal ThreadX pointer ***_tx_thread_current_ptr***.</span></span> <span data-ttu-id="f4296-338">Contiene la dirección del bloque de control del subproceso actualmente en ejecución.</span><span class="sxs-lookup"><span data-stu-id="f4296-338">It contains the control block address of the currently executing thread.</span></span> <span data-ttu-id="f4296-339">Si este puntero es NULL, no hay ningún subproceso de aplicación en ejecución; es decir, ThreadX espera en su bucle de programación a que un subproceso esté listo.</span><span class="sxs-lookup"><span data-stu-id="f4296-339">If this pointer is NULL, no application thread is executing; i.e., ThreadX is waiting in its scheduling loop for a thread to become ready.</span></span>

### <a name="thread-stack-area"></a><span data-ttu-id="f4296-340">Área de pila de subprocesos</span><span class="sxs-lookup"><span data-stu-id="f4296-340">Thread Stack Area</span></span>

<span data-ttu-id="f4296-341">Cada subproceso debe tener su propia pila para guardar el contexto de su última ejecución y uso del compilador.</span><span class="sxs-lookup"><span data-stu-id="f4296-341">Each thread must have its own stack for saving the context of its last execution and compiler use.</span></span> <span data-ttu-id="f4296-342">La mayoría de los compiladores de C usan la pila para realizar llamadas de función y para asignar variables locales de forma temporal.</span><span class="sxs-lookup"><span data-stu-id="f4296-342">Most C compilers use the stack for making function calls and for temporarily allocating local variables.</span></span> <span data-ttu-id="f4296-343">En la figura 6 se muestra la pila de un subproceso típico.</span><span class="sxs-lookup"><span data-stu-id="f4296-343">Figure 6 shows a typical thread's stack.</span></span>

<span data-ttu-id="f4296-344">La ubicación de la pila de un subproceso en memoria depende de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-344">Where a thread stack is located in memory is up to the application.</span></span> <span data-ttu-id="f4296-345">El área de pila se especifica durante la creación del subproceso y se puede ubicar en cualquier parte del espacio de direcciones del destino.</span><span class="sxs-lookup"><span data-stu-id="f4296-345">The stack area is specified during thread creation and can be located anywhere in the target's address space.</span></span> <span data-ttu-id="f4296-346">Se trata de una característica importante porque permite a las aplicaciones mejorar el rendimiento de los subprocesos importantes colocando su pila en memoria RAM de alta velocidad.</span><span class="sxs-lookup"><span data-stu-id="f4296-346">This is an important feature because it allows applications to improve performance of important threads by placing their stack in high-speed RAM.</span></span>

<span data-ttu-id="f4296-347">**Área de memoria de la pila** (ejemplo)</span><span class="sxs-lookup"><span data-stu-id="f4296-347">**Stack Memory Area** (example)</span></span>

![Pila de subprocesos típica](./media/user-guide/typical-thread-stack.png)

<span data-ttu-id="f4296-349">**FIGURA 6. Pila de subprocesos típica**</span><span class="sxs-lookup"><span data-stu-id="f4296-349">**FIGURE 6. Typical Thread Stack**</span></span>

<span data-ttu-id="f4296-350">El tamaño de una pila es una de las preguntas más frecuentes sobre los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="f4296-350">How big a stack should be is one of the most frequently asked questions about threads.</span></span> <span data-ttu-id="f4296-351">El área de pila de un subproceso debe ser lo suficientemente grande como para acomodar el anidamiento de llamadas de función en el peor de los casos, la asignación de variables locales y el guardado de su último contexto de ejecución.</span><span class="sxs-lookup"><span data-stu-id="f4296-351">A thread's stack area must be large enough to accommodate worst-case function call nesting, local variable allocation, and saving its last execution context.</span></span>

<span data-ttu-id="f4296-352">ThreadX define el tamaño mínimo de la pila, **TX_MINIMUM_STACK**.</span><span class="sxs-lookup"><span data-stu-id="f4296-352">The minimum stack size, **TX_MINIMUM_STACK**, is defined by ThreadX.</span></span> <span data-ttu-id="f4296-353">Una pila de este tamaño permite guardar el contexto de un subproceso y una cantidad mínima de llamadas de función y asignación de variables locales.</span><span class="sxs-lookup"><span data-stu-id="f4296-353">A stack of this size supports saving a thread's context and minimum amount of function calls and local variable allocation.</span></span>

<span data-ttu-id="f4296-354">Pero para la mayoría de los subprocesos, el tamaño mínimo de la pila es demasiado pequeño y el usuario debe determinar el requisito de tamaño en el peor de los casos examinando el anidamiento de las llamadas de función y la asignación de variables locales.</span><span class="sxs-lookup"><span data-stu-id="f4296-354">For most threads, however, the minimum stack size is too small, and the user must ascertain the worst-case size requirement by examining function-call nesting and local variable allocation.</span></span> <span data-ttu-id="f4296-355">Por supuesto, siempre es mejor empezar con un área de pila más grande.</span><span class="sxs-lookup"><span data-stu-id="f4296-355">Of course, it is always better to start with a larger stack area.</span></span>

<span data-ttu-id="f4296-356">Después de depurar la aplicación, se pueden ajustar los tamaños de la pila de subprocesos si la memoria es escasa.</span><span class="sxs-lookup"><span data-stu-id="f4296-356">After the application is debugged, it is possible to tune the thread stack sizes if memory is scarce.</span></span> <span data-ttu-id="f4296-357">Un truco consiste en preestablecer todas las áreas de pila con un patrón de datos fácilmente identificable como (0xEFEF) antes de crear los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="f4296-357">A favorite trick is to preset all stack areas with an easily identifiable data pattern like (0xEFEF) prior to creating the threads.</span></span> <span data-ttu-id="f4296-358">Una vez que la aplicación se ha probado en profundidad, se pueden examinar las áreas de pila para ver la cantidad que se ha usado realmente; para ello, se busca el área de la pila en la que el patrón de datos sigue intacto.</span><span class="sxs-lookup"><span data-stu-id="f4296-358">After the application has been thoroughly put through its paces, the stack areas can be examined to see how much stack was actually used by finding the area of the stack where the data pattern is still intact.</span></span> <span data-ttu-id="f4296-359">En la figura 7 se muestra un valor de pila preestablecido en 0xEFEF después de la ejecución exhaustiva de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="f4296-359">Figure 7 shows a stack preset to 0xEFEF after thorough thread execution.</span></span>

<span data-ttu-id="f4296-360">**Área de memoria de la pila** (otro ejemplo)</span><span class="sxs-lookup"><span data-stu-id="f4296-360">**Stack Memory Area** (another example)</span></span>

![Valor de la pila preestablecido en 0xEFEF\*](./media/user-guide/stack-preset.png)

<span data-ttu-id="f4296-362">**FIGURA 7. Valor de la pila preestablecido en 0xEFEF**</span><span class="sxs-lookup"><span data-stu-id="f4296-362">**FIGURE 7. Stack Preset to 0xEFEF**</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f4296-363">*De forma predeterminada, ThreadX inicializa todos los bytes de cada pila de subprocesos con un valor de 0xEF.*</span><span class="sxs-lookup"><span data-stu-id="f4296-363">*By default, ThreadX initializes every byte of each thread stack with a value of 0xEF.*</span></span>

### <a name="memory-pitfalls"></a><span data-ttu-id="f4296-364">Errores de memoria</span><span class="sxs-lookup"><span data-stu-id="f4296-364">Memory Pitfalls</span></span>

<span data-ttu-id="f4296-365">Los requisitos de pila para los subprocesos pueden ser considerables.</span><span class="sxs-lookup"><span data-stu-id="f4296-365">The stack requirements for threads can be large.</span></span> <span data-ttu-id="f4296-366">Por tanto, es importante diseñar la aplicación para que tenga un número razonable de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="f4296-366">Therefore, it is important to design the application to have a reasonable number of threads.</span></span> <span data-ttu-id="f4296-367">Además, se debe tener cuidado para evitar un uso excesivo de la pila dentro de los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="f4296-367">Furthermore, some care must be taken to avoid excessive stack usage within threads.</span></span> <span data-ttu-id="f4296-368">Se deben evitar los algoritmos recursivos y las estructuras de datos locales de gran tamaño.</span><span class="sxs-lookup"><span data-stu-id="f4296-368">Recursive algorithms and large local data structures should be avoided.</span></span>

<span data-ttu-id="f4296-369">En la mayoría de los casos, una pila desbordada hace que la ejecución de los subprocesos afecte a la memoria adyacente (normalmente antes) de su área de pila.</span><span class="sxs-lookup"><span data-stu-id="f4296-369">In most cases, an overflowed stack causes thread execution to corrupt memory adjacent (usually before) its stack area.</span></span> <span data-ttu-id="f4296-370">Los resultados son imprevisibles, pero la mayoría de las veces provocan un cambio no natural en el contador de programas.</span><span class="sxs-lookup"><span data-stu-id="f4296-370">The results are unpredictable, but most often result in an unnatural change in the program counter.</span></span> <span data-ttu-id="f4296-371">Esto se suele denominar "analizar los pormenores".</span><span class="sxs-lookup"><span data-stu-id="f4296-371">This is often called "jumping into the weeds."</span></span> <span data-ttu-id="f4296-372">Por supuesto, la única manera de evitarlo es asegurarse de que todas las pilas de subproceso son lo suficientemente grandes.</span><span class="sxs-lookup"><span data-stu-id="f4296-372">Of course, the only way to prevent this is to ensure all thread stacks are large enough.</span></span>

### <a name="optional-run-time-stack-checking"></a><span data-ttu-id="f4296-373">Comprobación de pila en tiempo de ejecución opcional</span><span class="sxs-lookup"><span data-stu-id="f4296-373">Optional Run-time Stack Checking</span></span>

<span data-ttu-id="f4296-374">ThreadX proporciona la capacidad de comprobar en tiempo de ejecución la existencia de daños en la pila de cada subproceso.</span><span class="sxs-lookup"><span data-stu-id="f4296-374">ThreadX provides the ability to check each thread's stack for corruption during run-time.</span></span> <span data-ttu-id="f4296-375">De forma predeterminada, ThreadX rellena cada byte de las pilas de subproceso con un patrón de datos 0xEF durante la creación.</span><span class="sxs-lookup"><span data-stu-id="f4296-375">By default, ThreadX fills every byte of thread stacks with a 0xEF data pattern during creation.</span></span> <span data-ttu-id="f4296-376">Si la aplicación compila la biblioteca de ThreadX con **TX_ENABLE_STACK_CHECKING** definido, ThreadX examinará la pila de cada subproceso en busca de daños mientras se suspende o se reanuda.</span><span class="sxs-lookup"><span data-stu-id="f4296-376">If the application builds the ThreadX library with **TX_ENABLE_STACK_CHECKING** defined, ThreadX will examine each thread's stack for corruption as it is suspended or resumed.</span></span> <span data-ttu-id="f4296-377">Si se detectan daños en la pila, ThreadX llamará a la rutina de control de errores de pila de la aplicación como se especifica en la llamada a **_tx_thread_stack_error_notify_ *_. De lo contrario, si no se ha especificado ningún controlador de errores de pila, ThreadX llamará a la rutina interna _* _ _tx_thread_stack_error_handler_**.</span><span class="sxs-lookup"><span data-stu-id="f4296-377">If stack corruption is detected, ThreadX will call the application's stack error handling routine as specified by the call to **_tx_thread_stack_error_notify_*_. Otherwise, if no stack error handler was specified, ThreadX will call the internal _\* _ _tx_thread_stack_error_handler_*\* routine.</span></span>

### <a name="reentrancy"></a><span data-ttu-id="f4296-378">Reentrada</span><span class="sxs-lookup"><span data-stu-id="f4296-378">Reentrancy</span></span>

<span data-ttu-id="f4296-379">Uno de los atractivos reales de multithreading es que se puede llamar a la misma función de C desde varios subprocesos.</span><span class="sxs-lookup"><span data-stu-id="f4296-379">One of the real beauties of multithreading is that the same C function can be called from multiple threads.</span></span> <span data-ttu-id="f4296-380">Esto proporciona una gran potencia y también ayuda a reducir el espacio de código.</span><span class="sxs-lookup"><span data-stu-id="f4296-380">This provides great power and also helps reduce code space.</span></span> <span data-ttu-id="f4296-381">Pero es necesario que las funciones de C a las que se llama desde varios subprocesos sean *reentrantes*.</span><span class="sxs-lookup"><span data-stu-id="f4296-381">However, it does require that C functions called from multiple threads are *reentrant*.</span></span>

<span data-ttu-id="f4296-382">Básicamente, una función reentrante almacena en la pila actual la dirección de devolución del autor de la llamada y no se basa en las variables de C globales o estáticas que ha configurado antes.</span><span class="sxs-lookup"><span data-stu-id="f4296-382">Basically, a reentrant function stores the caller's return address on the current stack and does not rely on global or static C variables that it previously set up.</span></span> <span data-ttu-id="f4296-383">La mayoría de los compiladores colocan la dirección de devolución en la pila.</span><span class="sxs-lookup"><span data-stu-id="f4296-383">Most compilers place the return address on the stack.</span></span> <span data-ttu-id="f4296-384">Por tanto, los desarrolladores de aplicaciones solo deben preocuparse por el uso de las variables *globales* y *estáticas*.</span><span class="sxs-lookup"><span data-stu-id="f4296-384">Hence, application developers must only worry about the use of *globals* and *statics*.</span></span>

<span data-ttu-id="f4296-385">Un ejemplo de una función no reentrante es la función de token de cadena ***strtok*** de la biblioteca estándar de C.</span><span class="sxs-lookup"><span data-stu-id="f4296-385">An example of a non-reentrant function is the string token function ***strtok*** found in the standard C library.</span></span> <span data-ttu-id="f4296-386">Esta función "recuerda" el puntero de cadena anterior en las llamadas siguientes.</span><span class="sxs-lookup"><span data-stu-id="f4296-386">This function "remembers" the previous string pointer on subsequent calls.</span></span> <span data-ttu-id="f4296-387">Y lo hace con un puntero de cadena estático.</span><span class="sxs-lookup"><span data-stu-id="f4296-387">It does this with a static string pointer.</span></span> <span data-ttu-id="f4296-388">Si se llama a esta función desde varios subprocesos, lo más probable es que devuelva un puntero no válido.</span><span class="sxs-lookup"><span data-stu-id="f4296-388">If this function is called from multiple threads, it would most likely return an invalid pointer.</span></span>

### <a name="thread-priority-pitfalls"></a><span data-ttu-id="f4296-389">Problemas de prioridad de subprocesos</span><span class="sxs-lookup"><span data-stu-id="f4296-389">Thread Priority Pitfalls</span></span>

<span data-ttu-id="f4296-390">La selección de prioridades de subprocesos es uno de los aspectos más importantes del multithreading.</span><span class="sxs-lookup"><span data-stu-id="f4296-390">Selecting thread priorities is one of the most important aspects of multithreading.</span></span> <span data-ttu-id="f4296-391">En ocasiones, es muy tentador asignar prioridades en función de una noción percibida de la importancia del subproceso, en lugar de determinar lo que es exactamente necesario durante el tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="f4296-391">It is sometimes very tempting to assign priorities based on a perceived notion of thread importance rather than determining what is exactly required during run-time.</span></span> <span data-ttu-id="f4296-392">El uso incorrecto de las prioridades de subproceso puede colapsar a otros subprocesos, crear la inversión de prioridades, reducir el ancho de banda de procesamiento y dificultar la comprensión del comportamiento en tiempo de ejecución de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-392">Misuse of thread priorities can starve other threads, create priority inversion, reduce processing bandwidth, and make the application's run-time behavior difficult to understand.</span></span>

<span data-ttu-id="f4296-393">Como se ha mencionado antes, ThreadX proporciona un algoritmo de programación de adelantamiento basado en la prioridad.</span><span class="sxs-lookup"><span data-stu-id="f4296-393">As mentioned before, ThreadX provides a priority-based, preemptive scheduling algorithm.</span></span> <span data-ttu-id="f4296-394">Los subprocesos de menor prioridad no se ejecutan hasta que no hay subprocesos de prioridad más alta listos para ejecutarse.</span><span class="sxs-lookup"><span data-stu-id="f4296-394">Lower priority threads do not execute until there are no higher priority threads ready for execution.</span></span> <span data-ttu-id="f4296-395">Si un subproceso de prioridad más alta está siempre listo, los subprocesos de menor prioridad nunca se ejecutan.</span><span class="sxs-lookup"><span data-stu-id="f4296-395">If a higher priority thread is always ready, the lower priority threads never execute.</span></span> <span data-ttu-id="f4296-396">Esta condición se denomina *colapso de subprocesos*.</span><span class="sxs-lookup"><span data-stu-id="f4296-396">This condition is called *thread starvation*.</span></span>

<span data-ttu-id="f4296-397">La mayoría de los problemas de colapso de subprocesos se detectan pronto en la depuración y se pueden resolver asegurándose de que los subprocesos de prioridad más alta no se ejecutan de forma continuada.</span><span class="sxs-lookup"><span data-stu-id="f4296-397">Most thread starvation problems are detected early in debug and can be solved by ensuring that higher priority threads don't execute continuously.</span></span> <span data-ttu-id="f4296-398">Como alternativa, se puede agregar lógica a la aplicación que genere gradualmente la prioridad de los subprocesos colapsados hasta que tengan la oportunidad de ejecutarse.</span><span class="sxs-lookup"><span data-stu-id="f4296-398">Alternatively, logic can be added to the application that gradually raises the priority of starved threads until they get a chance to execute.</span></span>

<span data-ttu-id="f4296-399">Otro problema asociado a las prioridades de subprocesos es el de *inversión de prioridades*.</span><span class="sxs-lookup"><span data-stu-id="f4296-399">Another pitfall associated with thread priorities is *priority inversion*.</span></span> <span data-ttu-id="f4296-400">La inversión de prioridades tiene lugar cuando se suspende un subproceso de prioridad superior porque otro de prioridad inferior tiene un recurso necesario.</span><span class="sxs-lookup"><span data-stu-id="f4296-400">Priority inversion takes place when a higher priority thread is suspended because a lower priority thread has a needed resource.</span></span> <span data-ttu-id="f4296-401">Evidentemente, en algunos casos es necesario que dos subprocesos de prioridad diferente compartan un recurso común.</span><span class="sxs-lookup"><span data-stu-id="f4296-401">Of course, in some instances it is necessary for two threads of different priority to share a common resource.</span></span> <span data-ttu-id="f4296-402">Si estos subprocesos son los únicos activos, el tiempo de inversión de prioridades está limitado por el tiempo que el subproceso de prioridad inferior mantiene el recurso.</span><span class="sxs-lookup"><span data-stu-id="f4296-402">If these threads are the only ones active, the priority inversion time is bounded by the time the lower priority thread holds the resource.</span></span> <span data-ttu-id="f4296-403">Esta condición es determinista y bastante normal.</span><span class="sxs-lookup"><span data-stu-id="f4296-403">This condition is both deterministic and quite normal.</span></span> <span data-ttu-id="f4296-404">Pero si durante esta condición de inversión de prioridades se activan subprocesos de prioridad intermedia, el tiempo de inversión de prioridades deja de ser determinista y podría provocar un error en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-404">However, if threads of intermediate priority become active during this priority inversion condition, the priority inversion time is no longer deterministic and could cause an application failure.</span></span>

<span data-ttu-id="f4296-405">Existen principalmente tres métodos distintos para evitar la inversión de prioridades no determinista en ThreadX.</span><span class="sxs-lookup"><span data-stu-id="f4296-405">There are principally three distinct methods of preventing nondeterministic priority inversion in ThreadX.</span></span> <span data-ttu-id="f4296-406">En primer lugar, las selecciones de prioridad de la aplicación y el comportamiento en tiempo de ejecución se pueden diseñar de forma que se impida el problema de inversión de prioridades.</span><span class="sxs-lookup"><span data-stu-id="f4296-406">First, the application priority selections and run-time behavior can be designed in a manner that prevents the priority inversion problem.</span></span> <span data-ttu-id="f4296-407">En segundo lugar, los subprocesos de menor prioridad pueden usar el *umbral de adelantamiento* para bloquear el adelantamiento de los subprocesos intermedios mientras comparten recursos con subprocesos de mayor prioridad.</span><span class="sxs-lookup"><span data-stu-id="f4296-407">Second, lower priority threads can utilize *preemption threshold* to block preemption from intermediate threads while they share resources with higher priority threads.</span></span> <span data-ttu-id="f4296-408">Por último, los subprocesos que usan objetos de exclusión mutua de ThreadX para proteger los recursos del sistema pueden usar la *herencia de prioridades* de exclusión mutua opcional para eliminar la inversión de prioridades no determinista.</span><span class="sxs-lookup"><span data-stu-id="f4296-408">Finally, threads using ThreadX mutex objects to protect system resources may utilize the optional mutex *priority inheritance* to eliminate nondeterministic priority inversion.</span></span>

### <a name="priority-overhead"></a><span data-ttu-id="f4296-409">Sobrecarga de prioridades</span><span class="sxs-lookup"><span data-stu-id="f4296-409">Priority Overhead</span></span>

<span data-ttu-id="f4296-410">Una de las formas más infravaloradas de reducir la sobrecarga en el multithreading consiste en reducir el número de cambios de contexto.</span><span class="sxs-lookup"><span data-stu-id="f4296-410">One of the most overlooked ways to reduce overhead in multithreading is to reduce the number of context switches.</span></span> <span data-ttu-id="f4296-411">Como se ha mencionado antes, un cambio de contexto se produce cuando se favorece la ejecución de un subproceso de prioridad más alta antes que la del subproceso en ejecución.</span><span class="sxs-lookup"><span data-stu-id="f4296-411">As previously mentioned, a context switch occurs when execution of a higher priority thread is favored over that of the executing thread.</span></span> <span data-ttu-id="f4296-412">Merece la pena mencionar que los subprocesos de mayor prioridad pueden estar listos como resultado de eventos externos (como interrupciones) y llamadas de servicio realizadas por el subproceso en ejecución.</span><span class="sxs-lookup"><span data-stu-id="f4296-412">It is worthwhile to mention that higher priority threads can become ready as a result of both external events (like interrupts) and from service calls made by the executing thread.</span></span>

<span data-ttu-id="f4296-413">Para ilustrar los efectos que tienen las prioridades de subproceso en la sobrecarga del cambio de contexto, imagine un entorno de tres subprocesos: *subproceso_1*, *subproceso_2* y *subproceso_3*.</span><span class="sxs-lookup"><span data-stu-id="f4296-413">To illustrate the effects thread priorities have on context switch overhead, assume a three thread environment with threads named *thread_1*, *thread_2*, and *thread_3*.</span></span> <span data-ttu-id="f4296-414">Imagine además que todos los subprocesos están en un estado de suspensión en espera de un mensaje.</span><span class="sxs-lookup"><span data-stu-id="f4296-414">Assume further that all of the threads are in a state of suspension waiting for a message.</span></span> <span data-ttu-id="f4296-415">Cuando el subproceso_1 recibe un mensaje, lo reenvía inmediatamente al subproceso_2.</span><span class="sxs-lookup"><span data-stu-id="f4296-415">When thread_1 receives a message, it immediately forwards it to thread_2.</span></span> <span data-ttu-id="f4296-416">Después, el subproceso_2 reenvía el mensaje al subproceso_3.</span><span class="sxs-lookup"><span data-stu-id="f4296-416">Thread_2 then forwards the message to thread_3.</span></span> <span data-ttu-id="f4296-417">El subproceso_3 simplemente descarta el mensaje.</span><span class="sxs-lookup"><span data-stu-id="f4296-417">Thread_3 just discards the message.</span></span> <span data-ttu-id="f4296-418">Una vez que cada subproceso procesa su mensaje, retrocede y espera otro mensaje.</span><span class="sxs-lookup"><span data-stu-id="f4296-418">After each thread processes its message, it goes back and waits for another message.</span></span>

<span data-ttu-id="f4296-419">El procesamiento necesario para ejecutar estos tres subprocesos varía considerablemente en función de sus prioridades.</span><span class="sxs-lookup"><span data-stu-id="f4296-419">The processing required to execute these three threads varies greatly depending on their priorities.</span></span> <span data-ttu-id="f4296-420">Si todos los subprocesos tienen la misma prioridad, solo se produce un cambio de contexto antes de la ejecución de cada uno.</span><span class="sxs-lookup"><span data-stu-id="f4296-420">If all of the threads have the same priority, a single context switch occurs before the execution of each thread.</span></span> <span data-ttu-id="f4296-421">El cambio de contexto se produce cuando cada subproceso se suspende en una cola de mensajes vacía.</span><span class="sxs-lookup"><span data-stu-id="f4296-421">The context switch occurs when each thread suspends on an empty message queue.</span></span>

<span data-ttu-id="f4296-422">Pero si el subproceso_2 tiene mayor prioridad que el subproceso_1, y el subproceso_3 tiene mayor prioridad que el subproceso_2, se duplica el número de cambios de contexto.</span><span class="sxs-lookup"><span data-stu-id="f4296-422">However, if thread_2 is higher priority than thread_1 and thread_3 is higher priority than thread_2, the number of context switches doubles.</span></span> <span data-ttu-id="f4296-423">Esto se debe a que se produce otro cambio de contexto dentro del servicio *tx_queue_send* cuando este detecta que un subproceso de prioridad más alta ya está listo.</span><span class="sxs-lookup"><span data-stu-id="f4296-423">This is because another context switch occurs inside of the *tx_queue_send* service when it detects that a higher priority thread is now ready.</span></span>

<span data-ttu-id="f4296-424">El mecanismo de umbral de adelantamiento de ThreadX puede evitar estos modificadores de contexto adicionales y seguir permitiendo las selecciones de prioridad mencionadas anteriormente.</span><span class="sxs-lookup"><span data-stu-id="f4296-424">The ThreadX preemption-threshold mechanism can avoid these extra context switches and still allow the previously mentioned priority selections.</span></span> <span data-ttu-id="f4296-425">Se trata de una característica importante porque permite varias prioridades de subproceso durante la programación, al tiempo que elimina algunos de los cambios de contexto no deseados entre ellos durante la ejecución de los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="f4296-425">This is an important feature because it allows several thread priorities during scheduling, while at the same time eliminating some of the unwanted context switching between them during thread execution.</span></span>

### <a name="run-time-thread-performance-information"></a><span data-ttu-id="f4296-426">Información sobre el rendimiento de subprocesos en tiempo de ejecución</span><span class="sxs-lookup"><span data-stu-id="f4296-426">Run-time Thread Performance Information</span></span>

<span data-ttu-id="f4296-427">ThreadX proporciona información opcional sobre el rendimiento de los subprocesos en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="f4296-427">ThreadX provides optional run-time thread performance information.</span></span> <span data-ttu-id="f4296-428">Si la biblioteca y la aplicación de ThreadX se compilan con **TX_THREAD_ENABLE_PERFORMANCE_INFO** definido, ThreadX acumula la información siguiente.</span><span class="sxs-lookup"><span data-stu-id="f4296-428">If the ThreadX library and application is built with **TX_THREAD_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="f4296-429">Número total del sistema general:</span><span class="sxs-lookup"><span data-stu-id="f4296-429">Total number for the overall system:</span></span>

  - <span data-ttu-id="f4296-430">reanudaciones de subprocesos</span><span class="sxs-lookup"><span data-stu-id="f4296-430">thread resumptions</span></span>

  - <span data-ttu-id="f4296-431">suspensiones de subprocesos</span><span class="sxs-lookup"><span data-stu-id="f4296-431">thread suspensions</span></span>

  - <span data-ttu-id="f4296-432">adelantamientos de llamadas de servicio</span><span class="sxs-lookup"><span data-stu-id="f4296-432">service call preemptions</span></span>

  - <span data-ttu-id="f4296-433">adelantamientos de interrupción</span><span class="sxs-lookup"><span data-stu-id="f4296-433">interrupt preemptions</span></span>

  - <span data-ttu-id="f4296-434">inversiones de prioridad</span><span class="sxs-lookup"><span data-stu-id="f4296-434">priority inversions</span></span>

  - <span data-ttu-id="f4296-435">segmentos temporales</span><span class="sxs-lookup"><span data-stu-id="f4296-435">time-slices</span></span>

  - <span data-ttu-id="f4296-436">abandonos</span><span class="sxs-lookup"><span data-stu-id="f4296-436">relinquishes</span></span>

  - <span data-ttu-id="f4296-437">tiempos de espera de subprocesos</span><span class="sxs-lookup"><span data-stu-id="f4296-437">thread timeouts</span></span>

  - <span data-ttu-id="f4296-438">anulaciones de suspensión</span><span class="sxs-lookup"><span data-stu-id="f4296-438">suspension aborts</span></span>

  - <span data-ttu-id="f4296-439">devoluciones del sistema inactivas</span><span class="sxs-lookup"><span data-stu-id="f4296-439">idle system returns</span></span>

  - <span data-ttu-id="f4296-440">devoluciones del sistema no inactivas</span><span class="sxs-lookup"><span data-stu-id="f4296-440">non-idle system returns</span></span>

<span data-ttu-id="f4296-441">Número total de cada subproceso:</span><span class="sxs-lookup"><span data-stu-id="f4296-441">Total number for each thread:</span></span>

  - <span data-ttu-id="f4296-442">reanudaciones</span><span class="sxs-lookup"><span data-stu-id="f4296-442">resumptions</span></span>

  - <span data-ttu-id="f4296-443">suspensiones</span><span class="sxs-lookup"><span data-stu-id="f4296-443">suspensions</span></span>

  - <span data-ttu-id="f4296-444">adelantamientos de llamadas de servicio</span><span class="sxs-lookup"><span data-stu-id="f4296-444">service call preemptions</span></span>

  - <span data-ttu-id="f4296-445">adelantamientos de interrupción</span><span class="sxs-lookup"><span data-stu-id="f4296-445">interrupt preemptions</span></span>

  - <span data-ttu-id="f4296-446">inversiones de prioridad</span><span class="sxs-lookup"><span data-stu-id="f4296-446">priority inversions</span></span>

  - <span data-ttu-id="f4296-447">segmentos temporales</span><span class="sxs-lookup"><span data-stu-id="f4296-447">time-slices</span></span>

  - <span data-ttu-id="f4296-448">abandonos de subproceso</span><span class="sxs-lookup"><span data-stu-id="f4296-448">thread relinquishes</span></span>

  - <span data-ttu-id="f4296-449">tiempos de espera de subprocesos</span><span class="sxs-lookup"><span data-stu-id="f4296-449">thread timeouts</span></span>

  - <span data-ttu-id="f4296-450">anulaciones de suspensión</span><span class="sxs-lookup"><span data-stu-id="f4296-450">suspension aborts</span></span>

<span data-ttu-id="f4296-451">Esta información está disponible en tiempo de ejecución mediante los servicios ***tx_thread_performance_info_get** _ y _*_tx_thread_performance_system_info_get_\*\*.</span><span class="sxs-lookup"><span data-stu-id="f4296-451">This information is available at run-time through the services ***tx_thread_performance_info_get** _ and _*_tx_thread_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="f4296-452">La información de rendimiento de los subprocesos resulta útil para determinar si la aplicación se comporta de manera correcta.</span><span class="sxs-lookup"><span data-stu-id="f4296-452">Thread performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="f4296-453">También es útil para optimizar la aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-453">It is also useful in optimizing the application.</span></span> <span data-ttu-id="f4296-454">Por ejemplo, es posible que un número relativamente alto de adelantos de llamada de servicio sugiera que la prioridad o el umbral de adelantamiento del subproceso son demasiado bajos.</span><span class="sxs-lookup"><span data-stu-id="f4296-454">For example, a relatively high number of service call preemptions might suggest the thread's priority and/or preemption-threshold is too low.</span></span> <span data-ttu-id="f4296-455">Además, un número relativamente bajo de devoluciones del sistema inactivas podría sugerir que los subprocesos de menor prioridad no se suspenden lo suficiente.</span><span class="sxs-lookup"><span data-stu-id="f4296-455">Furthermore, a relatively low number of idle system returns might suggest that lower priority threads are not suspending enough.</span></span>

### <a name="debugging-pitfalls"></a><span data-ttu-id="f4296-456">Errores de depuración</span><span class="sxs-lookup"><span data-stu-id="f4296-456">Debugging Pitfalls</span></span>

<span data-ttu-id="f4296-457">La depuración de aplicaciones multiproceso es algo más difícil, ya que el mismo código de programa se puede ejecutar desde varios subprocesos.</span><span class="sxs-lookup"><span data-stu-id="f4296-457">Debugging multithreaded applications is a little more difficult because the same program code can be executed from multiple threads.</span></span> <span data-ttu-id="f4296-458">En esos casos, es posible que no sea suficiente con un punto de interrupción.</span><span class="sxs-lookup"><span data-stu-id="f4296-458">In such cases, a break-point alone may not be enough.</span></span> <span data-ttu-id="f4296-459">El depurador también debe ver el puntero del subproceso actual **_tx_thread_current_ptr** con un punto de interrupción condicional para comprobar si el subproceso que realiza la llamada es el que se va a depurar.</span><span class="sxs-lookup"><span data-stu-id="f4296-459">The debugger must also view the current thread pointer **_tx_thread_current_ptr** using a conditional breakpoint to see if the calling thread is the one to debug.</span></span>

<span data-ttu-id="f4296-460">Gran parte de esta operación se controla en los paquetes de soporte de multithreading que ofrecen distintos proveedores de herramientas de desarrollo.</span><span class="sxs-lookup"><span data-stu-id="f4296-460">Much of this is being handled in multithreading support packages offered through various development tool vendors.</span></span> <span data-ttu-id="f4296-461">Debido a su diseño sencillo, la integración de ThreadX con diferentes herramientas de desarrollo es relativamente sencilla.</span><span class="sxs-lookup"><span data-stu-id="f4296-461">Because of its simple design, integrating ThreadX with different development tools is relatively easy.</span></span>

<span data-ttu-id="f4296-462">El tamaño de la pila es siempre un tema de depuración importante en el multithreading.</span><span class="sxs-lookup"><span data-stu-id="f4296-462">Stack size is always an important debug topic in multithreading.</span></span> <span data-ttu-id="f4296-463">Siempre que se observa un comportamiento inexplicable, una buena solución inicial suele consistir en aumentar los tamaños de pila de todos los subprocesos, especialmente el del último que se va a ejecutar.</span><span class="sxs-lookup"><span data-stu-id="f4296-463">Whenever unexplained behavior is observed, it is usually a good first guess to increase stack sizes for all threads—especially the stack size of the last thread to execute!</span></span>

> [!TIP]
> <span data-ttu-id="f4296-464">*También es aconsejable crear la biblioteca de ThreadX con **TX_ENABLE_STACK_CHECKING** definido. Esto ayudará a aislar los problemas de daños en la pila tan pronto como sea posible en el procesamiento.*</span><span class="sxs-lookup"><span data-stu-id="f4296-464">*It is also a good idea to build the ThreadX library with **TX_ENABLE_STACK_CHECKING** defined. This will help isolate stack corruption problems as early in the processing as possible.*</span></span>

## <a name="message-queues"></a><span data-ttu-id="f4296-465">Colas de mensajes</span><span class="sxs-lookup"><span data-stu-id="f4296-465">Message Queues</span></span>

<span data-ttu-id="f4296-466">Las colas de mensajes son el medio principal de la comunicación entre subprocesos en ThreadX.</span><span class="sxs-lookup"><span data-stu-id="f4296-466">Message queues are the primary means of inter-thread communication in ThreadX.</span></span> <span data-ttu-id="f4296-467">En una cola de mensajes puede haber uno o varios mensajes.</span><span class="sxs-lookup"><span data-stu-id="f4296-467">One or more messages can reside in a message queue.</span></span> <span data-ttu-id="f4296-468">Una cola de mensajes que contiene un solo mensaje normalmente se denomina *buzón*.</span><span class="sxs-lookup"><span data-stu-id="f4296-468">A message queue that holds a single message is commonly called a *mailbox*.</span></span>

<span data-ttu-id="f4296-469">Los mensajes se copian en una cola por medio de ***tx_queue_send** _ y desde una cola con _*_tx_queue_receive_\*\*.</span><span class="sxs-lookup"><span data-stu-id="f4296-469">Messages are copied to a queue by ***tx_queue_send** _ and are copied from a queue by _*_tx_queue_receive_\*\*.</span></span> <span data-ttu-id="f4296-470">La única excepción es cuando se suspende un subproceso mientras se espera un mensaje en una cola vacía.</span><span class="sxs-lookup"><span data-stu-id="f4296-470">The only exception to this is when a thread is suspended while waiting for a message on an empty queue.</span></span> <span data-ttu-id="f4296-471">En este caso, el siguiente mensaje que se envía a la cola se coloca directamente en el área de destino del subproceso.</span><span class="sxs-lookup"><span data-stu-id="f4296-471">In this case, the next message sent to the queue is placed directly into the thread's destination area.</span></span>

<span data-ttu-id="f4296-472">Cada cola de mensajes es un recurso público.</span><span class="sxs-lookup"><span data-stu-id="f4296-472">Each message queue is a public resource.</span></span> <span data-ttu-id="f4296-473">ThreadX no aplica restricciones al modo de usar las colas de mensajes.</span><span class="sxs-lookup"><span data-stu-id="f4296-473">ThreadX places no constraints on how message queues are used.</span></span>

### <a name="creating-message-queues"></a><span data-ttu-id="f4296-474">Creación de colas de mensajes</span><span class="sxs-lookup"><span data-stu-id="f4296-474">Creating Message Queues</span></span>

<span data-ttu-id="f4296-475">Las colas de mensajes se crean durante la inicialización o en tiempo de ejecución mediante subprocesos de aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-475">Message queues are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="f4296-476">No hay ningún límite en cuanto al número de colas de mensajes de una aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-476">There is no limit on the number of message queues in an application.</span></span>

### <a name="message-size"></a><span data-ttu-id="f4296-477">Tamaño de los mensajes</span><span class="sxs-lookup"><span data-stu-id="f4296-477">Message Size</span></span>

<span data-ttu-id="f4296-478">Cada cola de mensajes admite una serie de mensajes de tamaño fijo.</span><span class="sxs-lookup"><span data-stu-id="f4296-478">Each message queue supports a number of fixed-sized messages.</span></span> <span data-ttu-id="f4296-479">Los tamaños de mensaje disponibles son de 1 a 16 palabras de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="f4296-479">The available message sizes are 1 through 16 32-bit words inclusive.</span></span> <span data-ttu-id="f4296-480">El tamaño del mensaje se especifica cuando se crea la cola.</span><span class="sxs-lookup"><span data-stu-id="f4296-480">The message size is specified when the queue is created.</span></span> <span data-ttu-id="f4296-481">Los mensajes de aplicación de más de 16 palabras se deben pasar mediante un puntero.</span><span class="sxs-lookup"><span data-stu-id="f4296-481">Application messages greater than 16 words must be passed by pointer.</span></span> <span data-ttu-id="f4296-482">Esto se logra creando una cola con un tamaño de mensaje de 1 palabra (suficiente para contener un puntero) y, después, enviando y recibiendo punteros de mensaje en lugar del mensaje completo.</span><span class="sxs-lookup"><span data-stu-id="f4296-482">This is accomplished by creating a queue with a message size of 1 word (enough to hold a pointer) and then sending and receiving message pointers instead of the entire message.</span></span>

### <a name="message-queue-capacity"></a><span data-ttu-id="f4296-483">Capacidad de una cola de mensajes</span><span class="sxs-lookup"><span data-stu-id="f4296-483">Message Queue Capacity</span></span>

<span data-ttu-id="f4296-484">El número de mensajes que puede contener una cola es una función del tamaño del mensaje y el tamaño del área de memoria suministrado durante la creación.</span><span class="sxs-lookup"><span data-stu-id="f4296-484">The number of messages a queue can hold is a function of its message size and the size of the memory area supplied during creation.</span></span> <span data-ttu-id="f4296-485">Para calcular la capacidad total de mensajes de la cola, se divide el número de bytes de cada mensaje entre el número total de bytes del área de memoria proporcionada.</span><span class="sxs-lookup"><span data-stu-id="f4296-485">The total message capacity of the queue is calculated by dividing the number of bytes in each message into the total number of bytes in the supplied memory area.</span></span>

<span data-ttu-id="f4296-486">Por ejemplo, si se crea una cola de mensajes que admite un tamaño de mensaje de una palabra de 32 bits (4 bytes) con un área de memoria de 100 bytes, su capacidad es de 25 mensajes.</span><span class="sxs-lookup"><span data-stu-id="f4296-486">For example, if a message queue that supports a message size of 1 32-bit word (4 bytes) is created with a 100-byte memory area, its capacity is 25 messages.</span></span>

### <a name="queue-memory-area"></a><span data-ttu-id="f4296-487">Área de memoria de cola</span><span class="sxs-lookup"><span data-stu-id="f4296-487">Queue Memory Area</span></span>

<span data-ttu-id="f4296-488">Como se ha mencionado anteriormente, el área de memoria para almacenar en búfer los mensajes se especifica durante la creación de la cola.</span><span class="sxs-lookup"><span data-stu-id="f4296-488">As mentioned previously, the memory area for buffering messages is specified during queue creation.</span></span> <span data-ttu-id="f4296-489">Como sucede con otras áreas de memoria de ThreadX, se puede ubicar en cualquier parte del espacio de direcciones del destino.</span><span class="sxs-lookup"><span data-stu-id="f4296-489">Like other memory areas in ThreadX, it can be located anywhere in the target's address space.</span></span>

<span data-ttu-id="f4296-490">Se trata de una característica importante porque ofrece a la aplicación una gran flexibilidad.</span><span class="sxs-lookup"><span data-stu-id="f4296-490">This is an important feature because it gives the application considerable flexibility.</span></span> <span data-ttu-id="f4296-491">Por ejemplo, es posible que una aplicación coloque el área de memoria de una cola importante en memoria RAM de alta velocidad para mejorar el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="f4296-491">For example, an application might locate the memory area of an important queue in high-speed RAM to improve performance.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="f4296-492">Suspensión de subprocesos</span><span class="sxs-lookup"><span data-stu-id="f4296-492">Thread Suspension</span></span>

<span data-ttu-id="f4296-493">Los subprocesos de aplicación se pueden suspender al intentar enviar o recibir un mensaje de una cola.</span><span class="sxs-lookup"><span data-stu-id="f4296-493">Application threads can suspend while attempting to send or receive a message from a queue.</span></span> <span data-ttu-id="f4296-494">Normalmente, la suspensión de subprocesos implica esperar un mensaje de una cola vacía.</span><span class="sxs-lookup"><span data-stu-id="f4296-494">Typically, thread suspension involves waiting for a message from an empty queue.</span></span> <span data-ttu-id="f4296-495">Pero también es posible que un subproceso se suspenda al intentar enviar un mensaje a una cola completa.</span><span class="sxs-lookup"><span data-stu-id="f4296-495">However, it is also possible for a thread to suspend trying to send a message to a full queue.</span></span>

<span data-ttu-id="f4296-496">Una vez que se resuelve la condición de la suspensión, el servicio solicitado se completa y se reanuda el subproceso en espera.</span><span class="sxs-lookup"><span data-stu-id="f4296-496">After the condition for suspension is resolved, the service requested is completed and the waiting thread is resumed.</span></span> <span data-ttu-id="f4296-497">Si se suspenden varios subprocesos en la misma cola, se reanudan en el orden en el que se hayan suspendido (FIFO).</span><span class="sxs-lookup"><span data-stu-id="f4296-497">If multiple threads are suspended on the same queue, they are resumed in the order they were suspended (FIFO).</span></span>

<span data-ttu-id="f4296-498">Pero la reanudación de la prioridad también es posible si la aplicación llama a ***tx_queue_prioritize*** antes del servicio de cola que levanta la suspensión del subproceso.</span><span class="sxs-lookup"><span data-stu-id="f4296-498">However, priority resumption is also possible if the application calls ***tx_queue_prioritize*** prior to the queue service that lifts thread suspension.</span></span> <span data-ttu-id="f4296-499">El servicio de clasificación por orden de prioridad de las colas coloca el subproceso de prioridad más alta al principio de la lista de suspensiones y deja todos los demás subprocesos suspendidos en el mismo orden FIFO.</span><span class="sxs-lookup"><span data-stu-id="f4296-499">The queue prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

<span data-ttu-id="f4296-500">También hay tiempos de espera disponibles para todas las suspensiones de cola.</span><span class="sxs-lookup"><span data-stu-id="f4296-500">Time-outs are also available for all queue suspensions.</span></span> <span data-ttu-id="f4296-501">Básicamente, un tiempo de espera especifica el número máximo de tics de temporizador que el subproceso permanecerá suspendido.</span><span class="sxs-lookup"><span data-stu-id="f4296-501">Basically, a time-out specifies the maximum number of timer ticks the thread will stay suspended.</span></span> <span data-ttu-id="f4296-502">Si se agota el tiempo de espera, el subproceso se reanuda y el servicio devuelve el código de error adecuado.</span><span class="sxs-lookup"><span data-stu-id="f4296-502">If a time-out occurs, the thread is resumed and the service returns with the appropriate error code.</span></span>

### <a name="queue-send-notification"></a><span data-ttu-id="f4296-503">Notificación de envío de cola</span><span class="sxs-lookup"><span data-stu-id="f4296-503">Queue Send Notification</span></span>

<span data-ttu-id="f4296-504">Es posible que algunas aplicaciones se beneficien de recibir una notificación cada vez que un mensaje se coloca en una cola.</span><span class="sxs-lookup"><span data-stu-id="f4296-504">Some applications may find it advantageous to be notified whenever a message is placed on a queue.</span></span> <span data-ttu-id="f4296-505">ThreadX proporciona esta función por medio del servicio ***tx_queue_send_notify***.</span><span class="sxs-lookup"><span data-stu-id="f4296-505">ThreadX provides this ability through the ***tx_queue_send_notify*** service.</span></span> <span data-ttu-id="f4296-506">Este servicio registra la función de notificación de aplicación proporcionada con la cola especificada.</span><span class="sxs-lookup"><span data-stu-id="f4296-506">This service registers the supplied application notification function with the specified queue.</span></span> <span data-ttu-id="f4296-507">Después, ThreadX invocará esta función de notificación de aplicación cada vez que se envíe un mensaje a la cola.</span><span class="sxs-lookup"><span data-stu-id="f4296-507">ThreadX will subsequently invoke this application notification function whenever a message is sent to the queue.</span></span> <span data-ttu-id="f4296-508">El procesamiento exacto dentro de la función de notificación de aplicación viene determinado por la aplicación; pero normalmente consiste en reanudar el subproceso adecuado para procesar el nuevo mensaje.</span><span class="sxs-lookup"><span data-stu-id="f4296-508">The exact processing within the application notification function is determined by the application; however, it typically consists of resuming the appropriate thread for processing the new message.</span></span>

### <a name="queue-event-chainingtrade"></a><span data-ttu-id="f4296-509">Encadenamiento de eventos de cola&trade;</span><span class="sxs-lookup"><span data-stu-id="f4296-509">Queue Event chaining&trade;</span></span>

<span data-ttu-id="f4296-510">Las funciones de notificación de ThreadX se pueden usar para encadenar varios eventos de sincronización.</span><span class="sxs-lookup"><span data-stu-id="f4296-510">The notification capabilities in ThreadX can be used to chain various synchronization events together.</span></span> <span data-ttu-id="f4296-511">Esto suele ser útil cuando un único subproceso debe procesar varios eventos de sincronización.</span><span class="sxs-lookup"><span data-stu-id="f4296-511">This is typically useful when a single thread must process multiple synchronization events.</span></span>

<span data-ttu-id="f4296-512">Por ejemplo, imagine que un único subproceso es responsable de procesar los mensajes de cinco colas diferentes y que también se debe suspender cuando no haya mensajes disponibles.</span><span class="sxs-lookup"><span data-stu-id="f4296-512">For example, suppose a single thread is responsible for processing messages from five different queues and must also suspend when no messages are available.</span></span> <span data-ttu-id="f4296-513">Esto se consigue fácilmente registrando una función de notificación de aplicación para cada cola y agregando un semáforo de recuento adicional.</span><span class="sxs-lookup"><span data-stu-id="f4296-513">This is easily accomplished by registering an application notification function for each queue and introducing an additional counting semaphore.</span></span> <span data-ttu-id="f4296-514">En concreto, la función de notificación de aplicación ejecuta *tx_semaphore_put* cada vez que se le llama (el recuento de semáforos representa el número total de mensajes en las cinco colas).</span><span class="sxs-lookup"><span data-stu-id="f4296-514">Specifically, the application notification function performs a *tx_semaphore_put* whenever it is called (the semaphore count represents the total number of messages in all five queues).</span></span> <span data-ttu-id="f4296-515">El subproceso de procesamiento se suspende en este semáforo por medio del servicio *tx_semaphore_get*.</span><span class="sxs-lookup"><span data-stu-id="f4296-515">The processing thread suspends on this semaphore via the *tx_semaphore_get* service.</span></span> <span data-ttu-id="f4296-516">Cuando el semáforo está disponible (en este caso, cuando hay un mensaje disponible), se reanuda el subproceso de procesamiento.</span><span class="sxs-lookup"><span data-stu-id="f4296-516">When the semaphore is available (in this case, when a message is available!), the processing thread is resumed.</span></span> <span data-ttu-id="f4296-517">Después, solicita un mensaje a cada cola, procesa el mensaje encontrado y vuelve a ejecutar ***tx_semaphore_get*** para esperar al siguiente mensaje.</span><span class="sxs-lookup"><span data-stu-id="f4296-517">It then interrogates each queue for a message, processes the found message, and performs another ***tx_semaphore_get*** to wait for the next message.</span></span> <span data-ttu-id="f4296-518">La realización de esta tarea sin el encadenamiento de eventos es bastante difícil y es probable que necesite más subprocesos o código de aplicación adicional.</span><span class="sxs-lookup"><span data-stu-id="f4296-518">Accomplishing this without event-chaining is quite difficult and likely would require more threads and/or additional application code.</span></span>

<span data-ttu-id="f4296-519">En general, el *encadenamiento de eventos* genera menos subprocesos, menos sobrecarga y requisitos de RAM más pequeños.</span><span class="sxs-lookup"><span data-stu-id="f4296-519">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="f4296-520">También proporciona un mecanismo muy flexible para controlar los requisitos de sincronización de sistemas más complejos.</span><span class="sxs-lookup"><span data-stu-id="f4296-520">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span>

### <a name="run-time-queue-performance-information"></a><span data-ttu-id="f4296-521">Información de rendimiento de colas en tiempo de ejecución</span><span class="sxs-lookup"><span data-stu-id="f4296-521">Run-time Queue Performance Information</span></span>
<span data-ttu-id="f4296-522">ThreadX proporciona información opcional sobre el rendimiento de las colas en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="f4296-522">ThreadX provides optional run-time queue performance information.</span></span> <span data-ttu-id="f4296-523">Si la biblioteca y la aplicación de ThreadX se compilan con ***TX_QUEUE_ENABLE_PERFORMANCE_INFO*** definido, ThreadX acumula la información siguiente.</span><span class="sxs-lookup"><span data-stu-id="f4296-523">If the ThreadX library and application is built with ***TX_QUEUE_ENABLE_PERFORMANCE_INFO*** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="f4296-524">Número total del sistema general:</span><span class="sxs-lookup"><span data-stu-id="f4296-524">Total number for the overall system:</span></span>

  - <span data-ttu-id="f4296-525">mensajes enviados</span><span class="sxs-lookup"><span data-stu-id="f4296-525">messages sent</span></span>

  - <span data-ttu-id="f4296-526">mensajes recibidos</span><span class="sxs-lookup"><span data-stu-id="f4296-526">messages received</span></span>

  - <span data-ttu-id="f4296-527">suspensiones vacías de cola</span><span class="sxs-lookup"><span data-stu-id="f4296-527">queue empty suspensions</span></span>

  - <span data-ttu-id="f4296-528">suspensiones llenas de cola</span><span class="sxs-lookup"><span data-stu-id="f4296-528">queue full suspensions</span></span>

  - <span data-ttu-id="f4296-529">devoluciones de errores completos de cola (suspensión sin especificar)</span><span class="sxs-lookup"><span data-stu-id="f4296-529">queue full error returns (suspension not specified)</span></span>

  - <span data-ttu-id="f4296-530">tiempos de espera de cola</span><span class="sxs-lookup"><span data-stu-id="f4296-530">queue timeouts</span></span>

<span data-ttu-id="f4296-531">Número total de cada cola:</span><span class="sxs-lookup"><span data-stu-id="f4296-531">Total number for each queue:</span></span>

  - <span data-ttu-id="f4296-532">mensajes enviados</span><span class="sxs-lookup"><span data-stu-id="f4296-532">messages sent</span></span>

  - <span data-ttu-id="f4296-533">mensajes recibidos</span><span class="sxs-lookup"><span data-stu-id="f4296-533">messages received</span></span>

  - <span data-ttu-id="f4296-534">suspensiones vacías de cola</span><span class="sxs-lookup"><span data-stu-id="f4296-534">queue empty suspensions</span></span>

  - <span data-ttu-id="f4296-535">suspensiones llenas de cola</span><span class="sxs-lookup"><span data-stu-id="f4296-535">queue full suspensions</span></span>

  - <span data-ttu-id="f4296-536">devoluciones de errores completos de cola (suspensión sin especificar)</span><span class="sxs-lookup"><span data-stu-id="f4296-536">queue full error returns (suspension not specified)</span></span>

  - <span data-ttu-id="f4296-537">tiempos de espera de cola</span><span class="sxs-lookup"><span data-stu-id="f4296-537">queue timeouts</span></span>

<span data-ttu-id="f4296-538">Esta información está disponible en tiempo de ejecución por medio de los servicios ***tx_queue_performance_info_get** _ y _*_tx_queue_performance_system_info_get_\*\*.</span><span class="sxs-lookup"><span data-stu-id="f4296-538">This information is available at run-time through the services ***tx_queue_performance_info_get** _ and _*_tx_queue_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="f4296-539">La información de rendimiento de las colas resulta útil para determinar si la aplicación se comporta de manera correcta.</span><span class="sxs-lookup"><span data-stu-id="f4296-539">Queue performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="f4296-540">También es útil para optimizar la aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-540">It is also useful in optimizing the application.</span></span> <span data-ttu-id="f4296-541">Por ejemplo, un número relativamente alto de "suspensiones completas de cola" sugiere que un aumento en el tamaño de la cola podría ser beneficioso.</span><span class="sxs-lookup"><span data-stu-id="f4296-541">For example, a relatively high number of "queue full suspensions" suggests an increase in the queue size might be beneficial.</span></span>

### <a name="queue-control-block-tx_queue"></a><span data-ttu-id="f4296-542">TX_QUEUE: bloque de control de cola</span><span class="sxs-lookup"><span data-stu-id="f4296-542">Queue Control Block TX_QUEUE</span></span>

<span data-ttu-id="f4296-543">Las características de cada cola de mensajes se encuentran en su bloque de control.</span><span class="sxs-lookup"><span data-stu-id="f4296-543">The characteristics of each message queue are found in its control block.</span></span> <span data-ttu-id="f4296-544">Contiene información interesante, como el número de mensajes de la cola.</span><span class="sxs-lookup"><span data-stu-id="f4296-544">It contains interesting information such as the number of messages in the queue.</span></span> <span data-ttu-id="f4296-545">Esta estructura se define en el archivo ***tx_api.h***.</span><span class="sxs-lookup"><span data-stu-id="f4296-545">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="f4296-546">Los bloques de control de cola de mensajes se pueden ubicar en cualquier parte de la memoria, pero es más común convertir el bloque de control en una estructura global definiéndolo fuera del ámbito de cualquier función.</span><span class="sxs-lookup"><span data-stu-id="f4296-546">Message queue control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="message-destination-pitfall"></a><span data-ttu-id="f4296-547">Error de destino del mensaje</span><span class="sxs-lookup"><span data-stu-id="f4296-547">Message Destination Pitfall</span></span>

<span data-ttu-id="f4296-548">Como se ha mencionado antes, los mensajes se copian entre el área de cola y las áreas de datos de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-548">As mentioned previously, messages are copied between the queue area and application data areas.</span></span> <span data-ttu-id="f4296-549">Es importante asegurarse de que el destino de un mensaje recibido sea lo suficientemente grande como para contener todo el mensaje.</span><span class="sxs-lookup"><span data-stu-id="f4296-549">It is important to ensure the destination for a received message is large enough to hold the entire message.</span></span> <span data-ttu-id="f4296-550">De lo contrario, es probable que la memoria que sigue al destino del mensaje resulte dañada.</span><span class="sxs-lookup"><span data-stu-id="f4296-550">If not, the memory following the message destination will likely be corrupted.</span></span>

> [!NOTE]
> <span data-ttu-id="f4296-551">*Esto es especialmente grave cuando un destino de mensaje demasiado pequeño está en la pila; no hay nada peor que los daños en la dirección de devolución de una función.*</span><span class="sxs-lookup"><span data-stu-id="f4296-551">*This is especially lethal when a too-small message destination is on the stack—nothing like corrupting the return address of a function!*</span></span>

## <a name="counting-semaphores"></a><span data-ttu-id="f4296-552">Semáforos de recuento</span><span class="sxs-lookup"><span data-stu-id="f4296-552">Counting Semaphores</span></span>

<span data-ttu-id="f4296-553">ThreadX proporciona semáforos de recuento de 32 bits con un valor que oscila entre 0 y 4 294 967 295.</span><span class="sxs-lookup"><span data-stu-id="f4296-553">ThreadX provides 32-bit counting semaphores that range in value between 0 and 4,294,967,295.</span></span> <span data-ttu-id="f4296-554">Hay dos operaciones para el recuento de semáforos: *tx_semaphore_get* y *tx_semaphore_put*.</span><span class="sxs-lookup"><span data-stu-id="f4296-554">There are two operations for counting semaphores: *tx_semaphore_get* and *tx_semaphore_put*.</span></span> <span data-ttu-id="f4296-555">La operación Get reduce el semáforo en uno.</span><span class="sxs-lookup"><span data-stu-id="f4296-555">The get operation decreases the semaphore by one.</span></span> <span data-ttu-id="f4296-556">Si el semáforo es 0, la operación Get no se realiza correctamente.</span><span class="sxs-lookup"><span data-stu-id="f4296-556">If the semaphore is 0, the get operation is not successful.</span></span> <span data-ttu-id="f4296-557">La operación Put es la inversa de la operación Get.</span><span class="sxs-lookup"><span data-stu-id="f4296-557">The inverse of the get operation is the put operation.</span></span>
<span data-ttu-id="f4296-558">Aumenta el semáforo en uno.</span><span class="sxs-lookup"><span data-stu-id="f4296-558">It increases the semaphore by one.</span></span>

<span data-ttu-id="f4296-559">Cada semáforo de recuento es un recurso público.</span><span class="sxs-lookup"><span data-stu-id="f4296-559">Each counting semaphore is a public resource.</span></span> <span data-ttu-id="f4296-560">ThreadX no aplica restricciones al modo de usar los semáforos de recuento.</span><span class="sxs-lookup"><span data-stu-id="f4296-560">ThreadX places no constraints on how counting semaphores are used.</span></span>

<span data-ttu-id="f4296-561">Los semáforos de recuento se usan normalmente para la *exclusión mutua*.</span><span class="sxs-lookup"><span data-stu-id="f4296-561">Counting semaphores are typically used for *mutual exclusion*.</span></span> <span data-ttu-id="f4296-562">Pero también se pueden usar como un método para la notificación de eventos.</span><span class="sxs-lookup"><span data-stu-id="f4296-562">However, counting semaphores can also be used as a method for event notification.</span></span>

### <a name="mutual-exclusion"></a><span data-ttu-id="f4296-563">Exclusión mutua</span><span class="sxs-lookup"><span data-stu-id="f4296-563">Mutual Exclusion</span></span>

 <span data-ttu-id="f4296-564">La exclusión mutua corresponde a controlar el acceso de los subprocesos a determinadas áreas de la aplicación (también denominadas *secciones críticas* o *recursos de aplicación*).</span><span class="sxs-lookup"><span data-stu-id="f4296-564">Mutual exclusion pertains to controlling the access of threads to certain application areas (also called *critical sections* or *application resources*).</span></span> <span data-ttu-id="f4296-565">Cuando se usa para la exclusión mutua, el "recuento actual" de un semáforo representa el número total de subprocesos a los que se permite el acceso.</span><span class="sxs-lookup"><span data-stu-id="f4296-565">When used for mutual exclusion, the "current count" of a semaphore represents the total number of threads that are allowed access.</span></span> <span data-ttu-id="f4296-566">En la mayoría de los casos, el recuento de semáforos usados para la exclusión mutua tendrá un valor inicial de 1, lo que significa que solo un subproceso puede acceder al recurso asociado a la vez.</span><span class="sxs-lookup"><span data-stu-id="f4296-566">In most cases, counting semaphores used for mutual exclusion will have an initial value of 1, meaning that only one thread can access the associated resource at a time.</span></span> <span data-ttu-id="f4296-567">Los semáforos de recuento que solo tienen los valores 0 o 1 se denominan normalmente *semáforos binarios*.</span><span class="sxs-lookup"><span data-stu-id="f4296-567">Counting semaphores that only have values of 0 or 1 are commonly called *binary semaphores*.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f4296-568">*Si se usa un semáforo binario, el usuario debe evitar que el mismo subproceso realice una operación Get en un semáforo que ya posee. Una segunda operación Get no sería correcta y podría provocar una suspensión indefinida del subproceso que realiza la llamada y la falta de disponibilidad permanente del recurso.*</span><span class="sxs-lookup"><span data-stu-id="f4296-568">*If a binary semaphore is being used, the user must prevent the same thread from performing a get operation on a semaphore it already owns. A second get would be unsuccessful and could cause indefinite suspension of the calling thread and permanent unavailability of the resource.*</span></span>

### <a name="event-notification"></a><span data-ttu-id="f4296-569">Notificación de evento</span><span class="sxs-lookup"><span data-stu-id="f4296-569">Event Notification</span></span>

<span data-ttu-id="f4296-570">También es posible usar semáforos de recuento como notificación de eventos, en un modo de productor y consumidor.</span><span class="sxs-lookup"><span data-stu-id="f4296-570">It is also possible to use counting semaphores as event notification, in a producer-consumer fashion.</span></span> <span data-ttu-id="f4296-571">El consumidor intenta obtener el semáforo de recuento mientras el productor lo aumenta siempre que haya algo disponible.</span><span class="sxs-lookup"><span data-stu-id="f4296-571">The consumer attempts to get the counting semaphore while the producer increases the semaphore whenever something is available.</span></span> <span data-ttu-id="f4296-572">Estos semáforos suelen tener un valor inicial de 0 y no aumentarán hasta que el productor tenga algo preparado para el consumidor.</span><span class="sxs-lookup"><span data-stu-id="f4296-572">Such semaphores usually have an initial value of 0 and will not increase until the producer has something ready for the consumer.</span></span> <span data-ttu-id="f4296-573">Los semáforos que se usan para la notificación de eventos también se pueden beneficiar del uso de la llamada de servicio ***tx_semaphore_ceiling_put***.</span><span class="sxs-lookup"><span data-stu-id="f4296-573">Semaphores used for event notification may also benefit from use of the ***tx_semaphore_ceiling_put*** service call.</span></span> <span data-ttu-id="f4296-574">Este servicio garantiza que el recuento de semáforos nunca supere el valor proporcionado en la llamada.</span><span class="sxs-lookup"><span data-stu-id="f4296-574">This service ensures that the semaphore count never exceeds the value supplied in the call.</span></span>

### <a name="creating-counting-semaphores"></a><span data-ttu-id="f4296-575">Creación de semáforos de recuento</span><span class="sxs-lookup"><span data-stu-id="f4296-575">Creating Counting Semaphores</span></span>

<span data-ttu-id="f4296-576">Los semáforos de recuento se crean durante la inicialización o en tiempo de ejecución mediante subprocesos de aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-576">Counting semaphores are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="f4296-577">El recuento inicial del semáforo se especifica durante la creación.</span><span class="sxs-lookup"><span data-stu-id="f4296-577">The initial count of the semaphore is specified during creation.</span></span> <span data-ttu-id="f4296-578">No hay ningún límite en cuanto al número de semáforos de recuento en una aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-578">There is no limit on the number of counting semaphores in an application.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="f4296-579">Suspensión de subprocesos</span><span class="sxs-lookup"><span data-stu-id="f4296-579">Thread Suspension</span></span>

<span data-ttu-id="f4296-580">Los subprocesos de aplicación se pueden suspender mientras se intenta realizar una operación Get en un semáforo con un recuento actual de 0.</span><span class="sxs-lookup"><span data-stu-id="f4296-580">Application threads can suspend while attempting to perform a get operation on a semaphore with a current count of 0.</span></span>

<span data-ttu-id="f4296-581">Después de realizar una operación Put, se realiza la operación Get del subproceso suspendido y se reanuda.</span><span class="sxs-lookup"><span data-stu-id="f4296-581">After a put operation is performed, the suspended thread's get operation is performed and the thread is resumed.</span></span> <span data-ttu-id="f4296-582">Si se suspenden varios subprocesos en el mismo semáforo de recuento, se reanudan en el orden en el que se hayan suspendido (FIFO).</span><span class="sxs-lookup"><span data-stu-id="f4296-582">If multiple threads are suspended on the same counting semaphore, they are resumed in the same order they were suspended (FIFO).</span></span>

<span data-ttu-id="f4296-583">Pero la reanudación de la prioridad también es posible si la aplicación llama a ***tx_semaphore_prioritize*** antes de la llamada a Put del semáforo que levanta la suspensión del subproceso.</span><span class="sxs-lookup"><span data-stu-id="f4296-583">However, priority resumption is also possible if the application calls ***tx_semaphore_prioritize*** prior to the semaphore put call that lifts thread suspension.</span></span> <span data-ttu-id="f4296-584">El servicio de clasificación por orden de prioridad de los semáforos coloca el subproceso de prioridad más alta al principio de la lista de suspensiones y deja todos los demás subprocesos suspendidos en el mismo orden FIFO.</span><span class="sxs-lookup"><span data-stu-id="f4296-584">The semaphore prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="semaphore-put-notification"></a><span data-ttu-id="f4296-585">Notificación Put de semáforo</span><span class="sxs-lookup"><span data-stu-id="f4296-585">Semaphore Put Notification</span></span>

<span data-ttu-id="f4296-586">Es posible que algunas aplicaciones se beneficien de recibir una notificación cada vez que se agrega un semáforo.</span><span class="sxs-lookup"><span data-stu-id="f4296-586">Some applications may find it advantageous to be notified whenever a semaphore is put.</span></span> <span data-ttu-id="f4296-587">ThreadX proporciona esta función por medio del servicio ***tx_semaphore_put_notify***.</span><span class="sxs-lookup"><span data-stu-id="f4296-587">ThreadX provides this ability through the ***tx_semaphore_put_notify*** service.</span></span> <span data-ttu-id="f4296-588">Este servicio registra la función de notificación de aplicación proporcionada con el semáforo especificado.</span><span class="sxs-lookup"><span data-stu-id="f4296-588">This service registers the supplied application notification function with the specified semaphore.</span></span> <span data-ttu-id="f4296-589">Después, ThreadX invocará esta función de notificación de aplicación cada vez que se coloque el semáforo.</span><span class="sxs-lookup"><span data-stu-id="f4296-589">ThreadX will subsequently invoke this application notification function whenever the semaphore is put.</span></span> <span data-ttu-id="f4296-590">El procesamiento exacto dentro de la función de notificación de aplicación viene determinado por la aplicación; pero normalmente consiste en reanudar el subproceso adecuado para procesar el nuevo evento Put del semáforo.</span><span class="sxs-lookup"><span data-stu-id="f4296-590">The exact processing within the application notification function is determined by the application; however, it typically consists of resuming the appropriate thread for processing the new semaphore put event.</span></span>

### <a name="semaphore-event-chainingtrade"></a><span data-ttu-id="f4296-591">Encadenamiento de eventos de semáforo&trade;</span><span class="sxs-lookup"><span data-stu-id="f4296-591">Semaphore Event chaining&trade;</span></span>

<span data-ttu-id="f4296-592">Las funciones de notificación de ThreadX se pueden usar para encadenar varios eventos de sincronización.</span><span class="sxs-lookup"><span data-stu-id="f4296-592">The notification capabilities in ThreadX can be used to chain various synchronization events together.</span></span> <span data-ttu-id="f4296-593">Esto suele ser útil cuando un único subproceso debe procesar varios eventos de sincronización.</span><span class="sxs-lookup"><span data-stu-id="f4296-593">This is typically useful when a single thread must process multiple synchronization events.</span></span>

<span data-ttu-id="f4296-594">Por ejemplo, en lugar de suspender subprocesos independientes para un mensaje de cola, marcas de eventos y un semáforo, la aplicación puede registrar una rutina de notificación para cada objeto.</span><span class="sxs-lookup"><span data-stu-id="f4296-594">For example, instead of having separate threads suspend for a queue message, event flags, and a semaphore, the application can register a notification routine for each object.</span></span> <span data-ttu-id="f4296-595">Cuando se invoca, la rutina de notificación de aplicación puede reanudar un solo subproceso, que puede interrogar cada objeto para buscar y procesar el nuevo evento.</span><span class="sxs-lookup"><span data-stu-id="f4296-595">When invoked, the application notification routine can then resume a single thread, which can interrogate each object to find and process the new event.</span></span>

<span data-ttu-id="f4296-596">En general, el *encadenamiento de eventos* genera menos subprocesos, menos sobrecarga y requisitos de RAM más pequeños.</span><span class="sxs-lookup"><span data-stu-id="f4296-596">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="f4296-597">También proporciona un mecanismo muy flexible para controlar los requisitos de sincronización de sistemas más complejos.</span><span class="sxs-lookup"><span data-stu-id="f4296-597">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span>

### <a name="run-time-semaphore-performance-information"></a><span data-ttu-id="f4296-598">Información de rendimiento de semáforos en tiempo de ejecución</span><span class="sxs-lookup"><span data-stu-id="f4296-598">Run-time Semaphore Performance Information</span></span>

<span data-ttu-id="f4296-599">ThreadX proporciona información opcional sobre el rendimiento de los semáforos en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="f4296-599">ThreadX provides optional run-time semaphore performance information.</span></span> <span data-ttu-id="f4296-600">Si la biblioteca y la aplicación de ThreadX se compilan con **TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO** definido, ThreadX acumula la información siguiente.</span><span class="sxs-lookup"><span data-stu-id="f4296-600">If the ThreadX library and application is built with **TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="f4296-601">Número total del sistema general:</span><span class="sxs-lookup"><span data-stu-id="f4296-601">Total number for the overall system:</span></span>

  - <span data-ttu-id="f4296-602">operaciones Put de semáforo</span><span class="sxs-lookup"><span data-stu-id="f4296-602">semaphore puts</span></span>

  - <span data-ttu-id="f4296-603">operaciones Get de semáforo</span><span class="sxs-lookup"><span data-stu-id="f4296-603">semaphore gets</span></span>

  - <span data-ttu-id="f4296-604">suspensiones de operaciones Get de semáforo</span><span class="sxs-lookup"><span data-stu-id="f4296-604">semaphore get suspensions</span></span>

  - <span data-ttu-id="f4296-605">tiempo de espera de operaciones Get de semáforo</span><span class="sxs-lookup"><span data-stu-id="f4296-605">semaphore get timeouts</span></span>

<span data-ttu-id="f4296-606">Número total de cada semáforo:</span><span class="sxs-lookup"><span data-stu-id="f4296-606">Total number for each semaphore:</span></span>

  - <span data-ttu-id="f4296-607">operaciones Put de semáforo</span><span class="sxs-lookup"><span data-stu-id="f4296-607">semaphore puts</span></span>

  - <span data-ttu-id="f4296-608">operaciones Get de semáforo</span><span class="sxs-lookup"><span data-stu-id="f4296-608">semaphore gets</span></span>

  - <span data-ttu-id="f4296-609">suspensiones de operaciones Get de semáforo</span><span class="sxs-lookup"><span data-stu-id="f4296-609">semaphore get suspensions</span></span>

  - <span data-ttu-id="f4296-610">tiempo de espera de operaciones Get de semáforo</span><span class="sxs-lookup"><span data-stu-id="f4296-610">semaphore get timeouts</span></span>

<span data-ttu-id="f4296-611">Esta información está disponible en tiempo de ejecución por medio de los servicios ***tx_semaphore_performance_info_get** _ y _*_tx_semaphore_performance_system_info_get_\*\*.</span><span class="sxs-lookup"><span data-stu-id="f4296-611">This information is available at run-time through the services ***tx_semaphore_performance_info_get** _ and _*_tx_semaphore_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="f4296-612">La información de rendimiento de los semáforos resulta útil para determinar si la aplicación se comporta de manera correcta.</span><span class="sxs-lookup"><span data-stu-id="f4296-612">Semaphore performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="f4296-613">También es útil para optimizar la aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-613">It is also useful in optimizing the application.</span></span> <span data-ttu-id="f4296-614">Por ejemplo, un número relativamente alto de "tiempos de espera de operaciones Get de semáforo" podría sugerir que otros subprocesos conservan los recursos durante demasiado tiempo.</span><span class="sxs-lookup"><span data-stu-id="f4296-614">For example, a relatively high number of "semaphore get timeouts" might suggest that other threads are holding resources too long.</span></span>

### <a name="semaphore-control-block-tx_semaphore"></a><span data-ttu-id="f4296-615">TX_SEMAPHORE: bloque de control de semáforo</span><span class="sxs-lookup"><span data-stu-id="f4296-615">Semaphore Control Block TX_SEMAPHORE</span></span>

<span data-ttu-id="f4296-616">Las características de cada semáforo de recuento se encuentran en su bloque de control.</span><span class="sxs-lookup"><span data-stu-id="f4296-616">The characteristics of each counting semaphore are found in its control block.</span></span> <span data-ttu-id="f4296-617">Contiene información como el recuento de semáforos actual.</span><span class="sxs-lookup"><span data-stu-id="f4296-617">It contains information such as the current semaphore count.</span></span> <span data-ttu-id="f4296-618">Esta estructura se define en el archivo ***tx_api.h***.</span><span class="sxs-lookup"><span data-stu-id="f4296-618">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="f4296-619">Los bloques de control de semáforo se pueden ubicar en cualquier parte de la memoria, pero es más común convertir el bloque de control en una estructura global definiéndolo fuera del ámbito de cualquier función.</span><span class="sxs-lookup"><span data-stu-id="f4296-619">Semaphore control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="deadly-embrace"></a><span data-ttu-id="f4296-620">Adopción letal</span><span class="sxs-lookup"><span data-stu-id="f4296-620">Deadly Embrace</span></span>

<span data-ttu-id="f4296-621">Uno de los riesgos más interesantes y peligrosos asociados a los semáforos que se usan para la exclusión mutua es el de la *adopción letal*.</span><span class="sxs-lookup"><span data-stu-id="f4296-621">One of the most interesting and dangerous pitfalls associated with semaphores used for mutual exclusion is the *deadly embrace*.</span></span> <span data-ttu-id="f4296-622">Una adopción letal, o *interbloqueo*, es una condición en la que dos o más subprocesos se suspenden indefinidamente mientras intentan obtener semáforos que ya les pertenecen.</span><span class="sxs-lookup"><span data-stu-id="f4296-622">A deadly embrace, or *deadlock*, is a condition in which two or more threads are suspended indefinitely while attempting to get semaphores already owned by each other.</span></span>

<span data-ttu-id="f4296-623">Esta condición se ilustra mejor en un ejemplo de dos subprocesos y dos semáforos.</span><span class="sxs-lookup"><span data-stu-id="f4296-623">This condition is best illustrated by a two thread, two semaphore example.</span></span> <span data-ttu-id="f4296-624">Imagine que el primer subproceso posee el primer semáforo y el segundo subproceso posee el segundo semáforo.</span><span class="sxs-lookup"><span data-stu-id="f4296-624">Suppose the first thread owns the first semaphore and the second thread owns the second semaphore.</span></span> <span data-ttu-id="f4296-625">Si el primer subproceso intenta obtener el segundo semáforo y, al mismo tiempo, el segundo subproceso intenta obtener el primer semáforo, los dos subprocesos entran en una condición de interbloqueo.</span><span class="sxs-lookup"><span data-stu-id="f4296-625">If the first thread attempts to get the second semaphore and at the same time the second thread attempts to get the first semaphore, both threads enter a deadlock condition.</span></span> <span data-ttu-id="f4296-626">Además, si estos subprocesos permanecen suspendidos de manera indefinida, sus recursos asociados también se bloquean de forma permanente.</span><span class="sxs-lookup"><span data-stu-id="f4296-626">In addition, if these threads stay suspended forever, their associated resources are locked-out forever as well.</span></span> <span data-ttu-id="f4296-627">En la figura 8 se ilustra este ejemplo.</span><span class="sxs-lookup"><span data-stu-id="f4296-627">Figure 8 illustrates this example.</span></span>

<span data-ttu-id="f4296-628">**Adopción letal** (ejemplo)</span><span class="sxs-lookup"><span data-stu-id="f4296-628">**Deadly Embrace** (example)</span></span>

![Ejemplo de subprocesos suspendidos](./media/user-guide/example-suspended-threads.png)

<span data-ttu-id="f4296-630">**FIGURA 8. Ejemplo de subprocesos suspendidos**</span><span class="sxs-lookup"><span data-stu-id="f4296-630">**FIGURE 8. Example of Suspended Threads**</span></span>

<span data-ttu-id="f4296-631">En el caso de los sistemas en tiempo real, los interbloqueos se pueden evitar si se aplican determinadas restricciones al modo en que los subprocesos obtienen los semáforos.</span><span class="sxs-lookup"><span data-stu-id="f4296-631">For real-time systems, deadly embraces can be prevented by placing certain restrictions on how threads obtain semaphores.</span></span> <span data-ttu-id="f4296-632">Los subprocesos solo pueden tener un semáforo a la vez.</span><span class="sxs-lookup"><span data-stu-id="f4296-632">Threads can only have one semaphore at a time.</span></span> <span data-ttu-id="f4296-633">Como alternativa, los subprocesos pueden poseer varios semáforos si los obtienen en el mismo orden.</span><span class="sxs-lookup"><span data-stu-id="f4296-633">Alternatively, threads can own multiple semaphores if they gather them in the same order.</span></span> <span data-ttu-id="f4296-634">En el ejemplo anterior, si el primer y el segundo subproceso obtienen el primero y el segundo semáforo en orden, se evita el interbloqueo.</span><span class="sxs-lookup"><span data-stu-id="f4296-634">In the previous example, if the first and second thread obtain the first and second semaphore in order, the deadly embrace is prevented.</span></span>

> [!TIP]
> <span data-ttu-id="f4296-635">*También es posible usar el tiempo de espera de suspensión asociado a la operación Get para recuperarse de un interbloqueo.*</span><span class="sxs-lookup"><span data-stu-id="f4296-635">*It is also possible to use the suspension time-out associated with the get operation to recover from a deadly embrace.*</span></span>

### <a name="priority-inversion"></a><span data-ttu-id="f4296-636">Inversión de prioridades</span><span class="sxs-lookup"><span data-stu-id="f4296-636">Priority Inversion</span></span>

<span data-ttu-id="f4296-637">Otra dificultad asociada a los semáforos de exclusión mutua es la inversión de prioridades.</span><span class="sxs-lookup"><span data-stu-id="f4296-637">Another pitfall associated with mutual exclusion semaphores is priority inversion.</span></span> <span data-ttu-id="f4296-638">Este tema se describe con más detalle en "[Problemas de prioridad de subprocesos](#thread-priority-pitfalls)".</span><span class="sxs-lookup"><span data-stu-id="f4296-638">This topic is discussed more fully in "[Thread Priority Pitfalls](#thread-priority-pitfalls)".</span></span>

<span data-ttu-id="f4296-639">El problema básico se debe a una situación en la que un subproceso de prioridad baja tiene un semáforo que necesita un subproceso de prioridad superior.</span><span class="sxs-lookup"><span data-stu-id="f4296-639">The basic problem results from a situation in which a lower-priority thread has a semaphore that a higher priority thread needs.</span></span> <span data-ttu-id="f4296-640">En sí mismo, esto es normal.</span><span class="sxs-lookup"><span data-stu-id="f4296-640">This in itself is normal.</span></span> <span data-ttu-id="f4296-641">Pero los subprocesos con prioridades entre ellos pueden provocar que la inversión de prioridades dure una cantidad de tiempo no determinista.</span><span class="sxs-lookup"><span data-stu-id="f4296-641">However, threads with priorities in between them may cause the priority inversion to last a nondeterministic amount of time.</span></span> <span data-ttu-id="f4296-642">Esto se puede controlar mediante la selección cuidadosa de las prioridades de los subprocesos, con el umbral de adelantamiento y la elevación temporal de la prioridad del subproceso que posee el recurso a la del subproceso de prioridad alta.</span><span class="sxs-lookup"><span data-stu-id="f4296-642">This can be handled through careful selection of thread priorities, using preemption-threshold, and temporarily raising the priority of the thread that owns the resource to that of the high priority thread.</span></span>

## <a name="mutexes"></a><span data-ttu-id="f4296-643">Mutexes</span><span class="sxs-lookup"><span data-stu-id="f4296-643">Mutexes</span></span>

<span data-ttu-id="f4296-644">Además de los semáforos, ThreadX también proporciona un objeto de exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="f4296-644">In addition to semaphores, ThreadX also provides a mutex object.</span></span> <span data-ttu-id="f4296-645">Una exclusión mutua es básicamente un semáforo binario, lo que significa que solo un subproceso puede poseer una exclusión mutua a la vez.</span><span class="sxs-lookup"><span data-stu-id="f4296-645">A mutex is basically a binary semaphore, which means that only one thread can own a mutex at a time.</span></span> <span data-ttu-id="f4296-646">Además, el mismo subproceso puede realizar varias veces una operación Get de exclusión mutua correcta en una exclusión mutua de propiedad, 4 294 967 295 para ser exactos.</span><span class="sxs-lookup"><span data-stu-id="f4296-646">In addition, the same thread may perform a successful mutex get operation on an owned mutex multiple times, 4,294,967,295 to be exact.</span></span> <span data-ttu-id="f4296-647">En el objeto de exclusión mutua hay dos operaciones: ***tx_mutex_get** _ y _*_tx_mutex_put_\*\*.</span><span class="sxs-lookup"><span data-stu-id="f4296-647">There are two operations on the mutex object: ***tx_mutex_get** _ and _*_tx_mutex_put_\*\*.</span></span> <span data-ttu-id="f4296-648">La operación Get obtiene una exclusión mutua que no pertenece a otro subproceso, mientras que la operación Put libera una exclusión mutua obtenida previamente.</span><span class="sxs-lookup"><span data-stu-id="f4296-648">The get operation obtains a mutex not owned by another thread, while the put operation releases a previously obtained mutex.</span></span> <span data-ttu-id="f4296-649">Para que un subproceso libere una exclusión mutua, el número de operaciones Put debe ser igual al número de operaciones Get anteriores.</span><span class="sxs-lookup"><span data-stu-id="f4296-649">For a thread to release a mutex, the number of put operations must equal the number of prior get operations.</span></span>

<span data-ttu-id="f4296-650">Cada exclusión mutua es un recurso público.</span><span class="sxs-lookup"><span data-stu-id="f4296-650">Each mutex is a public resource.</span></span> <span data-ttu-id="f4296-651">ThreadX no aplica restricciones al modo de usar las exclusiones mutuas.</span><span class="sxs-lookup"><span data-stu-id="f4296-651">ThreadX places no constraints on how mutexes are used.</span></span>

<span data-ttu-id="f4296-652">Las exclusiones mutuas de ThreadX se usan únicamente para la *exclusión mutua*.</span><span class="sxs-lookup"><span data-stu-id="f4296-652">ThreadX mutexes are used solely for *mutual exclusion*.</span></span> <span data-ttu-id="f4296-653">A diferencia de los semáforos de recuento, las exclusiones mutuas no se usan como un método para la notificación de eventos.</span><span class="sxs-lookup"><span data-stu-id="f4296-653">Unlike counting semaphores, mutexes have no use as a method for event notification.</span></span>

### <a name="mutex-mutual-exclusion"></a><span data-ttu-id="f4296-654">Exclusión mutua de exclusiones mutuas</span><span class="sxs-lookup"><span data-stu-id="f4296-654">Mutex Mutual Exclusion</span></span>

<span data-ttu-id="f4296-655">De forma similar a la descripción de la sección sobre semáforos de recuento, la exclusión mutua se corresponde al control del acceso de los subprocesos a determinadas áreas de la aplicación (también denominadas *secciones críticas* o *recursos de aplicación*).</span><span class="sxs-lookup"><span data-stu-id="f4296-655">Similar to the discussion in the counting semaphore section, mutual exclusion pertains to controlling the access of threads to certain application areas (also called *critical sections* or *application resources*).</span></span> <span data-ttu-id="f4296-656">Cuando está disponible, una exclusión mutua de ThreadX tendrá un recuento de propiedad de 0.</span><span class="sxs-lookup"><span data-stu-id="f4296-656">When available, a ThreadX mutex will have an ownership count of 0.</span></span> <span data-ttu-id="f4296-657">Una vez que un subproceso obtiene la exclusión mutua, el recuento de propiedad se incrementa una vez por cada operación Get correcta realizada en la exclusión mutua y se reduce por cada operación Put correcta.</span><span class="sxs-lookup"><span data-stu-id="f4296-657">After the mutex is obtained by a thread, the ownership count is incremented once for every successful get operation performed on the mutex and decremented for every successful put operation.</span></span>

### <a name="creating-mutexes"></a><span data-ttu-id="f4296-658">Creación de exclusiones mutuas</span><span class="sxs-lookup"><span data-stu-id="f4296-658">Creating Mutexes</span></span>

<span data-ttu-id="f4296-659">Las exclusiones mutuas de ThreadX se crean durante la inicialización o en tiempo de ejecución mediante subprocesos de aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-659">ThreadX mutexes are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="f4296-660">La condición inicial de una exclusión mutua siempre es "disponible".</span><span class="sxs-lookup"><span data-stu-id="f4296-660">The initial condition of a mutex is always "available."</span></span> <span data-ttu-id="f4296-661">También se puede crear una exclusión mutua con la *herencia de prioridades* seleccionada.</span><span class="sxs-lookup"><span data-stu-id="f4296-661">A mutex may also be created with *priority inheritance* selected.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="f4296-662">Suspensión de subprocesos</span><span class="sxs-lookup"><span data-stu-id="f4296-662">Thread Suspension</span></span>

<span data-ttu-id="f4296-663">Los subprocesos de aplicación se pueden suspender mientras se intenta realizar una operación Get en una exclusión mutua que ya pertenece a otro subproceso.</span><span class="sxs-lookup"><span data-stu-id="f4296-663">Application threads can suspend while attempting to perform a get operation on a mutex already owned by another thread.</span></span>

<span data-ttu-id="f4296-664">Una vez que el subproceso propietario realiza el mismo número de operaciones Put, se realiza la operación Get del subproceso suspendido, se le asigna la propiedad de la exclusión mutua y se reanuda el subproceso.</span><span class="sxs-lookup"><span data-stu-id="f4296-664">After the same number of put operations are performed by the owning thread, the suspended thread's get operation is performed, giving it ownership of the mutex, and the thread is resumed.</span></span> <span data-ttu-id="f4296-665">Si se suspenden varios subprocesos en la exclusión mutua, se reanudan en el mismo orden en el que se hayan suspendido (FIFO).</span><span class="sxs-lookup"><span data-stu-id="f4296-665">If multiple threads are suspended on the same mutex, they are resumed in the same order they were suspended (FIFO).</span></span>

<span data-ttu-id="f4296-666">Pero la reanudación de la prioridad se realiza de forma automática si durante la creación se ha seleccionado la herencia de prioridades de exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="f4296-666">However, priority resumption is done automatically if the mutex priority inheritance was selected during creation.</span></span> <span data-ttu-id="f4296-667">La reanudación de la prioridad también es posible si la aplicación llama a ***tx_mutex_prioritize*** antes de la llamada a Put de la exclusión mutua que levanta la suspensión del subproceso.</span><span class="sxs-lookup"><span data-stu-id="f4296-667">Priority resumption is also possible if the application calls ***tx_mutex_prioritize*** prior to the mutex put call that lifts thread suspension.</span></span> <span data-ttu-id="f4296-668">El servicio de clasificación por orden de prioridad de las exclusiones mutuas coloca el subproceso de prioridad más alta al principio de la lista de suspensiones y deja todos los demás subprocesos suspendidos en el mismo orden FIFO.</span><span class="sxs-lookup"><span data-stu-id="f4296-668">The mutex prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-mutex-performance-information"></a><span data-ttu-id="f4296-669">Información de rendimiento de exclusiones mutuas en tiempo de ejecución</span><span class="sxs-lookup"><span data-stu-id="f4296-669">Run-time Mutex Performance Information</span></span>

<span data-ttu-id="f4296-670">ThreadX proporciona información opcional sobre el rendimiento de las exclusiones mutuas en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="f4296-670">ThreadX provides optional run-time mutex performance information.</span></span> <span data-ttu-id="f4296-671">Si la biblioteca y la aplicación de ThreadX se compilan con **TX_MUTEX_ENABLE_PERFORMANCE_INFO** definido, ThreadX acumula la información siguiente.</span><span class="sxs-lookup"><span data-stu-id="f4296-671">If the ThreadX library and application is built with **TX_MUTEX_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="f4296-672">Número total del sistema general:</span><span class="sxs-lookup"><span data-stu-id="f4296-672">Total number for the overall system:</span></span>

- <span data-ttu-id="f4296-673">operaciones Put de exclusión mutua</span><span class="sxs-lookup"><span data-stu-id="f4296-673">mutex puts</span></span>

- <span data-ttu-id="f4296-674">operaciones Get de exclusión mutua</span><span class="sxs-lookup"><span data-stu-id="f4296-674">mutex gets</span></span>

- <span data-ttu-id="f4296-675">suspensiones de operaciones Get de exclusión mutua</span><span class="sxs-lookup"><span data-stu-id="f4296-675">mutex get suspensions</span></span>

- <span data-ttu-id="f4296-676">tiempos de espera de operaciones Get de exclusión mutua</span><span class="sxs-lookup"><span data-stu-id="f4296-676">mutex get timeouts</span></span>

- <span data-ttu-id="f4296-677">inversiones de prioridad de exclusión mutua</span><span class="sxs-lookup"><span data-stu-id="f4296-677">mutex priority inversions</span></span>

- <span data-ttu-id="f4296-678">herencia de prioridades de exclusión mutua</span><span class="sxs-lookup"><span data-stu-id="f4296-678">mutex priority inheritances</span></span>

<span data-ttu-id="f4296-679">Número total de cada exclusión mutua:</span><span class="sxs-lookup"><span data-stu-id="f4296-679">Total number for each mutex:</span></span>

  - <span data-ttu-id="f4296-680">operaciones Put de exclusión mutua</span><span class="sxs-lookup"><span data-stu-id="f4296-680">mutex puts</span></span>

  - <span data-ttu-id="f4296-681">operaciones Get de exclusión mutua</span><span class="sxs-lookup"><span data-stu-id="f4296-681">mutex gets</span></span>

  - <span data-ttu-id="f4296-682">suspensiones de operaciones Get de exclusión mutua</span><span class="sxs-lookup"><span data-stu-id="f4296-682">mutex get suspensions</span></span>

  - <span data-ttu-id="f4296-683">tiempos de espera de operaciones Get de exclusión mutua</span><span class="sxs-lookup"><span data-stu-id="f4296-683">mutex get timeouts</span></span>

  - <span data-ttu-id="f4296-684">inversiones de prioridad de exclusión mutua</span><span class="sxs-lookup"><span data-stu-id="f4296-684">mutex priority inversions</span></span>

  - <span data-ttu-id="f4296-685">herencia de prioridades de exclusión mutua</span><span class="sxs-lookup"><span data-stu-id="f4296-685">mutex priority inheritances</span></span>

<span data-ttu-id="f4296-686">Esta información está disponible en tiempo de ejecución por medio de los servicios ***tx_mutex_performance_info_get** _ y _*_tx_mutex_performance_system_info_get_\*\*.</span><span class="sxs-lookup"><span data-stu-id="f4296-686">This information is available at run-time through the services ***tx_mutex_performance_info_get** _ and _*_tx_mutex_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="f4296-687">La información de rendimiento de las exclusiones mutuas resulta útil para determinar si la aplicación se comporta de manera correcta.</span><span class="sxs-lookup"><span data-stu-id="f4296-687">Mutex performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="f4296-688">También es útil para optimizar la aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-688">It is also useful in optimizing the application.</span></span> <span data-ttu-id="f4296-689">Por ejemplo, un número relativamente alto de "tiempos de espera de operaciones Get de exclusiones mutuas" podría sugerir que otros subprocesos conservan los recursos durante demasiado tiempo.</span><span class="sxs-lookup"><span data-stu-id="f4296-689">For example, a relatively high number of "mutex get timeouts" might suggest that other threads are holding resources too long.</span></span>

### <a name="mutex-control-block-tx_mutex"></a><span data-ttu-id="f4296-690">TX_MUTEX: bloque de control de exclusión mutua</span><span class="sxs-lookup"><span data-stu-id="f4296-690">Mutex Control Block TX_MUTEX</span></span>

<span data-ttu-id="f4296-691">Las características de cada exclusión mutua se encuentran en su bloque de control.</span><span class="sxs-lookup"><span data-stu-id="f4296-691">The characteristics of each mutex are found in its control block.</span></span> <span data-ttu-id="f4296-692">Contiene información como el recuento de propiedad de la exclusión mutua actual junto con el puntero del subproceso propietario de la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="f4296-692">It contains information such as the current mutex ownership count along with the pointer of the thread that owns the mutex.</span></span> <span data-ttu-id="f4296-693">Esta estructura se define en el archivo ***tx_api.h***.</span><span class="sxs-lookup"><span data-stu-id="f4296-693">This structure is defined in the ***tx_api.h*** file.</span></span> <span data-ttu-id="f4296-694">Los bloques de control de exclusión mutua se pueden ubicar en cualquier parte de la memoria, pero es más común convertir el bloque de control en una estructura global definiéndolo fuera del ámbito de cualquier función.</span><span class="sxs-lookup"><span data-stu-id="f4296-694">Mutex control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="deadly-embrace"></a><span data-ttu-id="f4296-695">Adopción letal</span><span class="sxs-lookup"><span data-stu-id="f4296-695">Deadly Embrace</span></span>

<span data-ttu-id="f4296-696">Uno de los riesgos más interesantes y peligrosos asociados a la propiedad de la exclusión mutua es el de la *adopción letal*.</span><span class="sxs-lookup"><span data-stu-id="f4296-696">One of the most interesting and dangerous pitfalls associated with mutex ownership is the *deadly embrace*.</span></span> <span data-ttu-id="f4296-697">Una adopción letal, o *interbloqueo*, es una condición en la que dos o más subprocesos se suspenden indefinidamente mientras intentan obtener una exclusión mutua que ya pertenece a los otros subprocesos.</span><span class="sxs-lookup"><span data-stu-id="f4296-697">A deadly embrace, or *deadlock*, is a condition where two or more threads are suspended indefinitely while attempting to get a mutex already owned by the other threads.</span></span> <span data-ttu-id="f4296-698">La descripción de los *interbloqueos* y sus correcciones también es totalmente válida para el objeto de exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="f4296-698">The discussion of *deadly embrace* and its remedies are completely valid for the mutex object as well.</span></span>

### <a name="priority-inversion"></a><span data-ttu-id="f4296-699">Inversión de prioridades</span><span class="sxs-lookup"><span data-stu-id="f4296-699">Priority Inversion</span></span>

<span data-ttu-id="f4296-700">Como se ha mencionado antes, un problema importante asociado a la exclusión mutua es el de la inversión de prioridades.</span><span class="sxs-lookup"><span data-stu-id="f4296-700">As mentioned previously, a major pitfall associated with mutual exclusion is priority inversion.</span></span> <span data-ttu-id="f4296-701">Este tema se describe con más detalle en "[Problemas de prioridad de subprocesos](#thread-priority-pitfalls)".</span><span class="sxs-lookup"><span data-stu-id="f4296-701">This topic is discussed more fully in "[Thread Priority Pitfalls](#thread-priority-pitfalls)".</span></span>

<span data-ttu-id="f4296-702">El problema básico se debe a una situación en la que un subproceso de prioridad baja tiene un semáforo que necesita un subproceso de prioridad superior.</span><span class="sxs-lookup"><span data-stu-id="f4296-702">The basic problem results from a situation in which a lower priority thread has a semaphore that a higher priority thread needs.</span></span> <span data-ttu-id="f4296-703">En sí mismo, esto es normal.</span><span class="sxs-lookup"><span data-stu-id="f4296-703">This in itself is normal.</span></span> <span data-ttu-id="f4296-704">Pero los subprocesos con prioridades entre ellos pueden provocar que la inversión de prioridades dure una cantidad de tiempo no determinista.</span><span class="sxs-lookup"><span data-stu-id="f4296-704">However, threads with priorities in between them may cause the priority inversion to last a nondeterministic amount of time.</span></span> <span data-ttu-id="f4296-705">A diferencia de los semáforos descritos anteriormente, el objeto de exclusión mutua de ThreadX tiene una *herencia de prioridades* opcional.</span><span class="sxs-lookup"><span data-stu-id="f4296-705">Unlike semaphores discussed previously, the ThreadX mutex object has optional *priority inheritance*.</span></span> <span data-ttu-id="f4296-706">La idea básica detrás de la herencia de prioridades es que, en un subproceso de prioridad inferior, su prioridad se aumenta temporalmente hasta que coincide con la de un subproceso de prioridad alta que quiere la misma exclusión mutua propiedad del subproceso de prioridad inferior.</span><span class="sxs-lookup"><span data-stu-id="f4296-706">The basic idea behind priority inheritance is that a lower priority thread has its priority raised temporarily to the priority of a high priority thread that wants the same mutex owned by the lower priority thread.</span></span> <span data-ttu-id="f4296-707">Cuando el subproceso de prioridad inferior libera la exclusión mutua, se restaura su prioridad original y la propiedad de la exclusión mutua se asigna al subproceso de prioridad más alta.</span><span class="sxs-lookup"><span data-stu-id="f4296-707">When the lower priority thread releases the mutex, its original priority is then restored and the higher priority thread is given ownership of the mutex.</span></span> <span data-ttu-id="f4296-708">Esta característica elimina la inversión de prioridades no determinista limitando la cantidad de inversión en el momento en que el subproceso de prioridad inferior mantiene la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="f4296-708">This feature eliminates nondeterministic priority inversion by bounding the amount of inversion to the time the lower priority thread holds the mutex.</span></span> <span data-ttu-id="f4296-709">Por supuesto, las técnicas descritas anteriormente en este capítulo para controlar la inversión de prioridades no determinista también son válidas con las exclusiones mutuas.</span><span class="sxs-lookup"><span data-stu-id="f4296-709">Of course, the techniques discussed earlier in this chapter to handle nondeterministic priority inversion are also valid with mutexes as well.</span></span>

## <a name="event-flags"></a><span data-ttu-id="f4296-710">Marcas de eventos</span><span class="sxs-lookup"><span data-stu-id="f4296-710">Event Flags</span></span>

<span data-ttu-id="f4296-711">Las marcas de eventos proporcionan una herramienta eficaz para la sincronización de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="f4296-711">Event flags provide a powerful tool for thread synchronization.</span></span> <span data-ttu-id="f4296-712">Cada marca de evento se representa con un solo bit.</span><span class="sxs-lookup"><span data-stu-id="f4296-712">Each event flag is represented by a single bit.</span></span> <span data-ttu-id="f4296-713">Las marcas de eventos se organizan en grupos de 32.</span><span class="sxs-lookup"><span data-stu-id="f4296-713">Event flags are arranged in groups of 32.</span></span> <span data-ttu-id="f4296-714">Los subprocesos pueden operar en las 32 marcas de eventos de un grupo al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="f4296-714">Threads can operate on all 32 event flags in a group at the same time.</span></span> <span data-ttu-id="f4296-715">Los eventos se establecen mediante ***tx_event_flags_set** _ y se recuperan con _*_tx_event_flags_get_\*\*.</span><span class="sxs-lookup"><span data-stu-id="f4296-715">Events are set by ***tx_event_flags_set** _ and are retrieved by _*_tx_event_flags_get_\*\*.</span></span>

<span data-ttu-id="f4296-716">Para establecer las marcas de eventos se realiza una operación AND/OR lógica entre las marcas de evento actuales y las nuevas.</span><span class="sxs-lookup"><span data-stu-id="f4296-716">Setting event flags is done with a logical AND/OR operation between the current event flags and the new event flags.</span></span> <span data-ttu-id="f4296-717">El tipo de operación lógica (OR o AND) se especifica en la llamada a ***tx_event_flags_set***.</span><span class="sxs-lookup"><span data-stu-id="f4296-717">The type of logical operation (either an AND or OR) is specified in the ***tx_event_flags_set*** call.</span></span>

<span data-ttu-id="f4296-718">Existen opciones lógicas similares para la recuperación de marcas de eventos.</span><span class="sxs-lookup"><span data-stu-id="f4296-718">There are similar logical options for retrieval of event flags.</span></span> <span data-ttu-id="f4296-719">Una solicitud GET puede especificar que todas las marcas de evento especificadas sean obligatorias (una operación AND lógica).</span><span class="sxs-lookup"><span data-stu-id="f4296-719">A get request can specify that all specified event flags are required (a logical AND).</span></span>

<span data-ttu-id="f4296-720">Como alternativa, una solicitud GET puede especificar que cualquiera de las marcas de evento especificadas satisfará la solicitud (una operación OR lógica).</span><span class="sxs-lookup"><span data-stu-id="f4296-720">Alternatively, a get request can specify that any of the specified event flags will satisfy the request (a logical OR).</span></span> <span data-ttu-id="f4296-721">El tipo de operación lógica asociada a la recuperación de marcas de eventos se especifica en la llamada a ***tx_event_flags_get***.</span><span class="sxs-lookup"><span data-stu-id="f4296-721">The type of logical operation associated with event flags retrieval is specified in the ***tx_event_flags_get*** call.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f4296-722">*Las marcas de evento que satisfacen una solicitud GET se consumen, es decir, se establecen en cero si* *la solicitud especifica **TX_OR_CLEAR** *o* **TX_AND_CLEAR*** .</span><span class="sxs-lookup"><span data-stu-id="f4296-722">*Event flags that satisfy a get request are consumed, i.e., set to zero, if* **TX_OR_CLEAR** *or* **TX_AND_CLEAR** *are specified by the request.*</span></span>

<span data-ttu-id="f4296-723">Cada grupo de marcas de evento es un recurso público.</span><span class="sxs-lookup"><span data-stu-id="f4296-723">Each event flags group is a public resource.</span></span> <span data-ttu-id="f4296-724">ThreadX no aplica restricciones al modo de usar los grupos de marcas de evento.</span><span class="sxs-lookup"><span data-stu-id="f4296-724">ThreadX places no constraints on how event flags groups are used.</span></span>

### <a name="creating-event-flags-groups"></a><span data-ttu-id="f4296-725">Creación de grupos de marcas de eventos</span><span class="sxs-lookup"><span data-stu-id="f4296-725">Creating Event Flags Groups</span></span>

<span data-ttu-id="f4296-726">Los grupos de marcas de eventos se crean durante la inicialización o en tiempo de ejecución mediante subprocesos de aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-726">Event flags groups are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="f4296-727">En el momento de su creación, todas las marcas de eventos del grupo se establecen en cero.</span><span class="sxs-lookup"><span data-stu-id="f4296-727">At the time of their creation, all event flags in the group are set to zero.</span></span> <span data-ttu-id="f4296-728">No hay ningún límite en cuanto al número de grupos de marcas de eventos de una aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-728">There is no limit on the number of event flags groups in an application.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="f4296-729">Suspensión de subprocesos</span><span class="sxs-lookup"><span data-stu-id="f4296-729">Thread Suspension</span></span>

<span data-ttu-id="f4296-730">Los subprocesos de aplicación se pueden suspender mientras se intenta obtener una combinación lógica de marcas de eventos de un grupo.</span><span class="sxs-lookup"><span data-stu-id="f4296-730">Application threads can suspend while attempting to get any logical combination of event flags from a group.</span></span> <span data-ttu-id="f4296-731">Después de establecer una marca de evento, se revisan las solicitudes GET de todos los subprocesos suspendidos.</span><span class="sxs-lookup"><span data-stu-id="f4296-731">After an event flag is set, the get requests of all suspended threads are reviewed.</span></span> <span data-ttu-id="f4296-732">Se reanudan todos los subprocesos que ahora tienen las marcas de evento necesarias.</span><span class="sxs-lookup"><span data-stu-id="f4296-732">All the threads that now have the required event flags are resumed.</span></span>

> [!NOTE]
> <span data-ttu-id="f4296-733">*Todos los subprocesos suspendidos de un grupo de marcas de evento se revisan cuando se establecen sus marcas de evento. Esto, por supuesto, presenta una sobrecarga adicional. Por tanto, se recomienda limitar el número de subprocesos que usan el mismo grupo de marcas de evento a un número razonable.*</span><span class="sxs-lookup"><span data-stu-id="f4296-733">*All suspended threads on an event flag group are reviewed when its event flags are set. This, of course, introduces additional overhead. Therefore, it is good practice to limit the number of threads using the same event flag group to a reasonable number.*</span></span>

### <a name="event-flags-set-notification"></a><span data-ttu-id="f4296-734">Notificación de establecimiento de marcas de evento</span><span class="sxs-lookup"><span data-stu-id="f4296-734">Event Flags Set Notification</span></span>

<span data-ttu-id="f4296-735">Es posible que algunas aplicaciones se beneficien de recibir una notificación cada vez que se establezca una marca de eventos.</span><span class="sxs-lookup"><span data-stu-id="f4296-735">Some applications may find it advantageous to be notified whenever an event flag is set.</span></span> <span data-ttu-id="f4296-736">ThreadX proporciona esta función por medio del servicio ***tx_event_flags_set_notify***.</span><span class="sxs-lookup"><span data-stu-id="f4296-736">ThreadX provides this ability through the ***tx_event_flags_set_notify*** service.</span></span> <span data-ttu-id="f4296-737">Este servicio registra la función de notificación de aplicación proporcionada con el grupo de marcas de evento especificado.</span><span class="sxs-lookup"><span data-stu-id="f4296-737">This service registers the supplied application notification function with the specified event flags group.</span></span> <span data-ttu-id="f4296-738">Después, ThreadX invocará esta función de notificación de aplicación cada vez que se establece una marca de evento en el grupo.</span><span class="sxs-lookup"><span data-stu-id="f4296-738">ThreadX will subsequently invoke this application notification function whenever an event flag in the group is set.</span></span> <span data-ttu-id="f4296-739">El procesamiento exacto dentro de la función de notificación de aplicación viene determinado por la aplicación, pero normalmente consiste en reanudar el subproceso adecuado para procesar la nueva marca de evento.</span><span class="sxs-lookup"><span data-stu-id="f4296-739">The exact processing within the application notification function is determined by the application, but it typically consists of resuming the appropriate thread for processing the new event flag.</span></span>

### <a name="event-flags-event-chainingtrade"></a><span data-ttu-id="f4296-740">Encadenamiento de eventos de marcas de evento&trade;</span><span class="sxs-lookup"><span data-stu-id="f4296-740">Event Flags Event chaining&trade;</span></span>

<span data-ttu-id="f4296-741">Las funciones de notificación de ThreadX se pueden usar para "encadenar" varios eventos de sincronización.</span><span class="sxs-lookup"><span data-stu-id="f4296-741">The notification capabilities in ThreadX can be used to "chain" various synchronization events together.</span></span> <span data-ttu-id="f4296-742">Esto suele ser útil cuando un único subproceso debe procesar varios eventos de sincronización.</span><span class="sxs-lookup"><span data-stu-id="f4296-742">This is typically useful when a single thread must process multiple synchronization events.</span></span>

<span data-ttu-id="f4296-743">Por ejemplo, en lugar de suspender subprocesos independientes para un mensaje de cola, marcas de eventos y un semáforo, la aplicación puede registrar una rutina de notificación para cada objeto.</span><span class="sxs-lookup"><span data-stu-id="f4296-743">For example, instead of having separate threads suspend for a queue message, event flags, and a semaphore, the application can register a notification routine for each object.</span></span> <span data-ttu-id="f4296-744">Cuando se invoca, la rutina de notificación de aplicación puede reanudar un solo subproceso, que puede interrogar cada objeto para buscar y procesar el nuevo evento.</span><span class="sxs-lookup"><span data-stu-id="f4296-744">When invoked, the application notification routine can then resume a single thread, which can interrogate each object to find and process the new event.</span></span>

<span data-ttu-id="f4296-745">En general, el *encadenamiento de eventos* genera menos subprocesos, menos sobrecarga y requisitos de RAM más pequeños.</span><span class="sxs-lookup"><span data-stu-id="f4296-745">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="f4296-746">También proporciona un mecanismo muy flexible para controlar los requisitos de sincronización de sistemas más complejos.</span><span class="sxs-lookup"><span data-stu-id="f4296-746">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span>

### <a name="run-time-event-flags-performance-information"></a><span data-ttu-id="f4296-747">Información de rendimiento de marcas de eventos en tiempo de ejecución</span><span class="sxs-lookup"><span data-stu-id="f4296-747">Run-time Event Flags Performance Information</span></span>

<span data-ttu-id="f4296-748">ThreadX proporciona información opcional sobre el rendimiento de las marcas de evento en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="f4296-748">ThreadX provides optional run-time event flags performance information.</span></span> <span data-ttu-id="f4296-749">Si la biblioteca y la aplicación de ThreadX se compilan con **TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO** definido, ThreadX acumula la información siguiente.</span><span class="sxs-lookup"><span data-stu-id="f4296-749">If the ThreadX library and application is built with **TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="f4296-750">Número total del sistema general:</span><span class="sxs-lookup"><span data-stu-id="f4296-750">Total number for the overall system:</span></span>

  - <span data-ttu-id="f4296-751">operaciones SET de marcas de evento</span><span class="sxs-lookup"><span data-stu-id="f4296-751">event flags sets</span></span>

  - <span data-ttu-id="f4296-752">operaciones GET de marcas de evento</span><span class="sxs-lookup"><span data-stu-id="f4296-752">event flags gets</span></span>

  - <span data-ttu-id="f4296-753">suspensiones GET de marcas de evento</span><span class="sxs-lookup"><span data-stu-id="f4296-753">event flags get suspensions</span></span>

  - <span data-ttu-id="f4296-754">tiempo de espera GET de marcas de evento</span><span class="sxs-lookup"><span data-stu-id="f4296-754">event flags get timeouts</span></span>

<span data-ttu-id="f4296-755">Número total para cada grupo de marcas de evento:</span><span class="sxs-lookup"><span data-stu-id="f4296-755">Total number for each event flags group:</span></span>

  - <span data-ttu-id="f4296-756">operaciones SET de marcas de evento</span><span class="sxs-lookup"><span data-stu-id="f4296-756">event flags sets</span></span>

  - <span data-ttu-id="f4296-757">operaciones GET de marcas de evento</span><span class="sxs-lookup"><span data-stu-id="f4296-757">event flags gets</span></span>

  - <span data-ttu-id="f4296-758">suspensiones GET de marcas de evento</span><span class="sxs-lookup"><span data-stu-id="f4296-758">event flags get suspensions</span></span>

  - <span data-ttu-id="f4296-759">tiempo de espera GET de marcas de evento</span><span class="sxs-lookup"><span data-stu-id="f4296-759">event flags get timeouts</span></span>

<span data-ttu-id="f4296-760">Esta información está disponible en tiempo de ejecución por medio de los servicios ***tx_event_flags_performance_info_get** _ y _*_tx_event_flags_performance_system_info_get_\*_.</span><span class="sxs-lookup"><span data-stu-id="f4296-760">This information is available at run-time through the services ***tx_event_flags_performance_info_get** _ and _*_tx_event_flags_performance_system_info_get_\*_.</span></span> <span data-ttu-id="f4296-761">La información de rendimiento de las marcas de evento resulta útil para determinar si la aplicación se comporta de manera correcta.</span><span class="sxs-lookup"><span data-stu-id="f4296-761">The performance information of event flags is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="f4296-762">También es útil para optimizar la aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-762">It is also useful in optimizing the application.</span></span> <span data-ttu-id="f4296-763">Por ejemplo, un número relativamente alto de tiempos de espera en el servicio _ *_tx_event_flags_get_*\* podría sugerir que el tiempo de espera de la suspensión de las marcas de evento es demasiado corto.</span><span class="sxs-lookup"><span data-stu-id="f4296-763">For example, a relatively high number of timeouts on the _ *_tx_event_flags_get_*\* service might suggest that the event flags suspension timeout is too short.</span></span>

### <a name="event-flags-group-control-block-tx_event_flags_group"></a><span data-ttu-id="f4296-764">TX_EVENT_FLAGS_GROUP: bloque de control de grupos de marcas de evento</span><span class="sxs-lookup"><span data-stu-id="f4296-764">Event Flags Group Control Block TX_EVENT_FLAGS_GROUP</span></span>

<span data-ttu-id="f4296-765">Las características de cada grupo de marcas de eventos se encuentran en el bloque de control.</span><span class="sxs-lookup"><span data-stu-id="f4296-765">The characteristics of each event flags group are found in its control block.</span></span> <span data-ttu-id="f4296-766">Contiene información como la configuración de las marcas de eventos actuales y el número de subprocesos suspendidos para los eventos.</span><span class="sxs-lookup"><span data-stu-id="f4296-766">It contains information such as the current event flags settings and the number of threads suspended for events.</span></span> <span data-ttu-id="f4296-767">Esta estructura se define en el archivo ***tx_api.h***.</span><span class="sxs-lookup"><span data-stu-id="f4296-767">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="f4296-768">Los bloques de control de grupo de eventos se pueden ubicar en cualquier parte de la memoria, pero es más común convertir el bloque de control en una estructura global definiéndolo fuera del ámbito de cualquier función.</span><span class="sxs-lookup"><span data-stu-id="f4296-768">Event group control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="memory-block-pools"></a><span data-ttu-id="f4296-769">Grupos de bloque de memoria</span><span class="sxs-lookup"><span data-stu-id="f4296-769">Memory Block Pools</span></span>

<span data-ttu-id="f4296-770">En las aplicaciones en tiempo real, la asignación de memoria de una manera rápida y determinista siempre es un desafío.</span><span class="sxs-lookup"><span data-stu-id="f4296-770">Allocating memory in a fast and deterministic manner is always a challenge in real-time applications.</span></span> <span data-ttu-id="f4296-771">Con esto en mente, ThreadX proporciona la capacidad de crear y administrar varios grupos de bloques de memoria de tamaño fijo.</span><span class="sxs-lookup"><span data-stu-id="f4296-771">With this in mind, ThreadX provides the ability to create and manage multiple pools of fixed-size memory blocks.</span></span>

<span data-ttu-id="f4296-772">Como los grupos de bloques de memoria se componen de bloques de tamaño fijo, nunca hay problemas de fragmentación.</span><span class="sxs-lookup"><span data-stu-id="f4296-772">Because memory block pools consist of fixed-size blocks, there are never any fragmentation problems.</span></span> <span data-ttu-id="f4296-773">Por supuesto, la fragmentación provoca un comportamiento que es inherentemente no determinista.</span><span class="sxs-lookup"><span data-stu-id="f4296-773">Of course, fragmentation causes behavior that is inherently nondeterministic.</span></span> <span data-ttu-id="f4296-774">Además, el tiempo necesario para asignar y liberar un bloque de memoria de tamaño fijo es comparable al de la manipulación de listas vinculadas simples.</span><span class="sxs-lookup"><span data-stu-id="f4296-774">In addition, the time required to allocate and free a fixed-size memory block is comparable to that of simple linked-list manipulation.</span></span> <span data-ttu-id="f4296-775">Además, la asignación y desasignación de bloques de memoria se realiza al inicio de la lista disponible.</span><span class="sxs-lookup"><span data-stu-id="f4296-775">Furthermore, memory block allocation and de-allocation is done at the head of the available list.</span></span> <span data-ttu-id="f4296-776">Esto proporciona el procesamiento de la lista vinculada más rápido posible y puede ayudar a mantener el bloque de memoria real en la caché.</span><span class="sxs-lookup"><span data-stu-id="f4296-776">This provides the fastest possible linked list processing and might help keep the actual memory block in cache.</span></span>

<span data-ttu-id="f4296-777">La falta de flexibilidad es el principal inconveniente de los grupos de memoria de tamaño fijo.</span><span class="sxs-lookup"><span data-stu-id="f4296-777">Lack of flexibility is the main drawback of fixed-size memory pools.</span></span> <span data-ttu-id="f4296-778">El tamaño de bloque de un grupo debe ser lo suficientemente grande como para administrar los peores requisitos de memoria de sus usuarios.</span><span class="sxs-lookup"><span data-stu-id="f4296-778">The block size of a pool must be large enough to handle the worst case memory requirements of its users.</span></span> <span data-ttu-id="f4296-779">Por supuesto, es posible que se desperdicie memoria si se realizan muchas solicitudes de memoria de tamaño diferente en el mismo grupo.</span><span class="sxs-lookup"><span data-stu-id="f4296-779">Of course, memory may be wasted if many different size memory requests are made to the same pool.</span></span> <span data-ttu-id="f4296-780">Una posible solución consiste en crear varios grupos de bloques de memoria diferentes que contengan bloques de memoria de diferente tamaño.</span><span class="sxs-lookup"><span data-stu-id="f4296-780">A possible solution is to make several different memory block pools that contain different sized memory blocks.</span></span>

<span data-ttu-id="f4296-781">Cada grupo de bloques de memoria es un recurso público.</span><span class="sxs-lookup"><span data-stu-id="f4296-781">Each memory block pool is a public resource.</span></span> <span data-ttu-id="f4296-782">ThreadX no aplica restricciones al modo de usar los grupos.</span><span class="sxs-lookup"><span data-stu-id="f4296-782">ThreadX places no constraints on how pools are used.</span></span>

### <a name="creating-memory-block-pools"></a><span data-ttu-id="f4296-783">Creación de grupos de bloques de memoria</span><span class="sxs-lookup"><span data-stu-id="f4296-783">Creating Memory Block Pools</span></span>

<span data-ttu-id="f4296-784">Los grupos de bloques de memoria se crean durante la inicialización o en tiempo de ejecución mediante subprocesos de aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-784">Memory block pools are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="f4296-785">No hay ningún límite en cuanto al número de grupos de bloques de memoria de una aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-785">There is no limit on the number of memory block pools in an application.</span></span>

### <a name="memory-block-size"></a><span data-ttu-id="f4296-786">Tamaño del bloque de memoria</span><span class="sxs-lookup"><span data-stu-id="f4296-786">Memory Block Size</span></span>

<span data-ttu-id="f4296-787">Como se ha mencionado antes, los grupos de bloques de memoria contienen una serie de bloques de tamaño fijo.</span><span class="sxs-lookup"><span data-stu-id="f4296-787">As mentioned earlier, memory block pools contain a number of fixed-size blocks.</span></span> <span data-ttu-id="f4296-788">El tamaño del bloque, en bytes, se especifica durante la creación del grupo.</span><span class="sxs-lookup"><span data-stu-id="f4296-788">The block size, in bytes, is specified during creation of the pool.</span></span>

> [!NOTE]
> <span data-ttu-id="f4296-789">*ThreadX agrega una pequeña cantidad de sobrecarga (del tamaño de un puntero de C) a cada bloque de memoria del grupo. Además, es posible que ThreadX tenga que rellenar el tamaño de bloque para mantener el principio de cada bloque de memoria en la alineación adecuada.*</span><span class="sxs-lookup"><span data-stu-id="f4296-789">*ThreadX adds a small amount of overhead—the size of a C pointer—to each memory block in the pool. In addition, ThreadX might have to pad the block size to keep the beginning of each memory block on proper alignment.*</span></span>

### <a name="pool-capacity"></a><span data-ttu-id="f4296-790">Capacidad del grupo</span><span class="sxs-lookup"><span data-stu-id="f4296-790">Pool Capacity</span></span>

<span data-ttu-id="f4296-791">El número de bloques de memoria de un grupo es una función del tamaño de bloque y el número total de bytes en el área de memoria proporcionado durante la creación.</span><span class="sxs-lookup"><span data-stu-id="f4296-791">The number of memory blocks in a pool is a function of the block size and the total number of bytes in the memory area supplied during creation.</span></span> <span data-ttu-id="f4296-792">Para calcular la capacidad de un grupo, se divide el tamaño de bloque (incluido el relleno y los bytes de sobrecarga del puntero) entre el número total de bytes en el área de memoria proporcionada.</span><span class="sxs-lookup"><span data-stu-id="f4296-792">The capacity of a pool is calculated by dividing the block size (including padding and the pointer overhead bytes) into the total number of bytes in the supplied memory area.</span></span>

### <a name="pools-memory-area"></a><span data-ttu-id="f4296-793">Área de memoria del grupo</span><span class="sxs-lookup"><span data-stu-id="f4296-793">Pool's Memory Area</span></span>

<span data-ttu-id="f4296-794">Como se ha mencionado antes, el área de memoria del grupo de bloques se especifica durante la creación.</span><span class="sxs-lookup"><span data-stu-id="f4296-794">As mentioned before, the memory area for the block pool is specified during creation.</span></span> <span data-ttu-id="f4296-795">Como sucede con otras áreas de memoria de ThreadX, se puede ubicar en cualquier parte del espacio de direcciones del destino.</span><span class="sxs-lookup"><span data-stu-id="f4296-795">Like other memory areas in ThreadX, it can be located anywhere in the target's address space.</span></span>

<span data-ttu-id="f4296-796">Esta es una característica importante debido a la gran flexibilidad que proporciona.</span><span class="sxs-lookup"><span data-stu-id="f4296-796">This is an important feature because of the considerable flexibility it provides.</span></span> <span data-ttu-id="f4296-797">Por ejemplo, imagine que un producto de comunicación tiene un área de memoria de alta velocidad para E/S.</span><span class="sxs-lookup"><span data-stu-id="f4296-797">For example, suppose that a communication product has a highspeed memory area for I/O.</span></span> <span data-ttu-id="f4296-798">Esta área de memoria se administra fácilmente si se convierte en un grupo de bloques de memoria de ThreadX.</span><span class="sxs-lookup"><span data-stu-id="f4296-798">This memory area is easily managed by making it into a ThreadX memory block pool.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="f4296-799">Suspensión de subprocesos</span><span class="sxs-lookup"><span data-stu-id="f4296-799">Thread Suspension</span></span>

<span data-ttu-id="f4296-800">Los subprocesos de aplicación se pueden suspender mientras se espera un bloque de memoria de un grupo vacío.</span><span class="sxs-lookup"><span data-stu-id="f4296-800">Application threads can suspend while waiting for a memory block from an empty pool.</span></span> <span data-ttu-id="f4296-801">Cuando se devuelve un bloque al grupo, el subproceso suspendido lo recibe y se reanuda.</span><span class="sxs-lookup"><span data-stu-id="f4296-801">When a block is returned to the pool, the suspended thread is given this block and the thread is resumed.</span></span>

<span data-ttu-id="f4296-802">Si se suspenden varios subprocesos en el mismo grupo de bloques de memoria, se reanudan en el orden en el que se hayan suspendido (FIFO).</span><span class="sxs-lookup"><span data-stu-id="f4296-802">If multiple threads are suspended on the same memory block pool, they are resumed in the order they were suspended (FIFO).</span></span>

<span data-ttu-id="f4296-803">Pero la reanudación de la prioridad también es posible si la aplicación llama a ***tx_block_pool_prioritize*** antes de la llamada de liberación del bloque que levanta la suspensión del subproceso.</span><span class="sxs-lookup"><span data-stu-id="f4296-803">However, priority resumption is also possible if the application calls ***tx_block_pool_prioritize*** prior to the block release call that lifts thread suspension.</span></span> <span data-ttu-id="f4296-804">El servicio de clasificación por orden de prioridad de los grupos de bloques coloca el subproceso de prioridad más alta al principio de la lista de suspensiones y deja todos los demás subprocesos suspendidos en el mismo orden FIFO.</span><span class="sxs-lookup"><span data-stu-id="f4296-804">The block pool prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-block-pool-performance-information"></a><span data-ttu-id="f4296-805">Información de rendimiento de un grupo de bloques en tiempo de ejecución</span><span class="sxs-lookup"><span data-stu-id="f4296-805">Run-time Block Pool Performance Information</span></span>

<span data-ttu-id="f4296-806">ThreadX proporciona información opcional sobre el rendimiento de los grupos de bloques en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="f4296-806">ThreadX provides optional run-time block pool performance information.</span></span> <span data-ttu-id="f4296-807">Si la biblioteca y la aplicación de ThreadX se compilan con **TX_BLOCK_POOL_ENABLE_PERFORMANCE_INFO** definido, ThreadX acumula la información siguiente.</span><span class="sxs-lookup"><span data-stu-id="f4296-807">If the ThreadX library and application is built with **TX_BLOCK_POOL_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="f4296-808">Número total del sistema general:</span><span class="sxs-lookup"><span data-stu-id="f4296-808">Total number for the overall system:</span></span>

  - <span data-ttu-id="f4296-809">bloques asignados</span><span class="sxs-lookup"><span data-stu-id="f4296-809">blocks allocated</span></span>

  - <span data-ttu-id="f4296-810">bloques liberados</span><span class="sxs-lookup"><span data-stu-id="f4296-810">blocks released</span></span>

  - <span data-ttu-id="f4296-811">suspensiones de asignación</span><span class="sxs-lookup"><span data-stu-id="f4296-811">allocation suspensions</span></span>

  - <span data-ttu-id="f4296-812">tiempos de espera de asignación</span><span class="sxs-lookup"><span data-stu-id="f4296-812">allocation timeouts</span></span>

<span data-ttu-id="f4296-813">Número total de cada grupo de bloques:</span><span class="sxs-lookup"><span data-stu-id="f4296-813">Total number for each block pool:</span></span>

  - <span data-ttu-id="f4296-814">bloques asignados</span><span class="sxs-lookup"><span data-stu-id="f4296-814">blocks allocated</span></span>

  - <span data-ttu-id="f4296-815">bloques liberados</span><span class="sxs-lookup"><span data-stu-id="f4296-815">blocks released</span></span>

  - <span data-ttu-id="f4296-816">suspensiones de asignación</span><span class="sxs-lookup"><span data-stu-id="f4296-816">allocation suspensions</span></span>

  - <span data-ttu-id="f4296-817">tiempos de espera de asignación</span><span class="sxs-lookup"><span data-stu-id="f4296-817">allocation timeouts</span></span>

<span data-ttu-id="f4296-818">Esta información está disponible en tiempo de ejecución por medio de los servicios ***tx_block_pool_performance_info_get** _ y _*_tx_block_pool_performance_system_info_get_\*\*.</span><span class="sxs-lookup"><span data-stu-id="f4296-818">This information is available at run-time through the services ***tx_block_pool_performance_info_get** _ and _*_tx_block_pool_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="f4296-819">La información de rendimiento de los grupos de bloques resulta útil para determinar si la aplicación se comporta de manera correcta.</span><span class="sxs-lookup"><span data-stu-id="f4296-819">Block pool performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="f4296-820">También es útil para optimizar la aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-820">It is also useful in optimizing the application.</span></span> <span data-ttu-id="f4296-821">Por ejemplo, un número relativamente alto de "suspensiones de asignación" podría sugerir que el grupo de bloques es demasiado pequeño.</span><span class="sxs-lookup"><span data-stu-id="f4296-821">For example, a relatively high number of "allocation suspensions" might suggest that the block pool is too small.</span></span>

### <a name="memory-block-pool-control-block-tx_block_pool"></a><span data-ttu-id="f4296-822">TX_BLOCK_POOL: bloque de control de grupos de bloques de memoria</span><span class="sxs-lookup"><span data-stu-id="f4296-822">Memory Block Pool Control Block TX_BLOCK_POOL</span></span>

<span data-ttu-id="f4296-823">Las características de cada grupo de bloques de memoria se encuentran en su bloque de control.</span><span class="sxs-lookup"><span data-stu-id="f4296-823">The characteristics of each memory block pool are found in its control block.</span></span> <span data-ttu-id="f4296-824">Contiene información como el número de bloques de memoria disponibles y el tamaño del bloque de memoria.</span><span class="sxs-lookup"><span data-stu-id="f4296-824">It contains information such as the number of memory blocks available and the memory pool block size.</span></span> <span data-ttu-id="f4296-825">Esta estructura se define en el archivo ***tx_api.h***.</span><span class="sxs-lookup"><span data-stu-id="f4296-825">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="f4296-826">Los bloques de control de grupos se pueden ubicar en cualquier parte de la memoria, pero es más común convertir el bloque de control en una estructura global definiéndolo fuera del ámbito de cualquier función.</span><span class="sxs-lookup"><span data-stu-id="f4296-826">Pool control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="overwriting-memory-blocks"></a><span data-ttu-id="f4296-827">Sobrescritura de bloques de memoria</span><span class="sxs-lookup"><span data-stu-id="f4296-827">Overwriting Memory Blocks</span></span>

<span data-ttu-id="f4296-828">Es importante asegurarse de que el usuario de un bloque de memoria asignado no escriba fuera de sus límites.</span><span class="sxs-lookup"><span data-stu-id="f4296-828">It is important to ensure that the user of an allocated memory block does not write outside its boundaries.</span></span> <span data-ttu-id="f4296-829">Si esto ocurre, los daños se producen en un área de memoria adyacente (normalmente posterior).</span><span class="sxs-lookup"><span data-stu-id="f4296-829">If this happens, corruption occurs in an adjacent (usually subsequent) memory area.</span></span> <span data-ttu-id="f4296-830">Los resultados son imprevisibles y a menudo graves para la aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-830">The results are unpredictable and often fatal to the application.</span></span>

## <a name="memory-byte-pools"></a><span data-ttu-id="f4296-831">Bloques de bytes de memoria</span><span class="sxs-lookup"><span data-stu-id="f4296-831">Memory Byte Pools</span></span>

<span data-ttu-id="f4296-832">Los grupos de bytes de memoria de ThreadX son similares a un montón de C estándar.</span><span class="sxs-lookup"><span data-stu-id="f4296-832">ThreadX memory byte pools are similar to a standard C heap.</span></span> <span data-ttu-id="f4296-833">A diferencia del montón de C estándar, es posible tener varios grupos de bytes de memoria.</span><span class="sxs-lookup"><span data-stu-id="f4296-833">Unlike the standard C heap, it is possible to have multiple memory byte pools.</span></span> <span data-ttu-id="f4296-834">Además, los subprocesos se pueden suspender en un grupo hasta que la memoria solicitada esté disponible.</span><span class="sxs-lookup"><span data-stu-id="f4296-834">In addition, threads can suspend on a pool until the requested memory is available.</span></span>

<span data-ttu-id="f4296-835">Las asignaciones desde los bloques de bytes de memoria son similares a las llamadas a \***malloc** _ tradicionales, que incluyen la cantidad de memoria deseada (en bytes).</span><span class="sxs-lookup"><span data-stu-id="f4296-835">Allocations from memory byte pools are similar to traditional \***malloc** _ calls, which include the amount of memory desired (in bytes).</span></span> <span data-ttu-id="f4296-836">La asignación de memoria desde el grupo usa un formato "el primero que sea válido", es decir, se usa el primer bloque de memoria libre que satisfaga la solicitud.</span><span class="sxs-lookup"><span data-stu-id="f4296-836">Memory is allocated from the pool in a _first-fit\* manner; i.e., the first free memory block that satisfies the request is used.</span></span> <span data-ttu-id="f4296-837">El exceso de memoria de este bloque se convierte en un nuevo bloque y se vuelve a colocar en la lista de memoria libre.</span><span class="sxs-lookup"><span data-stu-id="f4296-837">Excess memory from this block is converted into a new block and placed back in the free memory list.</span></span> <span data-ttu-id="f4296-838">Este proceso se denomina *fragmentación*.</span><span class="sxs-lookup"><span data-stu-id="f4296-838">This process is called *fragmentation*.</span></span>

<span data-ttu-id="f4296-839">Los bloques de memoria libre adyacentes se *combinan* durante una búsqueda de asignación posterior de un bloque de memoria libre suficientemente grande.</span><span class="sxs-lookup"><span data-stu-id="f4296-839">Adjacent free memory blocks are *merged* together during a subsequent allocation search for a large enough free memory block.</span></span> <span data-ttu-id="f4296-840">Este proceso se denomina *desfragmentación*.</span><span class="sxs-lookup"><span data-stu-id="f4296-840">This process is called *defragmentation*.</span></span>

<span data-ttu-id="f4296-841">Cada grupo de bytes de memoria es un recurso público.</span><span class="sxs-lookup"><span data-stu-id="f4296-841">Each memory byte pool is a public resource.</span></span> <span data-ttu-id="f4296-842">ThreadX no aplica restricciones al modo de usar los grupos, a excepción de que no se puede llamar a los servicios de bytes de memoria desde las ISR.</span><span class="sxs-lookup"><span data-stu-id="f4296-842">ThreadX places no constraints on how pools are used, except that memory byte services cannot be called from ISRs.</span></span>

### <a name="creating-memory-byte-pools"></a><span data-ttu-id="f4296-843">Creación de grupos de bytes de memoria</span><span class="sxs-lookup"><span data-stu-id="f4296-843">Creating Memory Byte Pools</span></span>

<span data-ttu-id="f4296-844">Los grupos de bytes de memoria se crean durante la inicialización o en tiempo de ejecución mediante subprocesos de aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-844">Memory byte pools are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="f4296-845">No hay ningún límite en cuanto al número de grupos de bytes de memoria de una aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-845">There is no limit on the number of memory byte pools in an application.</span></span>

### <a name="pool-capacity"></a><span data-ttu-id="f4296-846">Capacidad del grupo</span><span class="sxs-lookup"><span data-stu-id="f4296-846">Pool Capacity</span></span>

<span data-ttu-id="f4296-847">El número de bytes asignados en un grupo de bytes de memoria es ligeramente menor que el que se ha especificado durante la creación.</span><span class="sxs-lookup"><span data-stu-id="f4296-847">The number of allocatable bytes in a memory byte pool is slightly less than what was specified during creation.</span></span> <span data-ttu-id="f4296-848">Esto se debe a que la administración del área de memoria libre genera cierta sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="f4296-848">This is because management of the free memory area introduces some overhead.</span></span> <span data-ttu-id="f4296-849">Cada bloque de memoria libre del grupo necesita el equivalente de dos punteros de C de sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="f4296-849">Each free memory block in the pool requires the equivalent of two C pointers of overhead.</span></span> <span data-ttu-id="f4296-850">Además, el grupo se crea con dos bloques, un bloque libre grande y uno pequeño asignado de forma permanente al final del área de memoria.</span><span class="sxs-lookup"><span data-stu-id="f4296-850">In addition, the pool is created with two blocks, a large free block and a small permanently allocated block at the end of the memory area.</span></span> <span data-ttu-id="f4296-851">Este bloque asignado se usa para mejorar el rendimiento del algoritmo de asignación.</span><span class="sxs-lookup"><span data-stu-id="f4296-851">This allocated block is used to improve performance of the allocation algorithm.</span></span> <span data-ttu-id="f4296-852">Elimina la necesidad de comprobar continuamente el final del área del grupo durante la combinación.</span><span class="sxs-lookup"><span data-stu-id="f4296-852">It eliminates the need to continuously check for the end of the pool area during merging.</span></span>

<span data-ttu-id="f4296-853">En tiempo de ejecución, la cantidad de sobrecarga en el grupo suele aumentar.</span><span class="sxs-lookup"><span data-stu-id="f4296-853">During run-time, the amount of overhead in the pool typically increases.</span></span> <span data-ttu-id="f4296-854">Las asignaciones de un número impar de bytes se rellenan para garantizar la alineación adecuada del bloque de memoria siguiente.</span><span class="sxs-lookup"><span data-stu-id="f4296-854">Allocations of an odd number of bytes are padded to ensure proper alignment of the next memory block.</span></span> <span data-ttu-id="f4296-855">Además, la sobrecarga aumenta a medida que el grupo se vuelve más fragmentado.</span><span class="sxs-lookup"><span data-stu-id="f4296-855">In addition, overhead increases as the pool becomes more fragmented.</span></span>

### <a name="pools-memory-area"></a><span data-ttu-id="f4296-856">Área de memoria del grupo</span><span class="sxs-lookup"><span data-stu-id="f4296-856">Pool's Memory Area</span></span>

<span data-ttu-id="f4296-857">El área de memoria de un grupo de bytes de memoria se especifica durante la creación.</span><span class="sxs-lookup"><span data-stu-id="f4296-857">The memory area for a memory byte pool is specified during creation.</span></span> <span data-ttu-id="f4296-858">Como sucede con otras áreas de memoria de ThreadX, se puede ubicar en cualquier parte del espacio de direcciones del destino.</span><span class="sxs-lookup"><span data-stu-id="f4296-858">Like other memory areas in ThreadX, it can be located anywhere in the target's address space.</span></span> <span data-ttu-id="f4296-859">Esta es una característica importante debido a la gran flexibilidad que proporciona.</span><span class="sxs-lookup"><span data-stu-id="f4296-859">This is an important feature because of the considerable flexibility it provides.</span></span> <span data-ttu-id="f4296-860">Por ejemplo, si el hardware de destino tiene un área de memoria de alta velocidad y otra de baja velocidad, el usuario puede administrar la asignación de memoria para las dos áreas creando un grupo en cada una de ellas.</span><span class="sxs-lookup"><span data-stu-id="f4296-860">For example, if the target hardware has a high-speed memory area and a low-speed memory area, the user can manage memory allocation for both areas by creating a pool in each of them.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="f4296-861">Suspensión de subprocesos</span><span class="sxs-lookup"><span data-stu-id="f4296-861">Thread Suspension</span></span>

<span data-ttu-id="f4296-862">Los subprocesos de aplicación se pueden suspender mientras se esperan bytes de memoria de un grupo.</span><span class="sxs-lookup"><span data-stu-id="f4296-862">Application threads can suspend while waiting for memory bytes from a pool.</span></span> <span data-ttu-id="f4296-863">Cuando hay suficiente memoria contigua disponible, los subprocesos suspendidos reciben la memoria solicitada y se reanudan.</span><span class="sxs-lookup"><span data-stu-id="f4296-863">When sufficient contiguous memory becomes available, the suspended threads are given their requested memory and the threads are resumed.</span></span>

<span data-ttu-id="f4296-864">Si se suspenden varios subprocesos en el mismo grupo de bytes de memoria, se les asigna memoria (se reanudan) en el orden en el que se hayan suspendido (FIFO).</span><span class="sxs-lookup"><span data-stu-id="f4296-864">If multiple threads are suspended on the same memory byte pool, they are given memory (resumed) in the order they were suspended (FIFO).</span></span>

<span data-ttu-id="f4296-865">Pero la reanudación de la prioridad también es posible si la aplicación llama a ***tx_byte_pool_prioritize*** antes de la llamada de liberación de bytes que levanta la suspensión del subproceso.</span><span class="sxs-lookup"><span data-stu-id="f4296-865">However, priority resumption is also possible if the application calls ***tx_byte_pool_prioritize*** prior to the byte release call that lifts thread suspension.</span></span> <span data-ttu-id="f4296-866">El servicio de clasificación por orden de prioridad de los grupos de bytes coloca el subproceso de prioridad más alta al principio de la lista de suspensiones y deja todos los demás subprocesos suspendidos en el mismo orden FIFO.</span><span class="sxs-lookup"><span data-stu-id="f4296-866">The byte pool prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-byte-pool-performance-information"></a><span data-ttu-id="f4296-867">Información de rendimiento de un grupo de bytes en tiempo de ejecución</span><span class="sxs-lookup"><span data-stu-id="f4296-867">Run-time Byte Pool Performance Information</span></span>

<span data-ttu-id="f4296-868">ThreadX proporciona información opcional sobre el rendimiento de los grupos de bytes en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="f4296-868">ThreadX provides optional run-time byte pool performance information.</span></span> <span data-ttu-id="f4296-869">Si la biblioteca y la aplicación de ThreadX se compilan con ***TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO*** definido, ThreadX acumula la información siguiente.</span><span class="sxs-lookup"><span data-stu-id="f4296-869">If the ThreadX library and application is built with ***TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO*** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="f4296-870">Número total del sistema general:</span><span class="sxs-lookup"><span data-stu-id="f4296-870">Total number for the overall system:</span></span>

  - <span data-ttu-id="f4296-871">asignaciones</span><span class="sxs-lookup"><span data-stu-id="f4296-871">allocations</span></span>

  - <span data-ttu-id="f4296-872">versiones</span><span class="sxs-lookup"><span data-stu-id="f4296-872">releases</span></span>

  - <span data-ttu-id="f4296-873">fragmentos buscados</span><span class="sxs-lookup"><span data-stu-id="f4296-873">fragments searched</span></span>

  - <span data-ttu-id="f4296-874">fragmentos combinados</span><span class="sxs-lookup"><span data-stu-id="f4296-874">fragments merged</span></span>

  - <span data-ttu-id="f4296-875">fragmentos creados</span><span class="sxs-lookup"><span data-stu-id="f4296-875">fragments created</span></span>

  - <span data-ttu-id="f4296-876">suspensiones de asignación</span><span class="sxs-lookup"><span data-stu-id="f4296-876">allocation suspensions</span></span>

  - <span data-ttu-id="f4296-877">tiempos de espera de asignación</span><span class="sxs-lookup"><span data-stu-id="f4296-877">allocation timeouts</span></span>

<span data-ttu-id="f4296-878">Número total de cada grupo de bytes:</span><span class="sxs-lookup"><span data-stu-id="f4296-878">Total number for each byte pool:</span></span>

  - <span data-ttu-id="f4296-879">asignaciones</span><span class="sxs-lookup"><span data-stu-id="f4296-879">allocations</span></span>

  - <span data-ttu-id="f4296-880">versiones</span><span class="sxs-lookup"><span data-stu-id="f4296-880">releases</span></span>

  - <span data-ttu-id="f4296-881">fragmentos buscados</span><span class="sxs-lookup"><span data-stu-id="f4296-881">fragments searched</span></span>

  - <span data-ttu-id="f4296-882">fragmentos combinados</span><span class="sxs-lookup"><span data-stu-id="f4296-882">fragments merged</span></span>

  - <span data-ttu-id="f4296-883">fragmentos creados</span><span class="sxs-lookup"><span data-stu-id="f4296-883">fragments created</span></span>

  - <span data-ttu-id="f4296-884">suspensiones de asignación</span><span class="sxs-lookup"><span data-stu-id="f4296-884">allocation suspensions</span></span>

  - <span data-ttu-id="f4296-885">tiempos de espera de asignación</span><span class="sxs-lookup"><span data-stu-id="f4296-885">allocation timeouts</span></span>

<span data-ttu-id="f4296-886">Esta información está disponible en tiempo de ejecución por medio de los servicios ***tx_byte_pool_performance_info_get** _ y _*_tx_byte_pool_performance_system_info_get_\*\*.</span><span class="sxs-lookup"><span data-stu-id="f4296-886">This information is available at run-time through the services ***tx_byte_pool_performance_info_get** _ and _*_tx_byte_pool_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="f4296-887">La información de rendimiento de los grupos de bytes resulta útil para determinar si la aplicación se comporta de manera correcta.</span><span class="sxs-lookup"><span data-stu-id="f4296-887">Byte pool performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="f4296-888">También es útil para optimizar la aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-888">It is also useful in optimizing the application.</span></span> <span data-ttu-id="f4296-889">Por ejemplo, un número relativamente alto de "suspensiones de asignación" podría sugerir que el grupo de bytes es demasiado pequeño.</span><span class="sxs-lookup"><span data-stu-id="f4296-889">For example, a relatively high number of "allocation suspensions" might suggest that the byte pool is too small.</span></span>

### <a name="memory-byte-pool-control-block-tx_byte_pool"></a><span data-ttu-id="f4296-890">TX_BYTE_POOL: bloque de control de grupos de bytes de memoria</span><span class="sxs-lookup"><span data-stu-id="f4296-890">Memory Byte Pool Control Block TX_BYTE_POOL</span></span>

<span data-ttu-id="f4296-891">Las características de cada grupo de bytes de memoria se encuentran en su bloque de control.</span><span class="sxs-lookup"><span data-stu-id="f4296-891">The characteristics of each memory byte pool are found in its control block.</span></span> <span data-ttu-id="f4296-892">Contiene información útil, como el número de bytes disponibles en el grupo.</span><span class="sxs-lookup"><span data-stu-id="f4296-892">It contains useful information such as the number of available bytes in the pool.</span></span> <span data-ttu-id="f4296-893">Esta estructura se define en el archivo ***tx_api.h***.</span><span class="sxs-lookup"><span data-stu-id="f4296-893">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="f4296-894">Los bloques de control de grupos se pueden ubicar en cualquier parte de la memoria, pero es más común convertir el bloque de control en una estructura global definiéndolo fuera del ámbito de cualquier función.</span><span class="sxs-lookup"><span data-stu-id="f4296-894">Pool control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="nondeterministic-behavior"></a><span data-ttu-id="f4296-895">Comportamiento no determinista</span><span class="sxs-lookup"><span data-stu-id="f4296-895">Nondeterministic Behavior</span></span>

<span data-ttu-id="f4296-896">Aunque los grupos de bytes de memoria proporcionan la asignación de memoria más flexible, también sufren un comportamiento no determinista.</span><span class="sxs-lookup"><span data-stu-id="f4296-896">Although memory byte pools provide the most flexible memory allocation, they also suffer from somewhat nondeterministic behavior.</span></span> <span data-ttu-id="f4296-897">Por ejemplo, un grupo de bytes de memoria puede tener 2000 bytes de memoria disponibles, pero es posible que no pueda satisfacer una solicitud de asignación de 1000 bytes.</span><span class="sxs-lookup"><span data-stu-id="f4296-897">For example, a memory byte pool may have 2,000 bytes of memory available but may not be able to satisfy an allocation request of 1,000 bytes.</span></span> <span data-ttu-id="f4296-898">Esto se debe a que no hay ninguna garantía de cuántos de los bytes libres son contiguos.</span><span class="sxs-lookup"><span data-stu-id="f4296-898">This is because there are no guarantees on how many of the free bytes are contiguous.</span></span> <span data-ttu-id="f4296-899">Incluso si existe un bloque libre de 1000 bytes, no hay ninguna garantía sobre el tiempo que se puede tardar en encontrar el bloque.</span><span class="sxs-lookup"><span data-stu-id="f4296-899">Even if a 1,000 byte free block exists, there are no guarantees on how long it might take to find the block.</span></span> <span data-ttu-id="f4296-900">Es totalmente posible que sea necesario buscar en todo el grupo de memoria para encontrar el bloque de 1000 bytes.</span><span class="sxs-lookup"><span data-stu-id="f4296-900">It is completely possible that the entire memory pool would need to be searched to find the 1,000 byte block.</span></span>

> [!TIP]
> <span data-ttu-id="f4296-901">*Como resultado del comportamiento no determinista de los grupos de bytes de memoria, por lo general se recomienda evitar el uso de servicios de bytes de memoria en áreas donde se necesita un comportamiento determinista y en tiempo real. Muchas aplicaciones realizan una asignación previa de su memoria necesaria durante la configuración de inicialización o en tiempo de ejecución.*</span><span class="sxs-lookup"><span data-stu-id="f4296-901">*As a result of the nondeterministic behavior of memory byte pools, it is generally good practice to avoid using memory byte services in areas where deterministic, real-time behavior is required. Many applications pre-allocate their required memory during initialization or run-time configuration.*</span></span>

### <a name="overwriting-memory-blocks"></a><span data-ttu-id="f4296-902">Sobrescritura de bloques de memoria</span><span class="sxs-lookup"><span data-stu-id="f4296-902">Overwriting Memory Blocks</span></span>

<span data-ttu-id="f4296-903">Es importante asegurarse de que el usuario de la memoria asignada no escriba fuera de sus límites.</span><span class="sxs-lookup"><span data-stu-id="f4296-903">It is important to ensure that the user of allocated memory does not write outside its boundaries.</span></span> <span data-ttu-id="f4296-904">Si esto ocurre, los daños se producen en un área de memoria adyacente (normalmente posterior).</span><span class="sxs-lookup"><span data-stu-id="f4296-904">If this happens, corruption occurs in an adjacent (usually subsequent) memory area.</span></span> <span data-ttu-id="f4296-905">Los resultados son imprevisibles y a menudo catastróficos para la ejecución del programa.</span><span class="sxs-lookup"><span data-stu-id="f4296-905">The results are unpredictable and often catastrophic for program execution.</span></span>

## <a name="application-timers"></a><span data-ttu-id="f4296-906">Temporizadores de aplicación</span><span class="sxs-lookup"><span data-stu-id="f4296-906">Application Timers</span></span>

<span data-ttu-id="f4296-907">La respuesta rápida a los eventos externos asincrónicos es la función más importante de las aplicaciones insertadas en tiempo real.</span><span class="sxs-lookup"><span data-stu-id="f4296-907">Fast response to asynchronous external events is the most important function of real-time, embedded applications.</span></span> <span data-ttu-id="f4296-908">Pero muchas de estas aplicaciones también deben realizar ciertas actividades en intervalos de tiempo predeterminados.</span><span class="sxs-lookup"><span data-stu-id="f4296-908">However, many of these applications must also perform certain activities at predetermined intervals of time.</span></span>

<span data-ttu-id="f4296-909">Los temporizadores de aplicación de ThreadX proporcionan a las aplicaciones la capacidad de ejecutar funciones de aplicación de C a intervalos de tiempo concretos.</span><span class="sxs-lookup"><span data-stu-id="f4296-909">ThreadX application timers provide applications with the ability to execute application C functions at specific intervals of time.</span></span> <span data-ttu-id="f4296-910">También es posible que un temporizador de aplicación expire una sola vez.</span><span class="sxs-lookup"><span data-stu-id="f4296-910">It is also possible for an application timer to expire only once.</span></span> <span data-ttu-id="f4296-911">Este tipo de temporizador se denomina *temporizador único*, mientras que los temporizadores con intervalos repetidos se denominan *temporizadores periódicos*.</span><span class="sxs-lookup"><span data-stu-id="f4296-911">This type of timer is called a *one-shot timer*, while repeating interval timers are called *periodic timers*.</span></span>

<span data-ttu-id="f4296-912">Cada temporizador de aplicación es un recurso público.</span><span class="sxs-lookup"><span data-stu-id="f4296-912">Each application timer is a public resource.</span></span> <span data-ttu-id="f4296-913">ThreadX no aplica restricciones al modo de usar los temporizadores de aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-913">ThreadX places no constraints on how application timers are used.</span></span>

### <a name="timer-intervals"></a><span data-ttu-id="f4296-914">Intervalos de temporizador</span><span class="sxs-lookup"><span data-stu-id="f4296-914">Timer Intervals</span></span>

<span data-ttu-id="f4296-915">En ThreadX, los intervalos de tiempo se miden por interrupciones periódicas del temporizador.</span><span class="sxs-lookup"><span data-stu-id="f4296-915">In ThreadX time intervals are measured by periodic timer interrupts.</span></span> <span data-ttu-id="f4296-916">Cada interrupción del temporizador se denomina *tic* del temporizador.</span><span class="sxs-lookup"><span data-stu-id="f4296-916">Each timer interrupt is called a timer *tick*.</span></span> <span data-ttu-id="f4296-917">La aplicación especifica el tiempo real entre tics del temporizador, pero 10 ms es la norma en la mayoría de las implementaciones.</span><span class="sxs-lookup"><span data-stu-id="f4296-917">The actual time between timer ticks is specified by the application, but 10ms is the norm for most implementations.</span></span> <span data-ttu-id="f4296-918">La configuración del temporizador periódico normalmente se encuentra en el archivo de ensamblado ***tx_initialize_low_level***.</span><span class="sxs-lookup"><span data-stu-id="f4296-918">The periodic timer setup is typically found in the ***tx_initialize_low_level*** assembly file.</span></span>

<span data-ttu-id="f4296-919">Merece la pena mencionar que el hardware subyacente debe tener la capacidad de generar interrupciones periódicas para que los temporizadores de la aplicación funcionen.</span><span class="sxs-lookup"><span data-stu-id="f4296-919">It is worth mentioning that the underlying hardware must have the ability to generate periodic interrupts for application timers to function.</span></span> <span data-ttu-id="f4296-920">En algunos casos, el procesador tiene una capacidad de interrupción periódica integrada.</span><span class="sxs-lookup"><span data-stu-id="f4296-920">In some cases, the processor has a built-in periodic interrupt capability.</span></span> <span data-ttu-id="f4296-921">Si el procesador no tiene esta capacidad, el panel del usuario debe tener un dispositivo periférico que pueda generar interrupciones periódicas.</span><span class="sxs-lookup"><span data-stu-id="f4296-921">If the processor doesn't have this ability, the user's board must have a peripheral device that can generate periodic interrupts.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f4296-922">*ThreadX todavía puede funcionar incluso sin un origen de interrupción periódico, pero se deshabilita todo el procesamiento relacionado con el temporizador. Esto incluye la segmentación temporal, los tiempos de espera de suspensión y los servicios de temporizador.*</span><span class="sxs-lookup"><span data-stu-id="f4296-922">*ThreadX can still function even without a periodic interrupt source. However, all timer-related processing is then disabled. This includes timeslicing, suspension time-outs, and timer services.*</span></span>

### <a name="timer-accuracy"></a><span data-ttu-id="f4296-923">Precisión del temporizador</span><span class="sxs-lookup"><span data-stu-id="f4296-923">Timer Accuracy</span></span>

<span data-ttu-id="f4296-924">Las expiraciones del temporizador se especifican en términos de tics.</span><span class="sxs-lookup"><span data-stu-id="f4296-924">Timer expirations are specified in terms of ticks.</span></span> <span data-ttu-id="f4296-925">El valor de expiración especificado se reduce en uno en cada tic del temporizador.</span><span class="sxs-lookup"><span data-stu-id="f4296-925">The specified expiration value is decreased by one on each timer tick.</span></span> <span data-ttu-id="f4296-926">Como un temporizador de aplicación se puede habilitar justo antes de una interrupción del temporizador (o tic), el tiempo de expiración real puede ser hasta un tic anterior.</span><span class="sxs-lookup"><span data-stu-id="f4296-926">Because an application timer could be enabled just prior to a timer interrupt (or timer tick), the actual expiration time could be up to one tick early.</span></span>

<span data-ttu-id="f4296-927">Si la tasa de tics del temporizador es de 10 ms, los temporizadores de la aplicación pueden expirar hasta 10 ms antes.</span><span class="sxs-lookup"><span data-stu-id="f4296-927">If the timer tick rate is 10ms, application timers may expire up to 10ms early.</span></span> <span data-ttu-id="f4296-928">Esto es más importante para temporizadores de 10 ms que para los de 1 segundo.</span><span class="sxs-lookup"><span data-stu-id="f4296-928">This is more significant for 10ms timers than 1 second timers.</span></span> <span data-ttu-id="f4296-929">Evidentemente, el aumento de la frecuencia de interrupción del temporizador reduce este margen de error.</span><span class="sxs-lookup"><span data-stu-id="f4296-929">Of course, increasing the timer interrupt frequency decreases this margin of error.</span></span>

### <a name="timer-execution"></a><span data-ttu-id="f4296-930">Ejecución del temporizador</span><span class="sxs-lookup"><span data-stu-id="f4296-930">Timer Execution</span></span>

<span data-ttu-id="f4296-931">Los temporizadores de aplicación se ejecutan en el orden en que se activan.</span><span class="sxs-lookup"><span data-stu-id="f4296-931">Application timers execute in the order they become active.</span></span> <span data-ttu-id="f4296-932">Por ejemplo, si se crean tres temporizadores con el mismo valor de expiración y se activan, se garantiza que sus funciones de expiración correspondientes se ejecuten en el orden en el que se hayan activado.</span><span class="sxs-lookup"><span data-stu-id="f4296-932">For example, if three timers are created with the same expiration value and activated, their corresponding expiration functions are guaranteed to execute in the order they were activated.</span></span>

### <a name="creating-application-timers"></a><span data-ttu-id="f4296-933">Creación de temporizadores de aplicación</span><span class="sxs-lookup"><span data-stu-id="f4296-933">Creating Application Timers</span></span>

<span data-ttu-id="f4296-934">Los temporizadores de aplicación se crean durante la inicialización o en tiempo de ejecución mediante subprocesos de aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-934">Application timers are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="f4296-935">No hay ningún límite en cuanto al número de temporizadores de aplicación en una aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-935">There is no limit on the number of application timers in an application.</span></span>

### <a name="run-time-application-timer-performance-information"></a><span data-ttu-id="f4296-936">Información de rendimiento del temporizador de aplicación en tiempo de ejecución</span><span class="sxs-lookup"><span data-stu-id="f4296-936">Run-time Application Timer Performance Information</span></span>

<span data-ttu-id="f4296-937">ThreadX proporciona información opcional sobre el rendimiento de los temporizadores de aplicación en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="f4296-937">ThreadX provides optional run-time application timer performance information.</span></span> <span data-ttu-id="f4296-938">Si la biblioteca y la aplicación de ThreadX se compilan con **TX_TIMER_ENABLE_PERFORMANCE_INFO** definido, ThreadX acumula la información siguiente.</span><span class="sxs-lookup"><span data-stu-id="f4296-938">If the ThreadX library and application are built with **TX_TIMER_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="f4296-939">Número total del sistema general:</span><span class="sxs-lookup"><span data-stu-id="f4296-939">Total number for the overall system:</span></span>

- <span data-ttu-id="f4296-940">activaciones</span><span class="sxs-lookup"><span data-stu-id="f4296-940">activations</span></span>

- <span data-ttu-id="f4296-941">desactivaciones</span><span class="sxs-lookup"><span data-stu-id="f4296-941">deactivations</span></span>

- <span data-ttu-id="f4296-942">reactivaciones (temporizadores periódicos)</span><span class="sxs-lookup"><span data-stu-id="f4296-942">reactivations (periodic timers)</span></span>

- <span data-ttu-id="f4296-943">expirations</span><span class="sxs-lookup"><span data-stu-id="f4296-943">expirations</span></span>

- <span data-ttu-id="f4296-944">ajustes de expiración</span><span class="sxs-lookup"><span data-stu-id="f4296-944">expiration adjustments</span></span>

<span data-ttu-id="f4296-945">Número total de cada temporizador de aplicación:</span><span class="sxs-lookup"><span data-stu-id="f4296-945">Total number for each application timer:</span></span>

- <span data-ttu-id="f4296-946">activaciones</span><span class="sxs-lookup"><span data-stu-id="f4296-946">activations</span></span>

- <span data-ttu-id="f4296-947">desactivaciones</span><span class="sxs-lookup"><span data-stu-id="f4296-947">deactivations</span></span>

- <span data-ttu-id="f4296-948">reactivaciones (temporizadores periódicos)</span><span class="sxs-lookup"><span data-stu-id="f4296-948">reactivations (periodic timers)</span></span>

- <span data-ttu-id="f4296-949">expirations</span><span class="sxs-lookup"><span data-stu-id="f4296-949">expirations</span></span>

- <span data-ttu-id="f4296-950">ajustes de expiración</span><span class="sxs-lookup"><span data-stu-id="f4296-950">expiration adjustments</span></span>

<span data-ttu-id="f4296-951">Esta información está disponible en tiempo de ejecución por medio de los servicios ***tx_timer_performance_info_get** _ y _*_tx_timer_performance_system_info_get_\*\*.</span><span class="sxs-lookup"><span data-stu-id="f4296-951">This information is available at run-time through the services ***tx_timer_performance_info_get** _ and _*_tx_timer_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="f4296-952">La información de rendimiento de los temporizadores de aplicación resulta útil para determinar si la aplicación se comporta de manera correcta.</span><span class="sxs-lookup"><span data-stu-id="f4296-952">Application Timer performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="f4296-953">También es útil para optimizar la aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-953">It is also useful in optimizing the application.</span></span>

### <a name="application-timer-control-block-tx_timer"></a><span data-ttu-id="f4296-954">TX_TIMER: bloque de control de temporizador de aplicación</span><span class="sxs-lookup"><span data-stu-id="f4296-954">Application Timer Control Block TX_TIMER</span></span>

<span data-ttu-id="f4296-955">Las características de cada temporizador de aplicación se encuentran en su bloque de control.</span><span class="sxs-lookup"><span data-stu-id="f4296-955">The characteristics of each application timer are found in its control block.</span></span> <span data-ttu-id="f4296-956">Contiene información útil, como el valor de identificación de expiración de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="f4296-956">It contains useful information such as the 32-bit expiration identification value.</span></span> <span data-ttu-id="f4296-957">Esta estructura se define en el archivo ***tx_api.h***.</span><span class="sxs-lookup"><span data-stu-id="f4296-957">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="f4296-958">Los bloques de control de temporizador de aplicación se pueden ubicar en cualquier parte de la memoria, pero es más común convertir el bloque de control en una estructura global definiéndolo fuera del ámbito de cualquier función.</span><span class="sxs-lookup"><span data-stu-id="f4296-958">Application timer control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="excessive-timers"></a><span data-ttu-id="f4296-959">Temporizadores excesivos</span><span class="sxs-lookup"><span data-stu-id="f4296-959">Excessive Timers</span></span>

<span data-ttu-id="f4296-960">De forma predeterminada, los temporizadores de aplicación se ejecutan desde dentro de un subproceso del sistema oculto que se ejecuta con prioridad cero, que suele ser mayor que cualquier subproceso de aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-960">By default, application timers execute from within a hidden system thread that runs at priority zero, which is typically higher than any application thread.</span></span> <span data-ttu-id="f4296-961">Por este motivo, el procesamiento dentro de los temporizadores de aplicación debe ser mínimo.</span><span class="sxs-lookup"><span data-stu-id="f4296-961">Because of this, processing inside application timers should be kept to a minimum.</span></span>

<span data-ttu-id="f4296-962">También es importante evitar, siempre que sea posible, temporizadores que expiren en cada tic del temporizador.</span><span class="sxs-lookup"><span data-stu-id="f4296-962">It is also important to avoid, whenever possible, timers that expire every timer tick.</span></span> <span data-ttu-id="f4296-963">Esa situación podría inducir una sobrecarga excesiva en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-963">Such a situation might induce excessive overhead in the application.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f4296-964">*Como se ha mencionado antes, los temporizadores de aplicación se ejecutan desde un subproceso del sistema oculto. Por tanto, es importante no seleccionar la suspensión en ninguna llamada de servicio de ThreadX realizada desde la función de expiración del temporizador de aplicación.*</span><span class="sxs-lookup"><span data-stu-id="f4296-964">*As mentioned previously, application timers are executed from a hidden system thread. It is, therefore, important not to select suspension on any ThreadX service calls made from within the application timer's expiration function.*</span></span>

## <a name="relative-time"></a><span data-ttu-id="f4296-965">Tiempo relativo</span><span class="sxs-lookup"><span data-stu-id="f4296-965">Relative Time</span></span>

<span data-ttu-id="f4296-966">Además de los temporizadores de aplicación mencionados antes, ThreadX proporciona un único contador de tics de 32 bits que aumenta continuamente.</span><span class="sxs-lookup"><span data-stu-id="f4296-966">In addition to the application timers mentioned previously, ThreadX provides a single continuously incrementing 32-bit tick counter.</span></span> <span data-ttu-id="f4296-967">El contador de tics o *tiempo* se incrementa en uno en cada interrupción del temporizador.</span><span class="sxs-lookup"><span data-stu-id="f4296-967">The tick counter or *time* is increased by one on each timer interrupt.</span></span>

<span data-ttu-id="f4296-968">La aplicación puede leer o establecer este contador de 32 bits mediante llamadas a ***tx_time_get** _ y _*_tx_time_set_\*\*, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="f4296-968">The application can read or set this 32-bit counter through calls to ***tx_time_get** _ and _*_tx_time_set_\*\*, respectively.</span></span> <span data-ttu-id="f4296-969">La aplicación determina el uso de este contador de tics.</span><span class="sxs-lookup"><span data-stu-id="f4296-969">The use of this tick counter is determined completely by the application.</span></span> <span data-ttu-id="f4296-970">ThreadX no lo usa de forma interna.</span><span class="sxs-lookup"><span data-stu-id="f4296-970">It is not used internally by ThreadX.</span></span>

## <a name="interrupts"></a><span data-ttu-id="f4296-971">Interrupciones</span><span class="sxs-lookup"><span data-stu-id="f4296-971">Interrupts</span></span>

<span data-ttu-id="f4296-972">La respuesta rápida a los eventos asincrónicos es la función principal de las aplicaciones insertadas en tiempo real.</span><span class="sxs-lookup"><span data-stu-id="f4296-972">Fast response to asynchronous events is the principal function of real-time, embedded applications.</span></span> <span data-ttu-id="f4296-973">La aplicación sabe que este evento está presente por medio de interrupciones de hardware.</span><span class="sxs-lookup"><span data-stu-id="f4296-973">The application knows such an event is present through hardware interrupts.</span></span>

<span data-ttu-id="f4296-974">Una interrupción es un cambio asincrónico en la ejecución del procesador.</span><span class="sxs-lookup"><span data-stu-id="f4296-974">An interrupt is an asynchronous change in processor execution.</span></span> <span data-ttu-id="f4296-975">Normalmente, cuando se produce una interrupción, el procesador de *interrupciones* guarda una pequeña parte de la ejecución actual en la pila y transfiere el control al vector de interrupción adecuado.</span><span class="sxs-lookup"><span data-stu-id="f4296-975">Typically, when an interrupt occurs, the *Interrupts* processor saves a small portion of the current execution on the stack and transfers control to the appropriate interrupt vector.</span></span> <span data-ttu-id="f4296-976">El vector de interrupción es básicamente la dirección de la rutina responsable de controlar la interrupción de tipo específica.</span><span class="sxs-lookup"><span data-stu-id="f4296-976">The interrupt vector is basically just the address of the routine responsible for handling the specific type interrupt.</span></span> <span data-ttu-id="f4296-977">El procedimiento de control de la interrupción exacta es específico del procesador.</span><span class="sxs-lookup"><span data-stu-id="f4296-977">The exact interrupt handling procedure is processor specific.</span></span>

### <a name="interrupt-control"></a><span data-ttu-id="f4296-978">Control de interrupción</span><span class="sxs-lookup"><span data-stu-id="f4296-978">Interrupt Control</span></span>

<span data-ttu-id="f4296-979">El servicio ***tx_interrupt_control*** permite a las aplicaciones habilitar y deshabilitar las interrupciones.</span><span class="sxs-lookup"><span data-stu-id="f4296-979">The ***tx_interrupt_control*** service allows applications to enable and disable interrupts.</span></span> <span data-ttu-id="f4296-980">Este servicio devuelve la posición de habilitación o deshabilitación de la interrupción anterior.</span><span class="sxs-lookup"><span data-stu-id="f4296-980">The previous interrupt enable/disable posture is returned by this service.</span></span> <span data-ttu-id="f4296-981">Es importante mencionar que el control de interrupción solo afecta al segmento del programa actualmente en ejecución.</span><span class="sxs-lookup"><span data-stu-id="f4296-981">It is important to mention that interrupt control only affects the currently executing program segment.</span></span> <span data-ttu-id="f4296-982">Por ejemplo, si un subproceso deshabilita las interrupciones, solo permanecerán deshabilitadas durante la ejecución de ese subproceso.</span><span class="sxs-lookup"><span data-stu-id="f4296-982">For example, if a thread disables interrupts, they only remain disabled during execution of that thread.</span></span>

> [!NOTE]
> <span data-ttu-id="f4296-983">*Una interrupción no enmascarable (NMI) es una interrupción que el hardware no puede deshabilitar. Estas interrupciones se pueden usar en las aplicaciones de ThreadX; pero no se permite que la rutina de control de NMI de la aplicación use la administración de contextos de ThreadX ni ningún servicio de API.*</span><span class="sxs-lookup"><span data-stu-id="f4296-983">*A Non-Maskable Interrupt (NMI) is an interrupt that cannot be disabled by the hardware. Such an interrupt may be used by ThreadX applications. However, the application's NMI handling routine is not allowed to use ThreadX context management or any API services.*</span></span>

### <a name="threadx-managed-interrupts"></a><span data-ttu-id="f4296-984">Interrupciones administradas de ThreadX</span><span class="sxs-lookup"><span data-stu-id="f4296-984">ThreadX Managed Interrupts</span></span>

<span data-ttu-id="f4296-985">ThreadX proporciona a las aplicaciones la administración completa de las interrupciones.</span><span class="sxs-lookup"><span data-stu-id="f4296-985">ThreadX provides applications with complete interrupt management.</span></span> <span data-ttu-id="f4296-986">Esta administración incluye el guardado y la restauración del contexto de la ejecución interrumpida.</span><span class="sxs-lookup"><span data-stu-id="f4296-986">This management includes saving and restoring the context of the interrupted execution.</span></span> <span data-ttu-id="f4296-987">Además, ThreadX permite que se llame a determinados servicios desde rutinas de servicio de interrupción (ISR).</span><span class="sxs-lookup"><span data-stu-id="f4296-987">In addition, ThreadX allows certain services to be called from within Interrupt Service Routines (ISRs).</span></span> <span data-ttu-id="f4296-988">A continuación se muestra una lista de los servicios de ThreadX permitidos desde ISR de aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-988">The following is a list of ThreadX services allowed from application ISRs.</span></span>

```c
tx_block_allocate
tx_block_pool_info_get tx_block_pool_prioritize
tx_block_pool_performance_info_get
tx_block_pool_performance_system_info_get tx_block_release
tx_byte_pool_info_get tx_byte_pool_performance_info_get
tx_byte_pool_performance_system_info_get
tx_byte_pool_prioritize tx_event_flags_info_get
tx_event_flags_get tx_event_flags_set
tx_event_flags_performance_info_get
tx_event_flags_performance_system_info_get
tx_event_flags_set_notify tx_interrupt_control
tx_mutex_performance_info_get
tx_mutex_performance_system_info_get tx_queue_front_send
tx_queue_info_get tx_queue_performance_info_get
tx_queue_performance_system_info_get tx_queue_prioritize
tx_queue_receive tx_queue_send tx_semaphore_get
tx_queue_send_notify tx_semaphore_ceiling_put
tx_semaphore_info_get tx_semaphore_performance_info_get
tx_semaphore_performance_system_info_get
tx_semaphore_prioritize tx_semaphore_put tx_thread_identify
tx_semaphore_put_notify tx_thread_entry_exit_notify
tx_thread_info_get tx_thread_resume
tx_thread_performance_info_get
tx_thread_performance_system_info_get
tx_thread_stack_error_notify tx_thread_wait_abort tx_time_get
tx_time_set tx_timer_activate tx_timer_change
tx_timer_deactivate tx_timer_info_get
tx_timer_performance_info_get
tx_timer_performance_system_info_get
```

> [!IMPORTANT]
> <span data-ttu-id="f4296-989">*No se permite la suspensión desde ISR. Por tanto, el parámetro **wait_option** para todas las llamadas de servicio de ThreadX realizadas desde una ISR se deben establecer en **TX_NO_WAIT**.*</span><span class="sxs-lookup"><span data-stu-id="f4296-989">*Suspension is not allowed from ISRs. Therefore, the **wait_option** parameter for all ThreadX service calls made from an ISR must be set to **TX_NO_WAIT**.*</span></span>

### <a name="isr-template"></a><span data-ttu-id="f4296-990">Plantilla de ISR</span><span class="sxs-lookup"><span data-stu-id="f4296-990">ISR Template</span></span>

<span data-ttu-id="f4296-991">Para administrar las interrupciones de la aplicación, se debe llamar a varias utilidades de ThreadX al principio y al final de las ISR de aplicación.</span><span class="sxs-lookup"><span data-stu-id="f4296-991">To manage application interrupts, several ThreadX utilities must be called in the beginning and end of application ISRs.</span></span> <span data-ttu-id="f4296-992">El formato exacto para el control de interrupciones varía entre puertos.</span><span class="sxs-lookup"><span data-stu-id="f4296-992">The exact format for interrupt handling varies between ports.</span></span>

<span data-ttu-id="f4296-993">El siguiente segmento de código pequeño es típico de la mayoría de las ISR administradas de ThreadX.</span><span class="sxs-lookup"><span data-stu-id="f4296-993">The following small code segment is typical of most ThreadX managed ISRs.</span></span> <span data-ttu-id="f4296-994">En la mayoría de los casos, este procesamiento está en lenguaje de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="f4296-994">In most cases, this processing is in assembly language.</span></span>

```c
_application_ISR_vector_entry:

; Save context and prepare for

; ThreadX use by calling the ISR

; entry function.

CALL _tx_thread_context_save

; The ISR can now call ThreadX

; services and its own C functions

; When the ISR is finished, context

; is restored (or thread preemption)

; by calling the context restore ; function. Control does not return!

JUMP _tx_thread_context_restore
```

### <a name="high-frequency-interrupts"></a><span data-ttu-id="f4296-995">Interrupciones de alta frecuencia</span><span class="sxs-lookup"><span data-stu-id="f4296-995">High-frequency Interrupts</span></span>

<span data-ttu-id="f4296-996">Algunas interrupciones se producen con una frecuencia tan alta que al guardar y restaurar el contexto completo en cada interrupción se consumirá un ancho de banda de procesamiento excesivo.</span><span class="sxs-lookup"><span data-stu-id="f4296-996">Some interrupts occur at such a high frequency that saving and restoring full context upon each interrupt would consume excessive processing bandwidth.</span></span> <span data-ttu-id="f4296-997">En esos casos, es habitual que la aplicación tenga una ISR de lenguaje de ensamblado pequeña que realiza una cantidad limitada de procesamiento para una mayoría de estas interrupciones de alta frecuencia.</span><span class="sxs-lookup"><span data-stu-id="f4296-997">In such cases, it is common for the application to have a small assembly language ISR that does a limited amount of processing for a majority of these high-frequency interrupts.</span></span>

<span data-ttu-id="f4296-998">Después de un momento determinado, es posible que la ISR pequeña tenga que interactuar con ThreadX.</span><span class="sxs-lookup"><span data-stu-id="f4296-998">After a certain point in time, the small ISR may need to interact with ThreadX.</span></span> <span data-ttu-id="f4296-999">Esto se logra mediante una llamada a las funciones de entrada y salida descritas en la plantilla anterior.</span><span class="sxs-lookup"><span data-stu-id="f4296-999">This is accomplished by calling the entry and exit functions described in the above template.</span></span>

### <a name="interrupt-latency"></a><span data-ttu-id="f4296-1000">Latencia de interrupción</span><span class="sxs-lookup"><span data-stu-id="f4296-1000">Interrupt Latency</span></span>

<span data-ttu-id="f4296-1001">ThreadX bloquea las interrupciones durante breves periodos de tiempo.</span><span class="sxs-lookup"><span data-stu-id="f4296-1001">ThreadX locks out interrupts over brief periods of time.</span></span> <span data-ttu-id="f4296-1002">La cantidad máxima de tiempo que las interrupciones se deshabilitan es el orden del tiempo necesario para guardar o restaurar el contexto de un subproceso.</span><span class="sxs-lookup"><span data-stu-id="f4296-1002">The maximum amount of time interrupts are disabled is on the order of the time required to save or restore a thread's context.</span></span>
