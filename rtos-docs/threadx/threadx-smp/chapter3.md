---
title: 'Capítulo 3: Componentes funcionales de Azure RTOS ThreadX SMP'
description: Este capítulo contiene una descripción del kernel de alto rendimiento de Azure RTOS ThreadX SMP desde una perspectiva funcional.
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 6a72acb111aa986f4621e8747568ce3ce3e5e080
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 03/22/2021
ms.locfileid: "104815693"
---
# <a name="chapter-3---functional-components-of-azure-rtos-threadx-smp"></a><span data-ttu-id="5a912-103">Capítulo 3: Componentes funcionales de Azure RTOS ThreadX SMP</span><span class="sxs-lookup"><span data-stu-id="5a912-103">Chapter 3 - Functional Components of Azure RTOS ThreadX SMP</span></span>

<span data-ttu-id="5a912-104">Este capítulo contiene una descripción del kernel de alto rendimiento de Azure RTOS ThreadX SMP desde una perspectiva funcional.</span><span class="sxs-lookup"><span data-stu-id="5a912-104">This chapter contains a description of the highperformance Azure RTOS ThreadX SMP kernel from a functional perspective.</span></span> <span data-ttu-id="5a912-105">Cada componente funcional se presenta de una forma fácil de entender.</span><span class="sxs-lookup"><span data-stu-id="5a912-105">Each functional component is presented in an easy-to-understand manner.</span></span>

## <a name="execution-overview"></a><span data-ttu-id="5a912-106">Información general sobre la ejecución</span><span class="sxs-lookup"><span data-stu-id="5a912-106">Execution Overview</span></span>

<span data-ttu-id="5a912-107">En una aplicación de ThreadX SMP hay cuatro tipos de ejecución de programas: inicialización, ejecución de subprocesos, rutinas de servicio de interrupción (ISR) y temporizadores de aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-107">There are four types of program execution within a ThreadX SMP application: Initialization, Thread Execution, Interrupt Service Routines (ISRs), and Application Timers.</span></span>

<span data-ttu-id="5a912-108">En la figura 1 de la página 45 se muestra cada tipo de ejecución de programas.</span><span class="sxs-lookup"><span data-stu-id="5a912-108">Figure 1 on page 45 shows each different type of program execution.</span></span> <span data-ttu-id="5a912-109">En las secciones siguientes de este capítulo se ofrece información más detallada sobre cada uno de estos tipos.</span><span class="sxs-lookup"><span data-stu-id="5a912-109">More detailed information about each of these types is found in subsequent sections of this chapter.</span></span>

### <a name="initialization"></a><span data-ttu-id="5a912-110">Inicialización</span><span class="sxs-lookup"><span data-stu-id="5a912-110">Initialization</span></span>
<span data-ttu-id="5a912-111">Como su nombre indica, este es el primer tipo de ejecución de programas de una aplicación de ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="5a912-111">As the name implies, this is the first type of program execution in a ThreadX SMP application.</span></span> <span data-ttu-id="5a912-112">La inicialización incluye toda la ejecución de programas entre el restablecimiento del procesador y el punto de entrada del *bucle de programación de subprocesos*.</span><span class="sxs-lookup"><span data-stu-id="5a912-112">Initialization includes all program execution between processor reset and the entry point of the *thread scheduling loop.*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5a912-113">El núcleo 0, que es el núcleo que se ejecuta de manera predeterminada después del restablecimiento, es el que realiza o inicia la inicialización.</span><span class="sxs-lookup"><span data-stu-id="5a912-113">Initialization is performed by or initiated by core 0, which is the default running core after reset.</span></span>

### <a name="thread-execution"></a><span data-ttu-id="5a912-114">Ejecución de subprocesos</span><span class="sxs-lookup"><span data-stu-id="5a912-114">Thread Execution</span></span>
<span data-ttu-id="5a912-115">Una vez completada la inicialización, cada núcleo que ejecuta ThreadX SMP inicia su bucle de programación de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="5a912-115">After initialization is complete, each core running ThreadX SMP enters its thread scheduling loop.</span></span> <span data-ttu-id="5a912-116">El bucle de programación busca un subproceso de aplicación listo para ejecutarse en ese núcleo.</span><span class="sxs-lookup"><span data-stu-id="5a912-116">The scheduling loop looks for an application thread ready for execution on that core.</span></span> <span data-ttu-id="5a912-117">Cuando encuentra un subproceso preparado, ThreadX SMP le transfiere el control.</span><span class="sxs-lookup"><span data-stu-id="5a912-117">When a ready thread is found, ThreadX SMP transfers control to it.</span></span> <span data-ttu-id="5a912-118">Cuando termina el subproceso (o hay otro subproceso de mayor prioridad preparado), la ejecución se vuelve a transferir al bucle de programación de subprocesos a fin de encontrar el siguiente subproceso listo de mayor prioridad en cada núcleo.</span><span class="sxs-lookup"><span data-stu-id="5a912-118">After the thread is finished (or another higher-priority thread becomes ready), execution transfers back to the thread scheduling loop to find the next highest priority ready thread on each core.</span></span>

<span data-ttu-id="5a912-119">Este proceso de ejecución y programación continuas de subprocesos es el tipo más común de ejecución de programas en las aplicaciones de ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="5a912-119">This process of continually executing and scheduling threads is the most common type of program execution in ThreadX SMP applications.</span></span>

![Ejecución de subprocesos](media/image4.png)

<span data-ttu-id="5a912-121">**FIGURA 1. Tipos de ejecución de programas**</span><span class="sxs-lookup"><span data-stu-id="5a912-121">**FIGURE 1. Types of Program Execution**</span></span>

### <a name="interrupt-service-routines-isr"></a><span data-ttu-id="5a912-122">Rutinas de servicio de interrupción (ISR)</span><span class="sxs-lookup"><span data-stu-id="5a912-122">Interrupt Service Routines (ISR)</span></span>
<span data-ttu-id="5a912-123">Las interrupciones son la piedra angular de los sistemas en tiempo real.</span><span class="sxs-lookup"><span data-stu-id="5a912-123">Interrupts are the cornerstone of real-time systems.</span></span> <span data-ttu-id="5a912-124">Sin interrupciones, sería extremadamente difícil responder a los cambios en el mundo exterior de manera oportuna.</span><span class="sxs-lookup"><span data-stu-id="5a912-124">Without interrupts it would be extremely difficult to respond to changes in the external world in a timely manner.</span></span> <span data-ttu-id="5a912-125">Al detectar una interrupción, el procesador guarda información clave sobre la ejecución de programas actual (normalmente en la pila) y transfiere el control a un área de programas predefinida.</span><span class="sxs-lookup"><span data-stu-id="5a912-125">On detection of an interrupt, the processor saves key information about the current program execution (usually on the stack), then transfers control to a predefined program area.</span></span> <span data-ttu-id="5a912-126">Esta área de programas predefinida suele recibir el nombre de rutina de servicio de interrupción.</span><span class="sxs-lookup"><span data-stu-id="5a912-126">This predefined program area is commonly called an Interrupt Service Routine.</span></span>

<span data-ttu-id="5a912-127">En la mayoría de los casos, las interrupciones se producen durante la ejecución de subprocesos (o en el bucle de programación de subprocesos).</span><span class="sxs-lookup"><span data-stu-id="5a912-127">In most cases, interrupts occur during thread execution (or in the thread scheduling loop).</span></span> <span data-ttu-id="5a912-128">Pero también pueden producirse dentro de una ISR en ejecución o un temporizador de aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-128">However, interrupts may also occur inside of an executing ISR or an Application Timer.</span></span>

<span data-ttu-id="5a912-129">Todos los núcleos pueden procesar interrupciones.</span><span class="sxs-lookup"><span data-stu-id="5a912-129">All cores are allowed to process interrupts.</span></span> <span data-ttu-id="5a912-130">La asignación de interrupciones a los núcleos se produce bajo el control directo de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-130">The mapping of interrupts to cores is under the direct control of the application.</span></span> <span data-ttu-id="5a912-131">La interrupción del temporizador de ThreadX SMP se asigna de manera predeterminada al núcleo 0 para su procesamiento.</span><span class="sxs-lookup"><span data-stu-id="5a912-131">The ThreadX SMP timer interrupt is by default assigned to core 0 for processing.</span></span> <span data-ttu-id="5a912-132">Revise el código de *tx_timer_interrupt.S* para ver la implementación de esta asignación.</span><span class="sxs-lookup"><span data-stu-id="5a912-132">Please see the code in *tx_timer_interrupt.S* for implementation of this assignment.</span></span>

### <a name="application-timers"></a><span data-ttu-id="5a912-133">Temporizadores de aplicación</span><span class="sxs-lookup"><span data-stu-id="5a912-133">Application Timers</span></span>
<span data-ttu-id="5a912-134">Los temporizadores de aplicación son similares a las ISR, aunque la implementación de hardware (normalmente se usa una sola interrupción de hardware periódica) se oculta a la aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-134">Application Timers are similar to ISRs, except the hardware implementation (usually a single periodic hardware interrupt is used) is hidden from the application.</span></span> <span data-ttu-id="5a912-135">Las aplicaciones emplean estos temporizadores para ejecutar tiempos de espera, servicios periódicos o de guardián.</span><span class="sxs-lookup"><span data-stu-id="5a912-135">Such timers are used by applications to perform time-outs, periodics, and/or watchdog services.</span></span> <span data-ttu-id="5a912-136">Al igual que las ISR, los temporizadores de aplicación suelen interrumpir la ejecución de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="5a912-136">Just like ISRs, Application Timers most often interrupt thread execution.</span></span> <span data-ttu-id="5a912-137">Pero a diferencia de las ISR, los temporizadores de aplicación no se pueden interrumpir entre sí.</span><span class="sxs-lookup"><span data-stu-id="5a912-137">Unlike ISRs, however, Application Timers cannot interrupt each other.</span></span>

> [!NOTE]
> <span data-ttu-id="5a912-138">Así, como los subprocesos, los temporizadores de aplicación se pueden excluir de la ejecución en cualquier núcleo.</span><span class="sxs-lookup"><span data-stu-id="5a912-138">That like threads, application timers can be excluded from execution on any core.</span></span>

## <a name="memory-usage"></a><span data-ttu-id="5a912-139">Uso de la memoria</span><span class="sxs-lookup"><span data-stu-id="5a912-139">Memory Usage</span></span>

<span data-ttu-id="5a912-140">ThreadX SMP reside con el programa de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-140">ThreadX SMP resides along with the application program.</span></span> <span data-ttu-id="5a912-141">Por eso, el uso de memoria estática (o memoria fija) de ThreadX SMP viene determinado por las herramientas de desarrollo, por ejemplo, el compilador, el enlazador y el localizador.</span><span class="sxs-lookup"><span data-stu-id="5a912-141">As a result, the static memory (or fixed memory) usage of ThreadX SMP is determined by the development tools; e.g., the compiler, linker, and locator.</span></span> <span data-ttu-id="5a912-142">El uso de memoria dinámica (o memoria en tiempo de ejecución) está bajo el control directo de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-142">Dynamic memory (or run-time memory) usage is under direct control of the application.</span></span>

> [!NOTE]
> <span data-ttu-id="5a912-143">Toda la memoria a la que accede ThreadX SMP debe ser coherente con la caché y accesible desde todos los núcleos que ejecutan ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="5a912-143">All the memory accessed by ThreadX SMP must be cache coherent and accessible from all cores executing ThreadX SMP.</span></span>

### <a name="static-memory-usage"></a><span data-ttu-id="5a912-144">Uso de memoria estática</span><span class="sxs-lookup"><span data-stu-id="5a912-144">Static Memory Usage</span></span>
<span data-ttu-id="5a912-145">La mayoría de las herramientas de desarrollo dividen la imagen del programa de la aplicación en cinco áreas básicas: *instrucciones*, *constantes*, *datos inicializados*, *datos sin inicializar* y *pila del sistema*.</span><span class="sxs-lookup"><span data-stu-id="5a912-145">Most of the development tools divide the application program image into five basic areas: *instruction*, *constant*, *initialized data*, *uninitialized data*, and *system stack*.</span></span> <span data-ttu-id="5a912-146">En la figura 2 de la página 47 se muestra un ejemplo de estas áreas de memoria.</span><span class="sxs-lookup"><span data-stu-id="5a912-146">Figure 2 on page 47 shows an example of these memory areas.</span></span>

![Uso de memoria estática](media/image5.png)

<span data-ttu-id="5a912-148">**FIGURA 2. Ejemplo de área de memoria**</span><span class="sxs-lookup"><span data-stu-id="5a912-148">**FIGURE 2. Memory Area Example**</span></span>

<span data-ttu-id="5a912-149">Es importante entender que se trata solo de un ejemplo.</span><span class="sxs-lookup"><span data-stu-id="5a912-149">It is important to understand that this is only an example.</span></span> <span data-ttu-id="5a912-150">El diseño de memoria estática real es específico del procesador, las herramientas de desarrollo y el hardware subyacente.</span><span class="sxs-lookup"><span data-stu-id="5a912-150">The actual static memory layout is specific to the processor, development tools, and the underlying hardware.</span></span>

<span data-ttu-id="5a912-151">El área de instrucciones contiene todas las instrucciones del procesador del programa.</span><span class="sxs-lookup"><span data-stu-id="5a912-151">The instruction area contains all of the program’s processor instructions.</span></span> <span data-ttu-id="5a912-152">Normalmente esta área es la más grande y suele encontrarse en la ROM.</span><span class="sxs-lookup"><span data-stu-id="5a912-152">This area is typically the largest and is often located in ROM.</span></span>

<span data-ttu-id="5a912-153">El área de constantes contiene varias constantes compiladas, incluidas las cadenas definidas o a las que se hace referencia en el programa.</span><span class="sxs-lookup"><span data-stu-id="5a912-153">The constant area contains various compiled constants, including strings defined or referenced within the program.</span></span> <span data-ttu-id="5a912-154">Además, esta área contiene la "copia inicial" del área de datos inicializados.</span><span class="sxs-lookup"><span data-stu-id="5a912-154">In addition, this area contains the “initial copy” of the initialized data area.</span></span> <span data-ttu-id="5a912-155">Durante el proceso de inicialización del compilador, esta parte del área de constantes se usa para configurar el área de datos inicializados en la RAM.</span><span class="sxs-lookup"><span data-stu-id="5a912-155">During the compiler’s initialization process, this portion of the constant area is used to set up the initialized data area in RAM.</span></span> <span data-ttu-id="5a912-156">El área de constantes suele seguir al área de instrucciones y encontrarse en la ROM.</span><span class="sxs-lookup"><span data-stu-id="5a912-156">The constant area usually follows the instruction area and is often located in ROM.</span></span>

<span data-ttu-id="5a912-157">Las áreas de datos inicializados y sin inicializar contienen todas las variables globales y estáticas.</span><span class="sxs-lookup"><span data-stu-id="5a912-157">The initialized data and uninitialized data areas contain all of the global and static variables.</span></span> <span data-ttu-id="5a912-158">Estas áreas siempre se encuentran en la RAM.</span><span class="sxs-lookup"><span data-stu-id="5a912-158">These areas are always located in RAM.</span></span>

<span data-ttu-id="5a912-159">La pila del sistema suele configurarse inmediatamente detrás de las áreas de datos inicializados y sin inicializar.</span><span class="sxs-lookup"><span data-stu-id="5a912-159">The system stack is generally set up immediately following the initialized and uninitialized data areas.</span></span> <span data-ttu-id="5a912-160">El compilador usa la pila del sistema durante la inicialización, luego la emplea ThreadX SMP también durante la inicialización y, posteriormente, durante el procesamiento de ISR.</span><span class="sxs-lookup"><span data-stu-id="5a912-160">The system stack is used by the compiler during initialization, then by ThreadX SMP during initialization and, subsequently, in ISR processing.</span></span>

### <a name="dynamic-memory-usage"></a><span data-ttu-id="5a912-161">Uso de memoria dinámica</span><span class="sxs-lookup"><span data-stu-id="5a912-161">Dynamic Memory Usage</span></span>
<span data-ttu-id="5a912-162">Como se ha mencionado antes, el uso de memoria dinámica está bajo el control directo de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-162">As mentioned before, dynamic memory usage is under direct control of the application.</span></span> <span data-ttu-id="5a912-163">Los bloques de control y las áreas de memoria asociados a pilas, colas y grupos de memoria se pueden colocar en cualquier ubicación del espacio de memoria del destino.</span><span class="sxs-lookup"><span data-stu-id="5a912-163">Control blocks and memory areas associated with stacks, queues, and memory pools can be placed anywhere in the target’s memory space.</span></span> <span data-ttu-id="5a912-164">Se trata de una característica importante, ya que facilita el uso de diferentes tipos de memoria física.</span><span class="sxs-lookup"><span data-stu-id="5a912-164">This is an important feature because it facilitates easy utilization of different types of physical memory.</span></span>

<span data-ttu-id="5a912-165">Por ejemplo, imagine que un entorno de hardware de destino tiene memoria rápida y memoria lenta.</span><span class="sxs-lookup"><span data-stu-id="5a912-165">For example, suppose a target hardware environment has both fast memory and slow memory.</span></span> <span data-ttu-id="5a912-166">Si la aplicación necesita rendimiento adicional para un subproceso de alta prioridad, su bloque de control (TX_THREAD) y la pila se pueden colocar en el área de memoria rápida, lo que puede mejorar considerablemente el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="5a912-166">If the application needs extra performance for a high-priority thread, its control block (TX_THREAD) and stack can be placed in the fast memory area, which may greatly enhance its performance.</span></span>

## <a name="initialization"></a><span data-ttu-id="5a912-167">Inicialización</span><span class="sxs-lookup"><span data-stu-id="5a912-167">Initialization</span></span> 
<span data-ttu-id="5a912-168">Es importante entender el proceso de inicialización.</span><span class="sxs-lookup"><span data-stu-id="5a912-168">Understanding the initialization process is important.</span></span> <span data-ttu-id="5a912-169">Aquí se configura el entorno de hardware inicial.</span><span class="sxs-lookup"><span data-stu-id="5a912-169">The initial hardware environment is set up here.</span></span> <span data-ttu-id="5a912-170">Además, aquí es donde se proporciona a la aplicación su personalidad inicial.</span><span class="sxs-lookup"><span data-stu-id="5a912-170">In addition, this is where the application is given its initial personality.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5a912-171">ThreadX SMP intenta usar (siempre que sea posible) el proceso de inicialización completo de la herramienta de desarrollo.</span><span class="sxs-lookup"><span data-stu-id="5a912-171">ThreadX SMP attempts to utilize (whenever possible) the complete development tool’s initialization process.</span></span> <span data-ttu-id="5a912-172">Esto facilita la actualización a nuevas versiones de las herramientas de desarrollo en el futuro.</span><span class="sxs-lookup"><span data-stu-id="5a912-172">This makes it easier to upgrade to new versions of the development tools in the future.</span></span>

### <a name="system-reset-vector"></a><span data-ttu-id="5a912-173">Vector de restablecimiento del sistema</span><span class="sxs-lookup"><span data-stu-id="5a912-173">System Reset Vector</span></span> 
<span data-ttu-id="5a912-174">Todos los microprocesadores tienen lógica de restablecimiento.</span><span class="sxs-lookup"><span data-stu-id="5a912-174">All microprocessors have reset logic.</span></span> <span data-ttu-id="5a912-175">Cuando se produce un restablecimiento (ya sea de hardware o software), la dirección del punto de entrada de la aplicación se recupera desde una ubicación de memoria concreta.</span><span class="sxs-lookup"><span data-stu-id="5a912-175">When a reset occurs (either hardware or software), the address of the application’s entry point is retrieved from a specific memory location.</span></span> <span data-ttu-id="5a912-176">Una vez recuperado el punto de entrada, el procesador transfiere el control a esa ubicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-176">After the entry point is retrieved, the processor transfers control to that location.</span></span> 

<span data-ttu-id="5a912-177">El punto de entrada de la aplicación suele escribirse en el lenguaje de ensamblado nativo y, normalmente, lo suministran las herramientas de desarrollo (al menos en formato de plantilla).</span><span class="sxs-lookup"><span data-stu-id="5a912-177">The application entry point is quite often written in the native assembly language and is usually supplied by the development tools (at least in template form).</span></span> <span data-ttu-id="5a912-178">En algunos casos se proporciona una versión especial del programa de entrada con ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="5a912-178">In some cases, a special version of the entry program is supplied with ThreadX SMP.</span></span> 

### <a name="development-tool-initialization"></a><span data-ttu-id="5a912-179">Inicialización de la herramienta de desarrollo</span><span class="sxs-lookup"><span data-stu-id="5a912-179">Development Tool Initialization</span></span>
<span data-ttu-id="5a912-180">Una vez completada la inicialización de bajo nivel, el control se transfiere a la inicialización de alto nivel de la herramienta de desarrollo.</span><span class="sxs-lookup"><span data-stu-id="5a912-180">After the low-level initialization is complete, control transfers to the development tool’s high-level initialization.</span></span> <span data-ttu-id="5a912-181">Esta suele ser la ubicación en la que se configuran las variables inicializadas globales y estáticas de C.</span><span class="sxs-lookup"><span data-stu-id="5a912-181">This is usually the place where initialized global and static C variables are set up.</span></span> <span data-ttu-id="5a912-182">Recuerde que sus valores iniciales se recuperan del área de constantes.</span><span class="sxs-lookup"><span data-stu-id="5a912-182">Remember their initial values are retrieved from the constant area.</span></span> <span data-ttu-id="5a912-183">El procesamiento de inicialización exacto es específico de la herramienta de desarrollo.</span><span class="sxs-lookup"><span data-stu-id="5a912-183">Exact initialization processing is development tool specific.</span></span>

### <a name="main-function"></a><span data-ttu-id="5a912-184">main (función)</span><span class="sxs-lookup"><span data-stu-id="5a912-184">main Function</span></span> 
<span data-ttu-id="5a912-185">Una vez que se completa la inicialización de la herramienta de desarrollo, el control se transfiere a la función *main* proporcionada por el usuario.</span><span class="sxs-lookup"><span data-stu-id="5a912-185">When the development tool initialization is complete, control transfers to the user-supplied *main* function.</span></span> <span data-ttu-id="5a912-186">En este punto, la aplicación controla lo que ocurre a continuación.</span><span class="sxs-lookup"><span data-stu-id="5a912-186">At this point, the application controls what happens next.</span></span> <span data-ttu-id="5a912-187">En la mayoría de las aplicaciones, la función main simplemente llama a *tx_kernel_enter*, que es la entrada a ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="5a912-187">For most applications, the main function simply calls *tx_kernel_enter*, which is the entry into ThreadX SMP.</span></span> <span data-ttu-id="5a912-188">Pero las aplicaciones pueden realizar el procesamiento preliminar (normalmente para la inicialización de hardware) antes de entrar en ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="5a912-188">However, applications can perform preliminary processing (usually for hardware initialization) prior to entering ThreadX SMP.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5a912-189">La llamada a tx_kernel_enter no devuelve valores, así que no coloque ningún procesamiento después.</span><span class="sxs-lookup"><span data-stu-id="5a912-189">The call to tx_kernel_enter does not return, so do not place any processing after it!</span></span>

### <a name="tx_kernel_enter"></a><span data-ttu-id="5a912-190">tx_kernel_enter</span><span class="sxs-lookup"><span data-stu-id="5a912-190">tx_kernel_enter</span></span> 
<span data-ttu-id="5a912-191">La función de entrada coordina la inicialización de varias estructuras de datos internas de ThreadX SMP y, después, llama a la función de definición de la aplicación *tx_application_define*.</span><span class="sxs-lookup"><span data-stu-id="5a912-191">The entry function coordinates initialization of various internal ThreadX SMP data structures and then calls the application’s definition function *tx_application_define*.</span></span>

<span data-ttu-id="5a912-192">Cuando *tx_application_define* devuelve un valor, el control se transfiere al bucle de programación de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="5a912-192">When *tx_application_define* returns, control is transferred to the thread scheduling loop.</span></span> <span data-ttu-id="5a912-193">Esto marca el final de la inicialización.</span><span class="sxs-lookup"><span data-stu-id="5a912-193">This marks the end of initialization!</span></span>

### <a name="application-definition-function"></a><span data-ttu-id="5a912-194">Función de definición de aplicación</span><span class="sxs-lookup"><span data-stu-id="5a912-194">Application Definition Function</span></span>
<span data-ttu-id="5a912-195">La función *tx_application_define* define todos los subprocesos, las colas, los semáforos, las exclusiones mutuas, las marcas de eventos, los grupos de memoria y los temporizadores iniciales de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-195">The *tx_application_define* function defines all of the initial application threads, queues, semaphores, mutexes, event flags, memory pools, and timers.</span></span> <span data-ttu-id="5a912-196">También es posible crear y eliminar recursos del sistema desde subprocesos durante el funcionamiento normal de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-196">It is also possible to create and delete system resources from threads during the normal operation of the application.</span></span> <span data-ttu-id="5a912-197">Pero aquí se definen todos los recursos iniciales de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-197">However, all initial application resources are defined here.</span></span>

<span data-ttu-id="5a912-198">La función *tx_application_define* tiene un único parámetro de entrada que merece la pena mencionar.</span><span class="sxs-lookup"><span data-stu-id="5a912-198">The *tx_application_define* function has a single input parameter and it is certainly worth mentioning.</span></span> <span data-ttu-id="5a912-199">La dirección RAM *first-available* es el único parámetro de entrada de esta función.</span><span class="sxs-lookup"><span data-stu-id="5a912-199">The *first-available* RAM address is the sole input parameter to this function.</span></span> <span data-ttu-id="5a912-200">Normalmente se usa como punto de partida de las asignaciones de memoria iniciales en tiempo de ejecución de pilas de subprocesos, colas y grupos de memoria.</span><span class="sxs-lookup"><span data-stu-id="5a912-200">It is typically used as a starting point for initial run-time memory allocations of thread stacks, queues, and memory pools.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5a912-201">Una vez completada la inicialización, solo un subproceso en ejecución puede crear y eliminar recursos del sistema, incluidos otros subprocesos.</span><span class="sxs-lookup"><span data-stu-id="5a912-201">After initialization is complete, only an executing thread can create and delete system resources—including other threads.</span></span> <span data-ttu-id="5a912-202">Por lo tanto, se debe crear al menos un subproceso durante la inicialización.</span><span class="sxs-lookup"><span data-stu-id="5a912-202">Therefore, at least one thread must be created during initialization.</span></span>

### <a name="interrupts"></a><span data-ttu-id="5a912-203">Interrupciones</span><span class="sxs-lookup"><span data-stu-id="5a912-203">Interrupts</span></span> 
<span data-ttu-id="5a912-204">Las interrupciones se dejan deshabilitadas durante todo el proceso de inicialización.</span><span class="sxs-lookup"><span data-stu-id="5a912-204">Interrupts are left disabled during the entire initialization process.</span></span> <span data-ttu-id="5a912-205">Si la aplicación habilita las interrupciones de alguna manera, se puede producir un comportamiento impredecible.</span><span class="sxs-lookup"><span data-stu-id="5a912-205">If the application somehow enables interrupts, unpredictable behavior may occur.</span></span> <span data-ttu-id="5a912-206">En la figura 3 de la página 52 se muestra el proceso de inicialización completo, desde el restablecimiento del sistema hasta la inicialización específica de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-206">Figure 3 on page 52 shows the entire initialization process, from system reset through application-specific initialization.</span></span>

## <a name="thread-execution"></a><span data-ttu-id="5a912-207">Ejecución de subprocesos</span><span class="sxs-lookup"><span data-stu-id="5a912-207">Thread Execution</span></span>

<span data-ttu-id="5a912-208">La programación y ejecución de subprocesos de aplicación es la actividad más importante de ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="5a912-208">Scheduling and executing application threads is the most important activity of ThreadX SMP.</span></span> <span data-ttu-id="5a912-209">Un subproceso se suele definir como un segmento de programa semiindependiente con un fin específico.</span><span class="sxs-lookup"><span data-stu-id="5a912-209">A thread is typically defined as a semi-independent program segment with a dedicated purpose.</span></span> <span data-ttu-id="5a912-210">El procesamiento combinado de todos los subprocesos crea una aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-210">The combined processing of all threads makes an application.</span></span>

<span data-ttu-id="5a912-211">Los subprocesos se crean de forma dinámica mediante una llamada a *tx_thread_create* durante la inicialización o la ejecución de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="5a912-211">Threads are created dynamically by calling *tx_thread_create* during initialization or during thread execution.</span></span> <span data-ttu-id="5a912-212">Los subprocesos se crean en un estado *listo* o *suspendido*.</span><span class="sxs-lookup"><span data-stu-id="5a912-212">Threads are created in either a *ready* or *suspended* state.</span></span>

![Proceso de inicialización de SMP](media/image6.png)

<span data-ttu-id="5a912-214">**FIGURA 3. Proceso de inicialización de SMP**</span><span class="sxs-lookup"><span data-stu-id="5a912-214">**FIGURE 3. SMP Initialization Process**</span></span>

### <a name="thread-execution-states"></a><span data-ttu-id="5a912-215">Estados de ejecución de subprocesos</span><span class="sxs-lookup"><span data-stu-id="5a912-215">Thread Execution States</span></span>  
<span data-ttu-id="5a912-216">La comprensión de los distintos estados de procesamiento de los subprocesos es clave para entender todo el entorno multiproceso.</span><span class="sxs-lookup"><span data-stu-id="5a912-216">Understanding the different processing states of threads is a key ingredient to understanding the entire multithreaded environment.</span></span> <span data-ttu-id="5a912-217">En ThreadX SMP hay cinco estados de subproceso distintos: *listo*, *suspendido*, *en ejecución*, *terminado* y *completado*.</span><span class="sxs-lookup"><span data-stu-id="5a912-217">In ThreadX SMP, there are five distinct thread states: *ready*, *suspended*, *executing*, *terminated*, and *completed*.</span></span> <span data-ttu-id="5a912-218">En la figura 4 se muestra el diagrama de transición de estado de subprocesos de ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="5a912-218">Figure 4 shows the thread state transition diagram for ThreadX SMP.</span></span>

![Estados de ejecución de subprocesos](media/image7.png)

<span data-ttu-id="5a912-220">**FIGURA 4. Transición de estado de subprocesos**</span><span class="sxs-lookup"><span data-stu-id="5a912-220">**FIGURE 4. Thread State Transition**</span></span>

<span data-ttu-id="5a912-221">Un subproceso está en estado *listo* cuando está preparado para ejecutarse.</span><span class="sxs-lookup"><span data-stu-id="5a912-221">A thread is in a *ready* state when it is ready for execution.</span></span> <span data-ttu-id="5a912-222">Un subproceso listo no se ejecuta hasta que es el subproceso de mayor prioridad en estado listo.</span><span class="sxs-lookup"><span data-stu-id="5a912-222">A ready thread is not executed until it is the highest priority thread in ready state.</span></span> <span data-ttu-id="5a912-223">Cuando esto sucede, ThreadX SMP ejecuta el subproceso, que cambia su estado a *en ejecución*.</span><span class="sxs-lookup"><span data-stu-id="5a912-223">When this happens, ThreadX SMP executes the thread, which then changes its state to *executing*.</span></span>

<span data-ttu-id="5a912-224">Si hay un subproceso de mayor prioridad preparado, el subproceso en ejecución vuelve a un estado *listo*.</span><span class="sxs-lookup"><span data-stu-id="5a912-224">If a higher-priority thread becomes ready, the executing thread reverts back to a *ready* state.</span></span> <span data-ttu-id="5a912-225">Después se ejecuta el subproceso de alta prioridad recién preparado, que cambia su estado lógico a *en ejecución*.</span><span class="sxs-lookup"><span data-stu-id="5a912-225">The newly ready high-priority thread is then executed, which changes its logical state to *executing*.</span></span> <span data-ttu-id="5a912-226">Esta transición entre los estados *listo* y *en ejecución* se produce cada vez que tiene lugar el adelantamiento de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="5a912-226">This transition between *ready* and *executing* states occurs every time thread preemption occurs.</span></span>

<span data-ttu-id="5a912-227">En cualquier momento dado solo hay un subproceso en estado *en ejecución*.</span><span class="sxs-lookup"><span data-stu-id="5a912-227">At any given moment, only one thread is in an *executing* state.</span></span> <span data-ttu-id="5a912-228">Esto se debe a que un subproceso en el estado *en ejecución* tiene el control del procesador subyacente.</span><span class="sxs-lookup"><span data-stu-id="5a912-228">This is because a thread in the *executing* state has control of the underlying processor.</span></span>

<span data-ttu-id="5a912-229">Los subprocesos en estado *suspendido* no son aptos para ejecutarse.</span><span class="sxs-lookup"><span data-stu-id="5a912-229">Threads in a *suspended* state are not eligible for execution.</span></span> <span data-ttu-id="5a912-230">Entre los motivos para estar en estado *suspendido* se incluyen la suspensión por tiempo, mensajes de cola, semáforos, exclusiones mutuas, marcas de eventos, memoria y suspensión básica de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="5a912-230">Reasons for being in a *suspended* state include suspension for time, queue messages, semaphores, mutexes, event flags, memory, and basic thread suspension.</span></span> <span data-ttu-id="5a912-231">Una vez que se elimina la causa de la suspensión, el subproceso se vuelve a colocar en estado *listo*.</span><span class="sxs-lookup"><span data-stu-id="5a912-231">After the cause for suspension is removed, the thread is placed back in a *ready* state.</span></span>

<span data-ttu-id="5a912-232">Un subproceso en estado *completado* es el que ha completado su procesamiento y se ha devuelto desde su función de entrada.</span><span class="sxs-lookup"><span data-stu-id="5a912-232">A thread in a *completed* state is a thread that has completed its processing and returned from its entry function.</span></span> <span data-ttu-id="5a912-233">La función de entrada se especifica durante la creación del subproceso.</span><span class="sxs-lookup"><span data-stu-id="5a912-233">The entry function is specified during thread creation.</span></span> <span data-ttu-id="5a912-234">No se puede volver a ejecutar un subproceso en estado *completado*.</span><span class="sxs-lookup"><span data-stu-id="5a912-234">A thread in a *completed* state cannot execute again.</span></span>

<span data-ttu-id="5a912-235">Un subproceso está en estado *terminado* porque él mismo u otro subproceso ha llamado al servicio *tx_thread_terminate*.</span><span class="sxs-lookup"><span data-stu-id="5a912-235">A thread is in a *terminated* state because another thread or the thread itself called the *tx_thread_terminate* service.</span></span> <span data-ttu-id="5a912-236">Un subproceso en estado *terminado* no se puede volver a ejecutar.</span><span class="sxs-lookup"><span data-stu-id="5a912-236">A thread in a *terminated* state cannot execute again.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5a912-237">Si se quiere volver a iniciar un subproceso completado o terminado, la aplicación primero debe eliminarlo.</span><span class="sxs-lookup"><span data-stu-id="5a912-237">If re-starting a completed or terminated thread is desired, the application must first delete the thread.</span></span> <span data-ttu-id="5a912-238">Después se puede volver a crear y reiniciar.</span><span class="sxs-lookup"><span data-stu-id="5a912-238">It can then be re-created and re-started.</span></span>

### <a name="thread-entryexit-notification"></a><span data-ttu-id="5a912-239">Notificación de entrada o salida de subprocesos</span><span class="sxs-lookup"><span data-stu-id="5a912-239">Thread Entry/Exit Notification</span></span>  
<span data-ttu-id="5a912-240">A algunas aplicaciones les puede interesar recibir una notificación cuando se inicia por primera vez un subproceso concreto, cuando se completa o cuando se termina.</span><span class="sxs-lookup"><span data-stu-id="5a912-240">Some applications may find it advantageous to be notified when a specific thread is entered for the first time, when it completes, or is terminated.</span></span> <span data-ttu-id="5a912-241">ThreadX SMP ofrece esta posibilidad por medio del servicio *tx_thread_entry_exit_notify*.</span><span class="sxs-lookup"><span data-stu-id="5a912-241">ThreadX SMP provides this ability through the *tx_thread_entry_exit_notify* service.</span></span> <span data-ttu-id="5a912-242">Este servicio registra una función de notificación de aplicación de un subproceso concreto, al que ThreadX SMP llama cada vez que el subproceso empieza a ejecutarse, se completa o termina.</span><span class="sxs-lookup"><span data-stu-id="5a912-242">This service registers an application notification function for a specific thread, which is called by ThreadX SMP whenever the thread starts running, completes, or is terminated.</span></span> <span data-ttu-id="5a912-243">Después de invocarse, la función de notificación de la aplicación puede realizar el procesamiento específico de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-243">After being invoked, the application notification function can perform the applicationspecific processing.</span></span> <span data-ttu-id="5a912-244">Normalmente, esto implica informar a otro subproceso de aplicación del evento por medio de un primitivo de sincronización de ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="5a912-244">This typically involves informing another application thread of the event via a ThreadX SMP synchronization primitive.</span></span>

### <a name="thread-priorities"></a><span data-ttu-id="5a912-245">Prioridades de subprocesos</span><span class="sxs-lookup"><span data-stu-id="5a912-245">Thread Priorities</span></span>  
<span data-ttu-id="5a912-246">Como se ha mencionado antes, un subproceso es un segmento de programa semiindependiente con un fin concreto.</span><span class="sxs-lookup"><span data-stu-id="5a912-246">As mentioned before, a thread is a semi-independent program segment with a dedicated purpose.</span></span> <span data-ttu-id="5a912-247">Pero no todos los subprocesos se crean de la misma forma.</span><span class="sxs-lookup"><span data-stu-id="5a912-247">However, all threads are not created equal!</span></span> <span data-ttu-id="5a912-248">El fin concreto de algunos subprocesos es mucho más importante que el de otros.</span><span class="sxs-lookup"><span data-stu-id="5a912-248">The dedicated purpose of some threads is much more important than others.</span></span> <span data-ttu-id="5a912-249">Este tipo heterogéneo de importancia de los subprocesos es un sello de las aplicaciones insertadas en tiempo real.</span><span class="sxs-lookup"><span data-stu-id="5a912-249">This heterogeneous type of thread importance is a hallmark of embedded realtime applications.</span></span>

<span data-ttu-id="5a912-250">ThreadX SMP determina la importancia de un subproceso cuando se crea este mediante la asignación de un valor numérico que representa su *prioridad*.</span><span class="sxs-lookup"><span data-stu-id="5a912-250">ThreadX SMP determines a thread’s importance when the thread is created by assigning a numerical value representing its *priority*.</span></span> <span data-ttu-id="5a912-251">El número máximo de prioridades de ThreadX SMP se puede configurar de 32 a 1024 en incrementos de 32.</span><span class="sxs-lookup"><span data-stu-id="5a912-251">The maximum number of ThreadX SMP priorities is configurable from 32 through 1024 in increments of 32.</span></span> <span data-ttu-id="5a912-252">El número máximo real de prioridades viene determinado por la constante *TX_MAX_PRIORITIES* durante la compilación de la biblioteca de ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="5a912-252">The actual maximum number of priorities is determined by the *TX_MAX_PRIORITIES* constant during compilation of the ThreadX SMP library.</span></span> <span data-ttu-id="5a912-253">Tener un número mayor de prioridades no aumenta significativamente la sobrecarga de procesamiento.</span><span class="sxs-lookup"><span data-stu-id="5a912-253">Having a larger number of priorities does not significantly increase processing overhead.</span></span> <span data-ttu-id="5a912-254">Pero para cada grupo de 32 niveles de prioridad se necesitan 128 bytes de RAM adicionales a fin de administrarlos.</span><span class="sxs-lookup"><span data-stu-id="5a912-254">However, for each group of 32 priority levels an additional 128 bytes of RAM is required to manage them.</span></span> <span data-ttu-id="5a912-255">Por ejemplo, 32 niveles de prioridad necesitan 128 bytes de RAM, 64 niveles de prioridad necesitan 256 bytes de RAM y 96 niveles de prioridad necesitan 384 bytes de RAM.</span><span class="sxs-lookup"><span data-stu-id="5a912-255">For example, 32 priority levels require 128 bytes of RAM, 64 priority levels require 256 bytes of RAM, and 96 priority levels requires 384 bytes of RAM.</span></span>

<span data-ttu-id="5a912-256">De manera predeterminada, ThreadX SMP tiene 32 niveles de prioridad, que van desde la prioridad 0 hasta la prioridad 31.</span><span class="sxs-lookup"><span data-stu-id="5a912-256">By default, ThreadX SMP has 32 priority levels, ranging from priority 0 through priority 31.</span></span>

<span data-ttu-id="5a912-257">Los valores numéricos más pequeños implican una mayor prioridad.</span><span class="sxs-lookup"><span data-stu-id="5a912-257">Numerically smaller values imply higher priority.</span></span> <span data-ttu-id="5a912-258">Por tanto, la prioridad 0 representa la prioridad más alta, mientras que la prioridad (*TX_MAX_PRIORITIES*-1) representa la más baja.</span><span class="sxs-lookup"><span data-stu-id="5a912-258">Hence, priority 0 represents the highest priority, while priority (*TX_MAX_PRIORITIES*-1) represents the lowest priority.</span></span>

<span data-ttu-id="5a912-259">Varios subprocesos pueden tener la misma prioridad, que se basa en la programación cooperativa o la segmentación temporal.</span><span class="sxs-lookup"><span data-stu-id="5a912-259">Multiple threads can have the same priority relying on cooperative scheduling or time-slicing.</span></span> <span data-ttu-id="5a912-260">Además, las prioridades de los subprocesos se pueden cambiar durante el tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="5a912-260">In addition, thread priorities can be changed during run-time.</span></span>

### <a name="thread-scheduling"></a><span data-ttu-id="5a912-261">Programación de subprocesos</span><span class="sxs-lookup"><span data-stu-id="5a912-261">Thread Scheduling</span></span> 
<span data-ttu-id="5a912-262">ThreadX SMP programa los subprocesos según su prioridad.</span><span class="sxs-lookup"><span data-stu-id="5a912-262">ThreadX SMP schedules threads based on their priority.</span></span> <span data-ttu-id="5a912-263">En primer lugar se ejecuta el subproceso listo con la prioridad más alta.</span><span class="sxs-lookup"><span data-stu-id="5a912-263">The ready thread with the highest priority is executed first.</span></span> <span data-ttu-id="5a912-264">Si hay varios subprocesos con la misma prioridad listos, se ejecutan conforme a FIFO (*el primero en entrar es el primero en salir*).</span><span class="sxs-lookup"><span data-stu-id="5a912-264">If multiple threads of the same priority are ready, they are executed in a *first-in-first-out* (FIFO) manner.</span></span>

<span data-ttu-id="5a912-265">De manera predeterminada, ThreadX SMP programa los "n" subprocesos de prioridad más alta en los "n" procesadores disponibles.</span><span class="sxs-lookup"><span data-stu-id="5a912-265">By default, ThreadX SMP schedules the “n” highest priority threads on the “n” available processors.</span></span> <span data-ttu-id="5a912-266">Si el procesamiento simultáneo solo es necesario en subprocesos listos con la misma prioridad, la biblioteca de ThreadX SMP debe compilarse con **TX_THREAD_SMP_EQUAL_PRIORITY** definido.</span><span class="sxs-lookup"><span data-stu-id="5a912-266">If concurrent processing is only required on ready threads of the same priority, the ThreadX SMP library must be built with **TX_THREAD_SMP_EQUAL_PRIORITY** defined.</span></span>

> [!NOTE]
> <span data-ttu-id="5a912-267">Todos los subprocesos pueden tener inicialmente el valor predeterminado de ejecutarse solo en el núcleo 0 si se compila la biblioteca de ThreadX SMP con **TX_THREAD_SMP_ONLY_CORE_0_DEFAULT** definido.</span><span class="sxs-lookup"><span data-stu-id="5a912-267">That all threads can be initially defaulted to only run on core 0, by building the ThreadX SMP library with **TX_THREAD_SMP_ONLY_CORE_0_DEFAULT** defined.</span></span>

### <a name="round-robin-scheduling"></a><span data-ttu-id="5a912-268">Programación round robin</span><span class="sxs-lookup"><span data-stu-id="5a912-268">Round-robin Scheduling</span></span>  
<span data-ttu-id="5a912-269">ThreadX SMP admite la programación *round robin* de varios subprocesos que tienen la misma prioridad.</span><span class="sxs-lookup"><span data-stu-id="5a912-269">ThreadX SMP supports *round-robin* scheduling of multiple threads having the same priority.</span></span> <span data-ttu-id="5a912-270">Esto se logra mediante llamadas cooperativas a *tx_thread_relinquish*.</span><span class="sxs-lookup"><span data-stu-id="5a912-270">This is accomplished through cooperative calls to *tx_thread_relinquish*.</span></span> <span data-ttu-id="5a912-271">Este servicio ofrece a todos los demás subprocesos listos con la misma prioridad la oportunidad de ejecutarse antes de que el autor de la llamada a *tx_thread_relinquish* se vuelva a ejecutar.</span><span class="sxs-lookup"><span data-stu-id="5a912-271">This service gives all other ready threads of the same priority a chance to execute before the *tx_thread_relinquish* caller executes again.</span></span>

### <a name="time-slicing"></a><span data-ttu-id="5a912-272">Segmentación temporal</span><span class="sxs-lookup"><span data-stu-id="5a912-272">Time-Slicing</span></span> 
<span data-ttu-id="5a912-273">La *segmentación temporal* es otra forma de programación round robin.</span><span class="sxs-lookup"><span data-stu-id="5a912-273">*Time-slicing* is another form of round-robin scheduling.</span></span> <span data-ttu-id="5a912-274">Un segmento temporal especifica el número máximo de tics de temporizador (interrupciones del temporizador) que un subproceso puede ejecutar sin renunciar al procesador.</span><span class="sxs-lookup"><span data-stu-id="5a912-274">A time-slice specifies the maximum number of timer ticks (timer interrupts) that a thread can execute without giving up the processor.</span></span> <span data-ttu-id="5a912-275">En ThreadX SMP, la segmentación temporal está disponible por subproceso.</span><span class="sxs-lookup"><span data-stu-id="5a912-275">In ThreadX SMP, time-slicing is available on a perthread basis.</span></span> <span data-ttu-id="5a912-276">El segmento temporal del subproceso se asigna durante la creación y se puede modificar durante el tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="5a912-276">The thread’s time-slice is assigned during creation and can be modified during run-time.</span></span> <span data-ttu-id="5a912-277">Cuando expira un segmento temporal, todos los demás subprocesos listos con el mismo nivel de prioridad tienen la oportunidad de ejecutarse antes de que se vuelva a ejecutar el subproceso con segmentación temporal.</span><span class="sxs-lookup"><span data-stu-id="5a912-277">When a time-slice expires, all other ready threads of the same priority level are given a chance to execute before the time-sliced thread executes again.</span></span>

<span data-ttu-id="5a912-278">Se asigna un nuevo segmento temporal a un subproceso después de que este se suspenda, renuncie, realice una llamada al servicio ThreadX SMP que provoque adelantamiento, o ya tenga segmentación temporal.</span><span class="sxs-lookup"><span data-stu-id="5a912-278">A fresh thread time-slice is given to a thread after it suspends, relinquishes, makes a ThreadX SMP service call that causes preemption, or is itself timesliced.</span></span>

<span data-ttu-id="5a912-279">Cuando se adelanta un subproceso con segmentación temporal, se reanuda antes que otros subprocesos listos con la misma prioridad durante el resto de su segmento temporal.</span><span class="sxs-lookup"><span data-stu-id="5a912-279">When a time-sliced thread is preempted, it will resume before other ready threads of equal priority for the remainder of its time-slice.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5a912-280">El uso de la segmentación temporal provoca una ligera sobrecarga del sistema.</span><span class="sxs-lookup"><span data-stu-id="5a912-280">Using time-slicing results in a slight amount of system overhead.</span></span> <span data-ttu-id="5a912-281">Dado que la segmentación temporal solo es útil en aquellos casos en que varios subprocesos comparten la misma prioridad, no se debe asignar segmentación temporal a los subprocesos con una prioridad única.</span><span class="sxs-lookup"><span data-stu-id="5a912-281">Because time-slicing is only useful in cases in which multiple threads share the same priority, threads having a unique priority should not be assigned a time-slice.</span></span>

### <a name="preemption"></a><span data-ttu-id="5a912-282">Adelantamiento</span><span class="sxs-lookup"><span data-stu-id="5a912-282">Preemption</span></span> 
<span data-ttu-id="5a912-283">El adelantamiento es el proceso de interrumpir temporalmente un subproceso en ejecución en favor de uno con mayor prioridad.</span><span class="sxs-lookup"><span data-stu-id="5a912-283">Preemption is the process of temporarily interrupting an executing thread in favor of a higher-priority thread.</span></span> <span data-ttu-id="5a912-284">Este proceso no es visible para el subproceso en ejecución.</span><span class="sxs-lookup"><span data-stu-id="5a912-284">This process is invisible to the executing thread.</span></span> <span data-ttu-id="5a912-285">Cuando finaliza el subproceso de mayor prioridad, el control se transfiere de nuevo a la ubicación exacta donde se produjo el adelantamiento.</span><span class="sxs-lookup"><span data-stu-id="5a912-285">When the higher-priority thread is finished, control is transferred back to the exact place where the preemption took place.</span></span>

<span data-ttu-id="5a912-286">Se trata de una característica muy importante de los sistemas en tiempo real porque facilita la respuesta rápida a eventos de aplicación importantes.</span><span class="sxs-lookup"><span data-stu-id="5a912-286">This is a very important feature in real-time systems because it facilitates fast response to important application events.</span></span> <span data-ttu-id="5a912-287">Aunque es una característica muy importante, el adelantamiento también puede causar una serie de problemas, como el colapso, la sobrecarga excesiva y la inversión de prioridades.</span><span class="sxs-lookup"><span data-stu-id="5a912-287">Although a very important feature, preemption can also be a source of a variety of problems, including starvation, excessive overhead, and priority inversion.</span></span>

### <a name="preemption-threshold"></a><span data-ttu-id="5a912-288">Preemption-Threshold™</span><span class="sxs-lookup"><span data-stu-id="5a912-288">Preemption-Threshold™</span></span> 
<span data-ttu-id="5a912-289">Para aliviar algunos de los problemas que conlleva el adelantamiento, ThreadX SMP proporciona una avanzada característica exclusiva denominada *umbral de adelantamiento*.</span><span class="sxs-lookup"><span data-stu-id="5a912-289">To ease some of the inherent problems of preemption, ThreadX SMP provides a unique and advanced feature called *preemption-threshold*.</span></span>

<span data-ttu-id="5a912-290">Un umbral de adelantamiento permite que un subproceso especifique un *techo* de prioridad para deshabilitar el adelantamiento.</span><span class="sxs-lookup"><span data-stu-id="5a912-290">A preemption-threshold allows a thread to specify a priority *ceiling* for disabling preemption.</span></span> <span data-ttu-id="5a912-291">Los subprocesos con prioridades más altas que el techo pueden seguir adelantándose, mientras que aquellos con prioridades inferiores no pueden hacerlo.</span><span class="sxs-lookup"><span data-stu-id="5a912-291">Threads that have higher priorities than the ceiling are still allowed to preempt, while those less than the ceiling are not allowed to preempt.</span></span>

<span data-ttu-id="5a912-292">Por ejemplo, imagine que un subproceso de prioridad 20 solo interactúa con un grupo de subprocesos con prioridades entre 15 y 20.</span><span class="sxs-lookup"><span data-stu-id="5a912-292">For example, suppose a thread of priority 20 only interacts with a group of threads that have priorities between 15 and 20.</span></span> <span data-ttu-id="5a912-293">Durante sus secciones críticas, el subproceso de prioridad 20 puede establecer su umbral de adelantamiento en 15, con lo que se evita el adelantamiento de todos los subprocesos con los que interactúa.</span><span class="sxs-lookup"><span data-stu-id="5a912-293">During its critical sections, the thread of priority 20 can set its preemption-threshold to 15, thereby preventing preemption from all of the threads that it interacts with.</span></span> <span data-ttu-id="5a912-294">Esto sigue permitiendo que los subprocesos realmente importantes (con prioridades entre 0 y 14) adelanten a este durante su procesamiento de secciones críticas, lo que da lugar a un procesamiento mucho más dinámico.</span><span class="sxs-lookup"><span data-stu-id="5a912-294">This still permits really important threads (priorities between 0 and 14) to preempt this thread during its critical section processing, which results in much more responsive processing.</span></span>

<span data-ttu-id="5a912-295">Por supuesto, sigue siendo posible que un subproceso deshabilite todo adelantamiento si establece su umbral de adelantamiento en 0.</span><span class="sxs-lookup"><span data-stu-id="5a912-295">Of course, it is still possible for a thread to disable all preemption by setting its preemption-threshold to 0.</span></span> <span data-ttu-id="5a912-296">Además, el umbral de adelantamiento se puede cambiar durante el tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="5a912-296">In addition, preemption-threshold can be changed during run-time.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5a912-297">El uso del umbral de adelantamiento deshabilita la segmentación temporal en el subproceso especificado.</span><span class="sxs-lookup"><span data-stu-id="5a912-297">Using preemption-threshold disables time-slicing for the specified thread.</span></span>

### <a name="priority-inheritance"></a><span data-ttu-id="5a912-298">Herencia de prioridad</span><span class="sxs-lookup"><span data-stu-id="5a912-298">Priority Inheritance</span></span> 
<span data-ttu-id="5a912-299">ThreadX SMP también admite la herencia de prioridad opcional dentro de sus servicios de exclusión mutua, que se describen más adelante en este capítulo.</span><span class="sxs-lookup"><span data-stu-id="5a912-299">ThreadX SMP also supports optional priority inheritance within its mutex services described later in this chapter.</span></span> <span data-ttu-id="5a912-300">La herencia de prioridad permite que un subproceso de prioridad baja asuma temporalmente la de un subproceso de prioridad alta que espera una exclusión mutua que es propiedad del subproceso de prioridad baja.</span><span class="sxs-lookup"><span data-stu-id="5a912-300">Priority inheritance allows a lower priority thread to temporarily assume the priority of a high priority thread that is waiting for a mutex owned by the lower priority thread.</span></span> <span data-ttu-id="5a912-301">Esta capacidad ayuda a la aplicación a evitar la inversión de prioridades no determinista al eliminar el adelantamiento de prioridades de subprocesos intermedias.</span><span class="sxs-lookup"><span data-stu-id="5a912-301">This capability helps the application to avoid nondeterministic priority inversion by eliminating preemption of intermediate thread priorities.</span></span> <span data-ttu-id="5a912-302">Por supuesto, se puede usar el *umbral de adelantamiento* para lograr un resultado similar.</span><span class="sxs-lookup"><span data-stu-id="5a912-302">Of course, *preemption-threshold* may be used to achieve a similar result.</span></span>

### <a name="thread-creation"></a><span data-ttu-id="5a912-303">Creación de subprocesos</span><span class="sxs-lookup"><span data-stu-id="5a912-303">Thread Creation</span></span> 
<span data-ttu-id="5a912-304">Los subprocesos de aplicación se crean durante la inicialización o durante la ejecución de otros subprocesos de aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-304">Application threads are created during initialization or during the execution of other application threads.</span></span> <span data-ttu-id="5a912-305">No existe límite en cuanto al número de subprocesos que puede crear una aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-305">There is no limit on the number of threads that can be created by an application.</span></span>

### <a name="thread-control-block-tx_thread"></a><span data-ttu-id="5a912-306">Bloque de control de subprocesos TX_THREAD</span><span class="sxs-lookup"><span data-stu-id="5a912-306">Thread Control Block TX_THREAD</span></span> 
<span data-ttu-id="5a912-307">Las características de cada subproceso se encuentran en su bloque de control.</span><span class="sxs-lookup"><span data-stu-id="5a912-307">The characteristics of each thread are contained in its control block.</span></span> <span data-ttu-id="5a912-308">Esta estructura se define en el archivo ***tx_api.h***.</span><span class="sxs-lookup"><span data-stu-id="5a912-308">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="5a912-309">El bloque de control de un subproceso se puede colocar en cualquier parte de la memoria, pero es más común convertirlo en una estructura global; para ello, hay que definirlo fuera del ámbito de cualquier función.</span><span class="sxs-lookup"><span data-stu-id="5a912-309">A thread’s control block can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

<span data-ttu-id="5a912-310">La colocación del bloque de control en otras áreas exige un poco más de cuidado, igual que toda la memoria asignada de forma dinámica.</span><span class="sxs-lookup"><span data-stu-id="5a912-310">Locating the control block in other areas requires a bit more care, just like all dynamically allocated memory.</span></span> <span data-ttu-id="5a912-311">Si se asigna un bloque de control en una función de C, la memoria asociada al mismo forma parte de la pila del subproceso que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="5a912-311">If a control block is allocated within a C function, the memory associated with it is part of the calling thread’s stack.</span></span> <span data-ttu-id="5a912-312">En general, evite usar el almacenamiento local para los bloques de control, ya que, una vez devuelta la función, se libera todo su espacio de la pila de variables local, independientemente de si otro subproceso la usa para un bloque de control.</span><span class="sxs-lookup"><span data-stu-id="5a912-312">In general, avoid using local storage for control blocks because after the function returns, all of its local variable stack space is released—regardless of whether another thread is using it for a control block!</span></span>

<span data-ttu-id="5a912-313">En la mayoría de los casos, la aplicación desconoce el contenido del bloque de control del subproceso.</span><span class="sxs-lookup"><span data-stu-id="5a912-313">In most cases, the application is oblivious to the contents of the thread’s control block.</span></span> <span data-ttu-id="5a912-314">Pero hay algunas situaciones, especialmente durante la depuración, en que resulta útil examinar determinados miembros.</span><span class="sxs-lookup"><span data-stu-id="5a912-314">However, there are some situations, especially during debug, in which looking at certain members is useful.</span></span> <span data-ttu-id="5a912-315">A continuación se muestran algunos de los miembros de bloque de control más útiles:</span><span class="sxs-lookup"><span data-stu-id="5a912-315">The following are some of the more useful control block members:</span></span>

- <span data-ttu-id="5a912-316">**tx_thread_run_count** tiene un contador del número de veces que se ha programado el subproceso.</span><span class="sxs-lookup"><span data-stu-id="5a912-316">**tx_thread_run_count** contains a counter of the number of many times the thread has been scheduled.</span></span> <span data-ttu-id="5a912-317">Un contador creciente indica que el subproceso se está programando y ejecutando.</span><span class="sxs-lookup"><span data-stu-id="5a912-317">An increasing counter indicates the thread is being scheduled and executed.</span></span>

- <span data-ttu-id="5a912-318">**tx_thread_state** contiene el estado del subproceso asociado.</span><span class="sxs-lookup"><span data-stu-id="5a912-318">**tx_thread_state** contains the state of the associated thread.</span></span> <span data-ttu-id="5a912-319">A continuación se enumeran los posibles estados de un subproceso:</span><span class="sxs-lookup"><span data-stu-id="5a912-319">The following lists the possible thread states:</span></span>

    - <span data-ttu-id="5a912-320">TX_READY(0x00)</span><span class="sxs-lookup"><span data-stu-id="5a912-320">TX_READY(0x00)</span></span>
    - <span data-ttu-id="5a912-321">TX_COMPLETED(0x01)</span><span class="sxs-lookup"><span data-stu-id="5a912-321">TX_COMPLETED(0x01)</span></span>
    - <span data-ttu-id="5a912-322">TX_TERMINATED(0x02)</span><span class="sxs-lookup"><span data-stu-id="5a912-322">TX_TERMINATED(0x02)</span></span>
    - <span data-ttu-id="5a912-323">TX_SUSPENDED(0x03)</span><span class="sxs-lookup"><span data-stu-id="5a912-323">TX_SUSPENDED(0x03)</span></span>
    - <span data-ttu-id="5a912-324">TX_SLEEP(0x04)</span><span class="sxs-lookup"><span data-stu-id="5a912-324">TX_SLEEP(0x04)</span></span>
    - <span data-ttu-id="5a912-325">TX_QUEUE_SUSP(0x05)</span><span class="sxs-lookup"><span data-stu-id="5a912-325">TX_QUEUE_SUSP(0x05)</span></span>
    - <span data-ttu-id="5a912-326">TX_SEMAPHORE_SUSP(0x06)</span><span class="sxs-lookup"><span data-stu-id="5a912-326">TX_SEMAPHORE_SUSP(0x06)</span></span>
    - <span data-ttu-id="5a912-327">TX_EVENT_FLAG (0x07)</span><span class="sxs-lookup"><span data-stu-id="5a912-327">TX_EVENT_FLAG (0x07)</span></span>
    - <span data-ttu-id="5a912-328">TX_BLOCK_MEMORY(0x08)</span><span class="sxs-lookup"><span data-stu-id="5a912-328">TX_BLOCK_MEMORY(0x08)</span></span>
    - <span data-ttu-id="5a912-329">TX_BYTE_MEMORY (0x09)</span><span class="sxs-lookup"><span data-stu-id="5a912-329">TX_BYTE_MEMORY (0x09)</span></span>
    - <span data-ttu-id="5a912-330">TX_MUTEX_SUSP(0x0D)</span><span class="sxs-lookup"><span data-stu-id="5a912-330">TX_MUTEX_SUSP(0x0D)</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5a912-331">Evidentemente, hay otros muchos campos interesantes en el bloque de control de subprocesos, entre los que se incluyen el puntero de pila, el valor del segmento temporal, las prioridades, etc. Los usuarios pueden revisar los miembros del bloque de control, pero las modificaciones están totalmente prohibidas.</span><span class="sxs-lookup"><span data-stu-id="5a912-331">Of course there are many other interesting fields in the thread control block, including the stack pointer, time-slice value, priorities, etc. Users are welcome to review control block members, but modifications are strictly prohibited!</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5a912-332">No hay ningún equivalente al estado "en ejecución" mencionado anteriormente en esta sección.</span><span class="sxs-lookup"><span data-stu-id="5a912-332">There is no equate for the “executing” state mentioned earlier in this section.</span></span> <span data-ttu-id="5a912-333">No es necesario porque solo hay un subproceso en ejecución en un momento dado.</span><span class="sxs-lookup"><span data-stu-id="5a912-333">It is not necessary because there is only one executing thread at a given time.</span></span> <span data-ttu-id="5a912-334">El estado de un subproceso en ejecución también es ***TX_READY***.</span><span class="sxs-lookup"><span data-stu-id="5a912-334">The state of an executing thread is also ***TX_READY***.</span></span>

### <a name="currently-executing-thread"></a><span data-ttu-id="5a912-335">Subproceso en ejecución</span><span class="sxs-lookup"><span data-stu-id="5a912-335">Currently Executing Thread</span></span> 
<span data-ttu-id="5a912-336">Como se ha mencionado antes, en un momento dado solo hay un subproceso en ejecución.</span><span class="sxs-lookup"><span data-stu-id="5a912-336">As mentioned before, there is only one thread executing at any given time.</span></span> <span data-ttu-id="5a912-337">Hay varias maneras de identificar el subproceso en ejecución, en función del subproceso que realiza la solicitud.</span><span class="sxs-lookup"><span data-stu-id="5a912-337">There are several ways to identify the executing thread, depending on which thread is making the request.</span></span>

<span data-ttu-id="5a912-338">Un segmento de programa puede obtener la dirección del bloque de control del subproceso en ejecución mediante una llamada a ***tx_thread_identify***.</span><span class="sxs-lookup"><span data-stu-id="5a912-338">A program segment can get the control block address of the executing thread by calling ***tx_thread_identify***.</span></span> <span data-ttu-id="5a912-339">Esto resulta útil en fragmentos compartidos del código de la aplicación que se ejecutan desde varios subprocesos.</span><span class="sxs-lookup"><span data-stu-id="5a912-339">This is useful in shared portions of application code that are executed from multiple threads.</span></span>

<span data-ttu-id="5a912-340">En las sesiones de depuración, los usuarios pueden examinar la matriz de punteros interna de ThreadX SMP ***_tx_thread_current_ptr[core]***.</span><span class="sxs-lookup"><span data-stu-id="5a912-340">In debug sessions, users can examine the internal ThreadX SMP pointer array ***_tx_thread_current_ptr[core]***.</span></span> <span data-ttu-id="5a912-341">Contiene la dirección del bloque de control del subproceso en ejecución.</span><span class="sxs-lookup"><span data-stu-id="5a912-341">It contains the control block address of the currently executing thread.</span></span> <span data-ttu-id="5a912-342">Si este puntero es NULL, no hay ningún subproceso de aplicación en ejecución, es decir, ThreadX SMP espera en su bucle de programación a que un subproceso esté listo.</span><span class="sxs-lookup"><span data-stu-id="5a912-342">If this pointer is NULL, no application thread is executing; i.e., ThreadX SMP is waiting in its scheduling loop for a thread to become ready.</span></span>

### <a name="thread-stack-area"></a><span data-ttu-id="5a912-343">Área de pila del subproceso</span><span class="sxs-lookup"><span data-stu-id="5a912-343">Thread Stack Area</span></span> 
<span data-ttu-id="5a912-344">Cada subproceso debe tener su propia pila para guardar el contexto de su última ejecución y uso del compilador.</span><span class="sxs-lookup"><span data-stu-id="5a912-344">Each thread must have its own stack for saving the context of its last execution and compiler use.</span></span> <span data-ttu-id="5a912-345">La mayoría de los compiladores de C usan la pila para realizar llamadas a funciones y para asignar variables locales de forma temporal.</span><span class="sxs-lookup"><span data-stu-id="5a912-345">Most C compilers use the stack for making function calls and for temporarily allocating local variables.</span></span> <span data-ttu-id="5a912-346">En la figura 5 de la página 61 se muestra la pila de un subproceso típica.</span><span class="sxs-lookup"><span data-stu-id="5a912-346">Figure 5 on page 61 shows a typical thread’s stack.</span></span>

![Área de pila del subproceso](media/image8.png)

<span data-ttu-id="5a912-348">**FIGURA 5. Pila de subproceso típica**</span><span class="sxs-lookup"><span data-stu-id="5a912-348">**FIGURE 5. Typical Thread Stack**</span></span>

<span data-ttu-id="5a912-349">La ubicación de la pila de un subproceso en la memoria depende de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-349">Where a thread stack is located in memory is up to the application.</span></span> <span data-ttu-id="5a912-350">El área de pila se especifica durante la creación del subproceso y se puede colocar en cualquier parte del espacio de direcciones del destino.</span><span class="sxs-lookup"><span data-stu-id="5a912-350">The stack area is specified during thread creation and can be located anywhere in the target’s address space.</span></span> <span data-ttu-id="5a912-351">Se trata de una característica importante porque permite a las aplicaciones mejorar el rendimiento de los subprocesos importantes mediante la colocación de su pila en la memoria RAM de alta velocidad.</span><span class="sxs-lookup"><span data-stu-id="5a912-351">This is an important feature because it allows applications to improve performance of important threads by placing their stack in high-speed RAM.</span></span>

<span data-ttu-id="5a912-352">El tamaño de una pila debería ser una de las preguntas más frecuentes sobre los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="5a912-352">How big a stack should be is one of the most frequently asked questions about threads.</span></span> <span data-ttu-id="5a912-353">El área de pila de un subproceso debe ser lo suficientemente grande como para acomodar el anidamiento de llamadas a funciones de peor caso, la asignación de variables locales y el guardado de su último contexto de ejecución.</span><span class="sxs-lookup"><span data-stu-id="5a912-353">A thread’s stack area must be large enough to accommodate worst-case function call nesting, local variable allocation, and saving its last execution context.</span></span>

<span data-ttu-id="5a912-354">ThreadX SMP define el tamaño mínimo de la pila, **TX_MINIMUM_STACK**.</span><span class="sxs-lookup"><span data-stu-id="5a912-354">The minimum stack size, **TX_MINIMUM_STACK**, is defined by ThreadX SMP.</span></span> <span data-ttu-id="5a912-355">Una pila de este tamaño permite guardar el contexto de un subproceso y la cantidad mínima de llamadas a funciones y de asignaciones de variables locales.</span><span class="sxs-lookup"><span data-stu-id="5a912-355">A stack of this size supports saving a thread’s context and minimum amount of function calls and local variable allocation.</span></span>

<span data-ttu-id="5a912-356">Pero para la mayoría de los subprocesos, el tamaño mínimo de la pila es demasiado pequeño y el usuario debe determinar el requisito de tamaño de peor caso mediante el examen del anidamiento de las llamadas a funciones y la asignación de variables locales.</span><span class="sxs-lookup"><span data-stu-id="5a912-356">For most threads, however, the minimum stack size is too small, and the user must ascertain the worstcase size requirement by examining function-call nesting and local variable allocation.</span></span> <span data-ttu-id="5a912-357">Por supuesto, siempre es mejor empezar con un área de pila más grande.</span><span class="sxs-lookup"><span data-stu-id="5a912-357">Of course, it is always better to start with a larger stack area.</span></span>

<span data-ttu-id="5a912-358">Después de depurar la aplicación, se pueden ajustar los tamaños de la pila de subprocesos si la memoria es escasa.</span><span class="sxs-lookup"><span data-stu-id="5a912-358">After the application is debugged, it is possible to tune the thread stack sizes if memory is scarce.</span></span> <span data-ttu-id="5a912-359">Un buen truco es preestablecer todas las áreas de pila con un patrón de datos fácilmente identificable, como (0xEFEF), antes de crear los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="5a912-359">A favorite trick is to preset all stack areas with an easily identifiable data pattern like (0xEFEF) prior to creating the threads.</span></span> <span data-ttu-id="5a912-360">Una vez que la aplicación se ha probado en profundidad, se pueden examinar las áreas de pila para ver la cantidad que se ha usado realmente; para ello, se busca el área de la pila en la que el patrón de datos sigue intacto.</span><span class="sxs-lookup"><span data-stu-id="5a912-360">After the application has been thoroughly put through its paces, the stack areas can be examined to see how much stack was actually used by finding the area of the stack where the data pattern is still intact.</span></span> <span data-ttu-id="5a912-361">En la figura 6 se muestra un valor de pila preestablecido en 0xEFEF después de la ejecución exhaustiva de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="5a912-361">Figure 6 shows a stack preset to 0xEFEF after thorough thread execution.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5a912-362">De manera predeterminada, ThreadX SMP inicializa cada byte de cada pila de subprocesos con un valor de 0xEF.</span><span class="sxs-lookup"><span data-stu-id="5a912-362">By default, ThreadX SMP initializes every byte of each thread stack with a value of 0xEF.</span></span>

### <a name="memory-pitfalls"></a><span data-ttu-id="5a912-363">Problemas de memoria</span><span class="sxs-lookup"><span data-stu-id="5a912-363">Memory Pitfalls</span></span> 
<span data-ttu-id="5a912-364">Los requisitos de la pila para los subprocesos pueden ser considerables.</span><span class="sxs-lookup"><span data-stu-id="5a912-364">The stack requirements for threads can be large.</span></span> <span data-ttu-id="5a912-365">Por tanto, es importante diseñar la aplicación para que tenga un número razonable de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="5a912-365">Therefore, it is important to design the application to have a reasonable number of threads.</span></span> <span data-ttu-id="5a912-366">Además, se debe tener cuidado para evitar un uso excesivo de la pila dentro de los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="5a912-366">Furthermore, some care must be taken to avoid excessive stack usage within threads.</span></span> <span data-ttu-id="5a912-367">Se deben evitar los algoritmos recursivos y las estructuras de datos locales de gran tamaño.</span><span class="sxs-lookup"><span data-stu-id="5a912-367">Recursive algorithms and large local data structures should be avoided.</span></span>

<span data-ttu-id="5a912-368">En la mayoría de los casos, una pila desbordada hace que la ejecución de los subprocesos dañe la memoria adyacente (normalmente</span><span class="sxs-lookup"><span data-stu-id="5a912-368">In most cases, an overflowed stack causes thread execution to corrupt memory adjacent (usually</span></span> 

![Problemas de memoria](media/image9.png)

<span data-ttu-id="5a912-370">**FIGURA 6. Valor de la pila preestablecido en 0xEFEF**</span><span class="sxs-lookup"><span data-stu-id="5a912-370">**FIGURE 6. Stack Preset to 0xEFEF**</span></span>

<span data-ttu-id="5a912-371">delante) a su área de pila.</span><span class="sxs-lookup"><span data-stu-id="5a912-371">before) its stack area.</span></span> <span data-ttu-id="5a912-372">Los resultados son imprevisibles, pero la mayoría de las veces provocan un cambio no natural en el contador de programas.</span><span class="sxs-lookup"><span data-stu-id="5a912-372">The results are unpredictable, but most often result in an un-natural change in the program counter.</span></span> <span data-ttu-id="5a912-373">Esto se suele conocer como "estar desbordado".</span><span class="sxs-lookup"><span data-stu-id="5a912-373">This is often called “jumping into the weeds.”</span></span> <span data-ttu-id="5a912-374">Por supuesto, la única manera de evitarlo es asegurarse de que todas las pilas de subproceso son lo suficientemente grandes.</span><span class="sxs-lookup"><span data-stu-id="5a912-374">Of course, the only way to prevent this is to ensure all thread stacks are large enough.</span></span>

### <a name="optional-run-time-stack-checking"></a><span data-ttu-id="5a912-375">Comprobación opcional de pila en tiempo de ejecución</span><span class="sxs-lookup"><span data-stu-id="5a912-375">Optional Run-time Stack Checking</span></span>  
<span data-ttu-id="5a912-376">ThreadX SMP ofrece la posibilidad de comprobar en tiempo de ejecución la existencia de daños en la pila de cada subproceso.</span><span class="sxs-lookup"><span data-stu-id="5a912-376">ThreadX SMP provides the ability to check each thread's stack for corruption during run-time.</span></span> <span data-ttu-id="5a912-377">De manera predeterminada, ThreadX SMP rellena cada byte de las pilas de subproceso con un patrón de datos 0xEF durante la creación.</span><span class="sxs-lookup"><span data-stu-id="5a912-377">By default, ThreadX SMP fills every byte of thread stacks with a 0xEF data pattern during creation.</span></span> <span data-ttu-id="5a912-378">Si la aplicación compila la biblioteca de ThreadX SMP con \***TX_ENABLE_STACK_CHECKING** _ definido, ThreadX SMP examina la pila de cada subproceso en busca de daños mientras se suspende o se reanuda.</span><span class="sxs-lookup"><span data-stu-id="5a912-378">If the application builds the ThreadX SMP library with \***TX_ENABLE_STACK_CHECKING** _ defined, ThreadX SMP will examine each thread's stack for corruption as it is suspended or resumed.</span></span> <span data-ttu-id="5a912-379">Si se detectan daños en la pila, ThreadX SMP llama a la rutina de control de errores de la pila de la aplicación, como se especifica en la llamada a _tx_thread_stack_error_notify\*.</span><span class="sxs-lookup"><span data-stu-id="5a912-379">If stack corruption is detected, ThreadX SMP will call the application's stack error handling routine as specified by the call to _tx_thread_stack_error_notify\*.</span></span> <span data-ttu-id="5a912-380">De lo contrario, si no se ha especificado ningún controlador de errores de pila, ThreadX SMP llama a la rutina interna *_tx_thread_stack_error_handler*.</span><span class="sxs-lookup"><span data-stu-id="5a912-380">Otherwise, if no stack error handler was specified, ThreadX SMP will call the internal *_tx_thread_stack_error_handler* routine.</span></span>

### <a name="reentrancy"></a><span data-ttu-id="5a912-381">Reentrada</span><span class="sxs-lookup"><span data-stu-id="5a912-381">Reentrancy</span></span> 
<span data-ttu-id="5a912-382">Uno de los atractivos reales de multithreading es que se puede llamar a la misma función de C desde varios subprocesos.</span><span class="sxs-lookup"><span data-stu-id="5a912-382">One of the real beauties of multithreading is that the same C function can be called from multiple threads.</span></span> <span data-ttu-id="5a912-383">Esto proporciona una gran eficacia y también ayuda a reducir el espacio de código.</span><span class="sxs-lookup"><span data-stu-id="5a912-383">This provides great power and also helps reduce code space.</span></span> <span data-ttu-id="5a912-384">Pero es necesario que las funciones de C a las que se llama desde varios subprocesos sean *reentrantes*.</span><span class="sxs-lookup"><span data-stu-id="5a912-384">However, it does require that C functions called from multiple threads are *reentrant*.</span></span>

<span data-ttu-id="5a912-385">Básicamente, una función reentrante almacena en la pila actual la dirección de devolución del autor de la llamada y no se basa en las variables de C globales o estáticas que ha configurado antes.</span><span class="sxs-lookup"><span data-stu-id="5a912-385">Basically, a reentrant function stores the caller’s return address on the current stack and does not rely on global or static C variables that it previously set up.</span></span> <span data-ttu-id="5a912-386">La mayoría de los compiladores colocan la dirección de devolución en la pila.</span><span class="sxs-lookup"><span data-stu-id="5a912-386">Most compilers place the return address on the stack.</span></span> <span data-ttu-id="5a912-387">Por tanto, los desarrolladores de aplicaciones solo deben preocuparse por el uso de las variables *globales* y *estáticas*.</span><span class="sxs-lookup"><span data-stu-id="5a912-387">Hence, application developers must only worry about the use of *globals* and *statics*.</span></span>

<span data-ttu-id="5a912-388">Un ejemplo de función no reentrante es la función de token de cadena "strtok" de la biblioteca estándar de C.</span><span class="sxs-lookup"><span data-stu-id="5a912-388">An example of a non-reentrant function is the string token function “strtok” found in the standard C library.</span></span> <span data-ttu-id="5a912-389">Esta función recuerda el puntero de cadena anterior en las llamadas siguientes.</span><span class="sxs-lookup"><span data-stu-id="5a912-389">This function remembers the previous string pointer on subsequent calls.</span></span> <span data-ttu-id="5a912-390">Lo hace con un puntero de cadena estático.</span><span class="sxs-lookup"><span data-stu-id="5a912-390">It does this with a static string pointer.</span></span> <span data-ttu-id="5a912-391">Si se llama a esta función desde varios subprocesos, lo más probable es que devuelva un puntero no válido.</span><span class="sxs-lookup"><span data-stu-id="5a912-391">If this function is called from multiple threads, it would most likely return an invalid pointer.</span></span>

### <a name="thread-priority-pitfalls"></a><span data-ttu-id="5a912-392">Problemas de prioridad de subprocesos</span><span class="sxs-lookup"><span data-stu-id="5a912-392">Thread Priority Pitfalls</span></span> 
<span data-ttu-id="5a912-393">La selección de la prioridad de los subprocesos es uno de los aspectos más importantes de multithreading.</span><span class="sxs-lookup"><span data-stu-id="5a912-393">Selecting thread priorities is one of the most important aspects of multithreading.</span></span> <span data-ttu-id="5a912-394">A veces es muy tentador asignar la prioridad en función de una noción percibida de la importancia del subproceso, en lugar de determinar lo que se necesita exactamente durante el tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="5a912-394">It is sometimes very tempting to assign priorities based on a perceived notion of thread importance rather than determining what is exactly required during run-time.</span></span> <span data-ttu-id="5a912-395">El uso incorrecto de las prioridades de los subprocesos puede colapsar a otros subprocesos, crear inversión de prioridades, reducir el ancho de banda de procesamiento y dificultar la comprensión del comportamiento en tiempo de ejecución de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-395">Misuse of thread priorities can starve other threads, create priority inversion, reduce processing bandwidth, and make the application’s run-time behavior difficult to understand.</span></span>

<span data-ttu-id="5a912-396">Como se ha mencionado antes, ThreadX SMP proporciona un algoritmo de programación de adelantamientos basado en la prioridad.</span><span class="sxs-lookup"><span data-stu-id="5a912-396">As mentioned before, ThreadX SMP provides a priority-based, preemptive scheduling algorithm.</span></span> <span data-ttu-id="5a912-397">Los subprocesos de prioridad baja no se ejecutan hasta que no hay subprocesos de prioridad más alta listos para ejecutarse.</span><span class="sxs-lookup"><span data-stu-id="5a912-397">Lower priority threads do not execute until there are no higher priority threads ready for execution.</span></span> <span data-ttu-id="5a912-398">Si siempre hay un subproceso de prioridad más alta listo, los subprocesos de prioridad baja nunca se ejecutan.</span><span class="sxs-lookup"><span data-stu-id="5a912-398">If a higher priority thread is always ready, the lower priority threads never execute.</span></span> <span data-ttu-id="5a912-399">Esta condición se denomina *colapso de subprocesos*.</span><span class="sxs-lookup"><span data-stu-id="5a912-399">This condition is called *thread starvation*.</span></span>

<span data-ttu-id="5a912-400">La mayoría de los problemas de colapso de subprocesos se detectan en una fase temprana de la depuración y se pueden resolver asegurándose de que los subprocesos de prioridad más alta no se ejecuten de forma continuada.</span><span class="sxs-lookup"><span data-stu-id="5a912-400">Most thread starvation problems are detected early in debug and can be solved by ensuring that higher priority threads don’t execute continuously.</span></span> <span data-ttu-id="5a912-401">Como alternativa, se puede agregar una lógica a la aplicación que aumente gradualmente la prioridad de los subprocesos colapsados hasta que tengan la oportunidad de ejecutarse.</span><span class="sxs-lookup"><span data-stu-id="5a912-401">Alternatively, logic can be added to the application that gradually raises the priority of starved threads until they get a chance to execute.</span></span>

<span data-ttu-id="5a912-402">Otro problema asociado a las prioridades de los subprocesos es la *inversión de prioridades*.</span><span class="sxs-lookup"><span data-stu-id="5a912-402">Another pitfall associated with thread priorities is *priority inversion*.</span></span> <span data-ttu-id="5a912-403">La inversión de prioridades tiene lugar cuando se suspende un subproceso de prioridad superior porque otro de prioridad baja tiene un recurso necesario.</span><span class="sxs-lookup"><span data-stu-id="5a912-403">Priority inversion takes place when a higher priority thread is suspended because a lower priority thread has a needed resource.</span></span> <span data-ttu-id="5a912-404">Evidentemente, en algunos casos es necesario que dos subprocesos de prioridad diferente compartan un recurso común.</span><span class="sxs-lookup"><span data-stu-id="5a912-404">Of course, in some instances it is necessary for two threads of different priority to share a common resource.</span></span> <span data-ttu-id="5a912-405">Si estos subprocesos son los únicos activos, el tiempo de inversión de prioridades está limitado por el tiempo que el subproceso de prioridad baja mantiene el recurso.</span><span class="sxs-lookup"><span data-stu-id="5a912-405">If these threads are the only ones active, the priority inversion time is bounded by the time the lower priority thread holds the resource.</span></span> <span data-ttu-id="5a912-406">Esta condición es determinista y bastante normal.</span><span class="sxs-lookup"><span data-stu-id="5a912-406">This condition is both deterministic and quite normal.</span></span> <span data-ttu-id="5a912-407">Pero si durante esta condición de inversión de prioridades se activan subprocesos de prioridad intermedia, el tiempo de inversión de prioridades deja de ser determinista y puede provocar un error en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-407">However, if threads of intermediate priority become active during this priority inversion condition, the priority inversion time is no longer deterministic and could cause an application failure.</span></span>

<span data-ttu-id="5a912-408">Existen principalmente tres métodos distintos para evitar la inversión de prioridades no determinista en ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="5a912-408">There are principally three distinct methods of preventing nondeterministic priority inversion in ThreadX SMP.</span></span> <span data-ttu-id="5a912-409">En primer lugar, las selecciones de prioridad de las aplicaciones y el comportamiento en tiempo de ejecución se pueden diseñar de forma que se evite el problema de inversión de prioridades.</span><span class="sxs-lookup"><span data-stu-id="5a912-409">First, the application priority selections and run-time behavior can be designed in a manner that prevents the priority inversion problem.</span></span> <span data-ttu-id="5a912-410">En segundo lugar, los subprocesos de prioridad baja pueden usar el *umbral de adelantamiento* para bloquear el adelantamiento de los subprocesos intermedios mientras comparten recursos con subprocesos de mayor prioridad.</span><span class="sxs-lookup"><span data-stu-id="5a912-410">Second, lower priority threads can utilize *preemption-threshold* to block preemption from intermediate threads while they share resources with higher priority threads.</span></span> <span data-ttu-id="5a912-411">Por último, los subprocesos que usan objetos de exclusión mutua de ThreadX SMP para proteger los recursos del sistema pueden usar la *herencia de prioridad* de exclusión mutua opcional para eliminar la inversión de prioridades no determinista.</span><span class="sxs-lookup"><span data-stu-id="5a912-411">Finally, threads using ThreadX SMP mutex objects to protect system resources may utilize the optional mutex *priority inheritance* to eliminate nondeterministic priority inversion.</span></span>

### <a name="priority-overhead"></a><span data-ttu-id="5a912-412">Sobrecarga de prioridad</span><span class="sxs-lookup"><span data-stu-id="5a912-412">Priority Overhead</span></span> 
<span data-ttu-id="5a912-413">Una de las formas más infravaloradas para disminuir la sobrecarga en multithreading es reducir el número de cambios de contexto.</span><span class="sxs-lookup"><span data-stu-id="5a912-413">One of the most overlooked ways to reduce overhead in multithreading is to reduce the number of context switches.</span></span> <span data-ttu-id="5a912-414">Como se ha mencionado antes, un cambio de contexto se produce cuando se favorece la ejecución de un subproceso de prioridad más alta sobre la del subproceso en ejecución.</span><span class="sxs-lookup"><span data-stu-id="5a912-414">As previously mentioned, a context switch occurs when execution of a higher priority thread is favored over that of the executing thread.</span></span> <span data-ttu-id="5a912-415">Merece la pena mencionar que los subprocesos de mayor prioridad pueden pasar a estar listos como resultado de eventos externos (por ejemplo, interrupciones) y de llamadas a servicios realizadas por el subproceso en ejecución.</span><span class="sxs-lookup"><span data-stu-id="5a912-415">It is worthwhile to mention that higher priority threads can become ready as a result of both external events (like interrupts) and from service calls made by the executing thread.</span></span>

<span data-ttu-id="5a912-416">Para ilustrar los efectos que tienen las prioridades de los subprocesos en la sobrecarga de cambios de contexto, imagine un entorno de tres subprocesos: *subproceso_1*, *subproceso_2* y *subproceso_3*.</span><span class="sxs-lookup"><span data-stu-id="5a912-416">To illustrate the effects thread priorities have on context switch overhead, assume a three thread environment with threads named *thread_1*, *thread_2*, and *thread_3*.</span></span> <span data-ttu-id="5a912-417">Imagine además que todos los subprocesos están en estado de suspensión en espera de un mensaje.</span><span class="sxs-lookup"><span data-stu-id="5a912-417">Assume further that all of the threads are in a state of suspension waiting for a message.</span></span> <span data-ttu-id="5a912-418">Cuando subproceso_1 recibe un mensaje, lo reenvía inmediatamente a subproceso_2.</span><span class="sxs-lookup"><span data-stu-id="5a912-418">When thread_1 receives a message, it immediately forwards it to thread_2.</span></span> <span data-ttu-id="5a912-419">Después, subproceso_2 reenvía el mensaje a subproceso_3.</span><span class="sxs-lookup"><span data-stu-id="5a912-419">Thread_2 then forwards the message to thread_3.</span></span> <span data-ttu-id="5a912-420">Subproceso_3 simplemente descarta el mensaje.</span><span class="sxs-lookup"><span data-stu-id="5a912-420">Thread_3 just discards the message.</span></span> <span data-ttu-id="5a912-421">Una vez que cada subproceso procesa su mensaje, retrocede y espera otro mensaje.</span><span class="sxs-lookup"><span data-stu-id="5a912-421">After each thread processes its message, it goes back and waits for another message.</span></span>

<span data-ttu-id="5a912-422">El procesamiento necesario para ejecutar estos tres subprocesos varía considerablemente en función de sus prioridades.</span><span class="sxs-lookup"><span data-stu-id="5a912-422">The processing required to execute these three threads varies greatly depending on their priorities.</span></span> <span data-ttu-id="5a912-423">Si todos los subprocesos tienen la misma prioridad, solo se produce un cambio de contexto antes de la ejecución de cada uno.</span><span class="sxs-lookup"><span data-stu-id="5a912-423">If all of the threads have the same priority, a single context switch occurs before the execution of each thread.</span></span> <span data-ttu-id="5a912-424">El cambio de contexto se produce cuando cada subproceso se suspende en una cola de mensajes vacía.</span><span class="sxs-lookup"><span data-stu-id="5a912-424">The context switch occurs when each thread suspends on an empty message queue.</span></span>

<span data-ttu-id="5a912-425">Pero si subproceso_2 tiene mayor prioridad que subproceso_1, y subproceso_3 tiene mayor prioridad que subproceso_2, se duplica el número de cambios de contexto.</span><span class="sxs-lookup"><span data-stu-id="5a912-425">However, if thread_2 is higher priority than thread_1 and thread_3 is higher priority than thread_2, the number of context switches doubles.</span></span> <span data-ttu-id="5a912-426">Esto se debe a que se produce otro cambio de contexto dentro del servicio *tx_queue_send* cuando detecta que un subproceso de prioridad más alta ya está listo.</span><span class="sxs-lookup"><span data-stu-id="5a912-426">This is because another context switch occurs inside of the *tx_queue_send* service when it detects that a higher priority thread is now ready.</span></span>

<span data-ttu-id="5a912-427">El mecanismo de umbral de adelantamiento de ThreadX SMP puede evitar estos cambios de contexto adicionales y seguir permitiendo las selecciones de prioridad mencionadas anteriormente.</span><span class="sxs-lookup"><span data-stu-id="5a912-427">The ThreadX SMP preemption-threshold mechanism can avoid these extra context switches and still allow the previously mentioned priority selections.</span></span> <span data-ttu-id="5a912-428">Se trata de una característica importante porque permite varias prioridades de subproceso durante la programación, al tiempo que elimina algunos de los cambios de contexto no deseados entre ellos durante la ejecución de los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="5a912-428">This is an important feature because it allows several thread priorities during scheduling, while at the same time eliminating some of the unwanted context switching between them during thread execution.</span></span>

### <a name="run-time-thread-performance-information"></a><span data-ttu-id="5a912-429">Información sobre el rendimiento de los subprocesos en tiempo de ejecución</span><span class="sxs-lookup"><span data-stu-id="5a912-429">Run-time Thread Performance Information</span></span> 
<span data-ttu-id="5a912-430">ThreadX SMP proporciona información opcional sobre el rendimiento de los subprocesos en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="5a912-430">ThreadX SMP provides optional run-time thread performance information.</span></span> <span data-ttu-id="5a912-431">Si la biblioteca de ThreadX SMP y la aplicación se compilan con ***TX_THREAD_ENABLE_PERFORMANCE_INFO*** definido, ThreadX SMP acumula la información siguiente:</span><span class="sxs-lookup"><span data-stu-id="5a912-431">If the ThreadX SMP library and application is built with ***TX_THREAD_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information:</span></span>

<span data-ttu-id="5a912-432">Número total en el sistema general:</span><span class="sxs-lookup"><span data-stu-id="5a912-432">Total number for the overall system:</span></span>

- <span data-ttu-id="5a912-433">reanudaciones de subprocesos</span><span class="sxs-lookup"><span data-stu-id="5a912-433">thread resumptions</span></span>
- <span data-ttu-id="5a912-434">suspensiones de subprocesos</span><span class="sxs-lookup"><span data-stu-id="5a912-434">thread suspensions</span></span>
- <span data-ttu-id="5a912-435">adelantamientos de llamadas a servicios</span><span class="sxs-lookup"><span data-stu-id="5a912-435">service call preemptions</span></span>
- <span data-ttu-id="5a912-436">adelantamientos de interrupciones</span><span class="sxs-lookup"><span data-stu-id="5a912-436">interrupt preemptions</span></span>
- <span data-ttu-id="5a912-437">inversiones de prioridades</span><span class="sxs-lookup"><span data-stu-id="5a912-437">priority inversions</span></span>
- <span data-ttu-id="5a912-438">segmentos temporales</span><span class="sxs-lookup"><span data-stu-id="5a912-438">time-slices</span></span>
- <span data-ttu-id="5a912-439">renuncias</span><span class="sxs-lookup"><span data-stu-id="5a912-439">relinquishes</span></span>
- <span data-ttu-id="5a912-440">tiempos de espera de subprocesos</span><span class="sxs-lookup"><span data-stu-id="5a912-440">thread timeouts</span></span>
- <span data-ttu-id="5a912-441">anulaciones de suspensiones</span><span class="sxs-lookup"><span data-stu-id="5a912-441">suspension aborts</span></span>
- <span data-ttu-id="5a912-442">devoluciones de sistema inactivo</span><span class="sxs-lookup"><span data-stu-id="5a912-442">idle system returns</span></span>
- <span data-ttu-id="5a912-443">devoluciones de sistema no inactivo</span><span class="sxs-lookup"><span data-stu-id="5a912-443">non-idle system returns</span></span>

<span data-ttu-id="5a912-444">Número total en cada subproceso:</span><span class="sxs-lookup"><span data-stu-id="5a912-444">Total number for each thread:</span></span>

- <span data-ttu-id="5a912-445">reanudaciones</span><span class="sxs-lookup"><span data-stu-id="5a912-445">resumptions</span></span>
- <span data-ttu-id="5a912-446">suspensiones</span><span class="sxs-lookup"><span data-stu-id="5a912-446">suspensions</span></span>
- <span data-ttu-id="5a912-447">adelantamientos de llamadas a servicios</span><span class="sxs-lookup"><span data-stu-id="5a912-447">service call preemptions</span></span>
- <span data-ttu-id="5a912-448">adelantamientos de interrupciones</span><span class="sxs-lookup"><span data-stu-id="5a912-448">interrupt preemptions</span></span>
- <span data-ttu-id="5a912-449">inversiones de prioridades</span><span class="sxs-lookup"><span data-stu-id="5a912-449">priority inversions</span></span>
- <span data-ttu-id="5a912-450">segmentos temporales</span><span class="sxs-lookup"><span data-stu-id="5a912-450">time-slices</span></span>
- <span data-ttu-id="5a912-451">renuncias de subprocesos</span><span class="sxs-lookup"><span data-stu-id="5a912-451">thread relinquishes</span></span>
- <span data-ttu-id="5a912-452">tiempos de espera de subprocesos</span><span class="sxs-lookup"><span data-stu-id="5a912-452">thread timeouts</span></span>
- <span data-ttu-id="5a912-453">anulaciones de suspensiones</span><span class="sxs-lookup"><span data-stu-id="5a912-453">suspension aborts</span></span>

<span data-ttu-id="5a912-454">Esta información está disponible en tiempo de ejecución por medio de los servicios *tx_thread_performance_info_get* y *tx_thread_performance_system_info_get*.</span><span class="sxs-lookup"><span data-stu-id="5a912-454">This information is available at run-time through the services *tx_thread_performance_info_get* and *tx_thread_performance_system_info_get*.</span></span> <span data-ttu-id="5a912-455">La información sobre el rendimiento de los subprocesos resulta útil para determinar si la aplicación se comporta de manera correcta.</span><span class="sxs-lookup"><span data-stu-id="5a912-455">Thread performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="5a912-456">También es útil para optimizar la aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-456">It is also useful in optimizing the application.</span></span> <span data-ttu-id="5a912-457">Por ejemplo, un número relativamente alto de adelantamientos de llamadas a servicios puede sugerir que la prioridad o el umbral de adelantamiento del subproceso es demasiado bajo.</span><span class="sxs-lookup"><span data-stu-id="5a912-457">For example, a relatively high number of service call preemptions might suggest the thread’s priority and/or preemption-threshold is too low.</span></span> <span data-ttu-id="5a912-458">Además, un número relativamente bajo de devoluciones de sistema inactivo podría sugerir que los subprocesos de prioridad baja no se suspenden lo suficiente.</span><span class="sxs-lookup"><span data-stu-id="5a912-458">Furthermore, a relatively low number of idle system returns might suggest that lower priority threads are not suspending enough.</span></span>

### <a name="debugging-pitfalls"></a><span data-ttu-id="5a912-459">Problemas de depuración</span><span class="sxs-lookup"><span data-stu-id="5a912-459">Debugging Pitfalls</span></span> 
<span data-ttu-id="5a912-460">La depuración de aplicaciones multiproceso es algo más difícil, ya que el mismo código de programa se puede ejecutar desde varios subprocesos.</span><span class="sxs-lookup"><span data-stu-id="5a912-460">Debugging multithreaded applications is a little more difficult because the same program code can be executed from multiple threads.</span></span> <span data-ttu-id="5a912-461">En esos casos, es posible que no baste con un punto de interrupción.</span><span class="sxs-lookup"><span data-stu-id="5a912-461">In such cases, a break-point alone may not be enough.</span></span> <span data-ttu-id="5a912-462">El depurador también debe ver la matriz de punteros de subproceso actual ***_tx_thread_current_ptr[core]*** con un punto de interrupción condicional para comprobar si el subproceso que realiza la llamada es el que se va a depurar.</span><span class="sxs-lookup"><span data-stu-id="5a912-462">The debugger must also view the current thread pointer array ***_tx_thread_current_ptr[core]*** using a conditional breakpoint to see if the calling thread is the one to debug.</span></span>

<span data-ttu-id="5a912-463">Gran parte de esta operación se controla en los paquetes de soporte de multithreading que ofrecen distintos proveedores de herramientas de desarrollo.</span><span class="sxs-lookup"><span data-stu-id="5a912-463">Much of this is being handled in multithreading support packages offered through various development tool vendors.</span></span> <span data-ttu-id="5a912-464">Debido a su diseño sencillo, la integración de ThreadX SMP con diferentes herramientas de desarrollo es relativamente sencilla.</span><span class="sxs-lookup"><span data-stu-id="5a912-464">Because of its simple design, integrating ThreadX SMP with different development tools is relatively easy.</span></span>

<span data-ttu-id="5a912-465">El tamaño de la pila es siempre un tema de depuración importante en multithreading.</span><span class="sxs-lookup"><span data-stu-id="5a912-465">Stack size is always an important debug topic in multithreading.</span></span> <span data-ttu-id="5a912-466">Siempre que se observa un comportamiento inexplicable, una buena solución inicial suele ser aumentar los tamaños de pila de todos los subprocesos, especialmente el del último que se va a ejecutar.</span><span class="sxs-lookup"><span data-stu-id="5a912-466">Whenever unexplained behavior is observed, it is usually a good first guess to increase stack sizes for all threads—especially the stack size of the last thread to execute!</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5a912-467">También es buena idea compilar la biblioteca de ThreadX SMP con TX_ENABLE_STACK_CHECKING definido.</span><span class="sxs-lookup"><span data-stu-id="5a912-467">It is also a good idea to build the ThreadX SMP library with TX_ENABLE_STACK_CHECKING defined.</span></span> <span data-ttu-id="5a912-468">Esto ayuda a aislar los problemas de daños en la pila en la fase más temprana posible del procesamiento.</span><span class="sxs-lookup"><span data-stu-id="5a912-468">This will help isolate stack corruption problems as early in the processing as possible!</span></span>

## <a name="message-queues"></a><span data-ttu-id="5a912-469">Colas de mensajes</span><span class="sxs-lookup"><span data-stu-id="5a912-469">Message Queues</span></span>

<span data-ttu-id="5a912-470">Las colas de mensajes son el medio principal para la comunicación entre subprocesos en ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="5a912-470">Message queues are the primary means of interthread communication in ThreadX SMP.</span></span> <span data-ttu-id="5a912-471">En una cola de mensajes puede haber uno o varios mensajes.</span><span class="sxs-lookup"><span data-stu-id="5a912-471">One or more messages can reside in a message queue.</span></span> <span data-ttu-id="5a912-472">Una cola de mensajes que contiene un solo mensaje normalmente se denomina *buzón*.</span><span class="sxs-lookup"><span data-stu-id="5a912-472">A message queue that holds a single message is commonly called a *mailbox*.</span></span>

<span data-ttu-id="5a912-473">Los mensajes se copian en una cola por medio de *tx_queue_send* y desde una cola con *tx_queue_receive*.</span><span class="sxs-lookup"><span data-stu-id="5a912-473">Messages are copied to a queue by *tx_queue_send* and are copied from a queue by *tx_queue_receive*.</span></span> <span data-ttu-id="5a912-474">La única excepción es cuando se suspende un subproceso mientras espera un mensaje en una cola vacía.</span><span class="sxs-lookup"><span data-stu-id="5a912-474">The only exception to this is when a thread is suspended while waiting for a message on an empty queue.</span></span> <span data-ttu-id="5a912-475">En este caso, el siguiente mensaje que se envía a la cola se coloca directamente en el área de destino del subproceso.</span><span class="sxs-lookup"><span data-stu-id="5a912-475">In this case, the next message sent to the queue is placed directly into the thread’s destination area.</span></span>

<span data-ttu-id="5a912-476">Cada cola de mensajes es un recurso público.</span><span class="sxs-lookup"><span data-stu-id="5a912-476">Each message queue is a public resource.</span></span> <span data-ttu-id="5a912-477">ThreadX SMP no aplica restricciones al modo en que se usan las colas de mensajes.</span><span class="sxs-lookup"><span data-stu-id="5a912-477">ThreadX SMP places no constraints on how message queues are used.</span></span>

### <a name="creating-message-queues"></a><span data-ttu-id="5a912-478">Creación de colas de mensajes</span><span class="sxs-lookup"><span data-stu-id="5a912-478">Creating Message Queues</span></span> 
<span data-ttu-id="5a912-479">Las colas de mensajes se crean durante la inicialización o durante el tiempo de ejecución por medio de subprocesos de aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-479">Message queues are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="5a912-480">No hay ningún límite en cuanto al número de colas de mensajes de una aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-480">There is no limit on the number of message queues in an application.</span></span> 

### <a name="message-size"></a><span data-ttu-id="5a912-481">Tamaño de los mensajes</span><span class="sxs-lookup"><span data-stu-id="5a912-481">Message Size</span></span> 
<span data-ttu-id="5a912-482">Cada cola de mensajes admite una serie de mensajes de tamaño fijo.</span><span class="sxs-lookup"><span data-stu-id="5a912-482">Each message queue supports a number of fixedsized messages.</span></span> <span data-ttu-id="5a912-483">Los tamaños de mensaje disponibles son de 1 a 16 palabras de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="5a912-483">The available message sizes are 1 through 16 32-bit words inclusive.</span></span> <span data-ttu-id="5a912-484">El tamaño del mensaje se especifica cuando se crea la cola.</span><span class="sxs-lookup"><span data-stu-id="5a912-484">The message size is specified when the queue is created.</span></span> 

<span data-ttu-id="5a912-485">Los mensajes de aplicación de más de 16 palabras se deben pasar mediante un puntero.</span><span class="sxs-lookup"><span data-stu-id="5a912-485">Application messages greater than 16 words must be passed by pointer.</span></span> <span data-ttu-id="5a912-486">Esto se logra mediante la creación de una cola con un tamaño de mensaje de 1 palabra (suficiente para contener un puntero) y, después, el envío y la recepción de punteros de mensaje en lugar del mensaje completo.</span><span class="sxs-lookup"><span data-stu-id="5a912-486">This is accomplished by creating a queue with a message size of 1 word (enough to hold a pointer) and then sending and receiving message pointers instead of the entire message.</span></span>

### <a name="message-queue-capacity"></a><span data-ttu-id="5a912-487">Capacidad de la cola de mensajes</span><span class="sxs-lookup"><span data-stu-id="5a912-487">Message Queue Capacity</span></span> 
<span data-ttu-id="5a912-488">El número de mensajes que puede contener una cola es una función de su tamaño de mensaje y el tamaño del área de memoria suministrada durante la creación.</span><span class="sxs-lookup"><span data-stu-id="5a912-488">The number of messages a queue can hold is a function of its message size and the size of the memory area supplied during creation.</span></span> <span data-ttu-id="5a912-489">Para calcular la capacidad total de mensajes de la cola, se divide el número de bytes de cada mensaje entre el número total de bytes del área de memoria proporcionada.</span><span class="sxs-lookup"><span data-stu-id="5a912-489">The total message capacity of the queue is calculated by dividing the number of bytes in each message into the total number of bytes in the supplied memory area.</span></span>

<span data-ttu-id="5a912-490">Por ejemplo, si se crea una cola de mensajes que admite un tamaño de mensaje de una palabra de 32 bits (4 bytes) con un área de memoria de 100 bytes, su capacidad es de 25 mensajes.</span><span class="sxs-lookup"><span data-stu-id="5a912-490">For example, if a message queue that supports a message size of 1 32-bit word (4 bytes) is created with a 100-byte memory area, its capacity is 25 messages.</span></span>

### <a name="queue-memory-area"></a><span data-ttu-id="5a912-491">Área de memoria de la cola</span><span class="sxs-lookup"><span data-stu-id="5a912-491">Queue Memory Area</span></span> 
<span data-ttu-id="5a912-492">Como se ha mencionado anteriormente, el área de memoria para el almacenamiento en búfer de los mensajes se especifica durante la creación de la cola.</span><span class="sxs-lookup"><span data-stu-id="5a912-492">As mentioned before, the memory area for buffering messages is specified during queue creation.</span></span> <span data-ttu-id="5a912-493">Como sucede con otras áreas de memoria de ThreadX SMP, se puede colocar en cualquier parte del espacio de direcciones del destino.</span><span class="sxs-lookup"><span data-stu-id="5a912-493">Like other memory areas in ThreadX SMP, it can be located anywhere in the target’s address space.</span></span>

<span data-ttu-id="5a912-494">Se trata de una característica importante porque ofrece a la aplicación una gran flexibilidad.</span><span class="sxs-lookup"><span data-stu-id="5a912-494">This is an important feature because it gives the application considerable flexibility.</span></span> <span data-ttu-id="5a912-495">Por ejemplo, una aplicación puede colocar el área de memoria de una cola importante en la memoria RAM de alta velocidad para mejorar el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="5a912-495">For example, an application might locate the memory area of an important queue in high-speed RAM to improve performance.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="5a912-496">Suspensión de subprocesos</span><span class="sxs-lookup"><span data-stu-id="5a912-496">Thread Suspension</span></span>  
<span data-ttu-id="5a912-497">Los subprocesos de aplicación se pueden suspender mientras se intenta enviar o recibir un mensaje de una cola.</span><span class="sxs-lookup"><span data-stu-id="5a912-497">Application threads can suspend while attempting to send or receive a message from a queue.</span></span> <span data-ttu-id="5a912-498">Normalmente, la suspensión de subprocesos implica esperar un mensaje de una cola vacía.</span><span class="sxs-lookup"><span data-stu-id="5a912-498">Typically, thread suspension involves waiting for a message from an empty queue.</span></span> <span data-ttu-id="5a912-499">Pero también es posible que un subproceso se suspenda al intentar enviar un mensaje a una cola completa.</span><span class="sxs-lookup"><span data-stu-id="5a912-499">However, it is also possible for a thread to suspend trying to send a message to a full queue.</span></span> 

<span data-ttu-id="5a912-500">Una vez que se resuelve la condición de la suspensión, el servicio solicitado se completa y se reanuda el subproceso en espera.</span><span class="sxs-lookup"><span data-stu-id="5a912-500">After the condition for suspension is resolved, the service requested is completed and the waiting thread is resumed.</span></span> <span data-ttu-id="5a912-501">Si se suspenden varios subprocesos en la misma cola, se reanudan en el orden en el que se suspendieron (FIFO).</span><span class="sxs-lookup"><span data-stu-id="5a912-501">If multiple threads are suspended on the same queue, they are resumed in the order they were suspended (FIFO).</span></span>

<span data-ttu-id="5a912-502">Pero la reanudación por prioridad también es posible si la aplicación llama a ***tx_queue_prioritize*** antes que al servicio de cola que anula la suspensión de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="5a912-502">However, priority resumption is also possible if the application calls ***tx_queue_prioritize*** prior to the queue service that lifts thread suspension.</span></span> <span data-ttu-id="5a912-503">El servicio de clasificación por orden de prioridad de la cola coloca el subproceso de mayor prioridad al principio de la lista de suspensión y deja a todos los demás subprocesos suspendidos en el mismo orden FIFO.</span><span class="sxs-lookup"><span data-stu-id="5a912-503">The queue prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

<span data-ttu-id="5a912-504">También hay tiempos de espera disponibles para todas las suspensiones de cola.</span><span class="sxs-lookup"><span data-stu-id="5a912-504">Time-outs are also available for all queue suspensions.</span></span> <span data-ttu-id="5a912-505">Básicamente, un tiempo de espera especifica el número máximo de tics de temporizador que el subproceso permanece suspendido.</span><span class="sxs-lookup"><span data-stu-id="5a912-505">Basically, a time-out specifies the maximum number of timer ticks the thread will stay suspended.</span></span> <span data-ttu-id="5a912-506">Si se agota el tiempo de espera, el subproceso se reanuda y el servicio devuelve el código de error adecuado.</span><span class="sxs-lookup"><span data-stu-id="5a912-506">If a time-out occurs, the thread is resumed and the service returns with the appropriate error code.</span></span>

### <a name="queue-send-notification"></a><span data-ttu-id="5a912-507">Notificación de envío a cola</span><span class="sxs-lookup"><span data-stu-id="5a912-507">Queue Send Notification</span></span>  
<span data-ttu-id="5a912-508">Para algunas aplicaciones puede resultar beneficioso recibir una notificación cada vez que un mensaje se coloca en una cola.</span><span class="sxs-lookup"><span data-stu-id="5a912-508">Some applications may find it advantageous to be notified whenever a message is placed on a queue.</span></span> <span data-ttu-id="5a912-509">ThreadX SMP proporciona esta capacidad por medio del servicio *tx_queue_send_notify*.</span><span class="sxs-lookup"><span data-stu-id="5a912-509">ThreadX SMP provides this ability through the *tx_queue_send_notify* service.</span></span> <span data-ttu-id="5a912-510">Este servicio registra la función de notificación de aplicación proporcionada en la cola especificada.</span><span class="sxs-lookup"><span data-stu-id="5a912-510">This service registers the supplied application notification function with the specified queue.</span></span> <span data-ttu-id="5a912-511">Después, ThreadX SMP invoca a esta función de notificación de aplicación cada vez que se envía un mensaje a la cola.</span><span class="sxs-lookup"><span data-stu-id="5a912-511">ThreadX SMP will subsequently invoke this application notification function whenever a message is sent to the queue.</span></span> <span data-ttu-id="5a912-512">El procesamiento exacto dentro de la función de notificación de aplicación viene determinado por la aplicación, aunque normalmente consiste en reanudar el subproceso adecuado para procesar el nuevo mensaje.</span><span class="sxs-lookup"><span data-stu-id="5a912-512">The exact processing within the application notification function is determined by the application; however, it typically consists of resuming the appropriate thread for processing the new message.</span></span>

### <a name="queue-event-chaining"></a><span data-ttu-id="5a912-513">Event-chaining™ de cola</span><span class="sxs-lookup"><span data-stu-id="5a912-513">Queue Event-chaining™</span></span>  
<span data-ttu-id="5a912-514">Las capacidades de notificación de ThreadX SMP se pueden usar para encadenar varios eventos de sincronización.</span><span class="sxs-lookup"><span data-stu-id="5a912-514">The notification capabilities in ThreadX SMP can be used to chain various synchronization events together.</span></span> <span data-ttu-id="5a912-515">Esto suele ser útil cuando un único subproceso debe procesar varios eventos de sincronización.</span><span class="sxs-lookup"><span data-stu-id="5a912-515">This is typically useful when a single thread must process multiple synchronization events.</span></span>

<span data-ttu-id="5a912-516">Por ejemplo, imagine que un único subproceso es responsable de procesar los mensajes de cinco colas diferentes y que también se debe suspender cuando no haya mensajes disponibles.</span><span class="sxs-lookup"><span data-stu-id="5a912-516">For example, suppose a single thread is responsible for processing messages from five different queues and must also suspend when no messages are available.</span></span> <span data-ttu-id="5a912-517">Esto se consigue fácilmente mediante el registro de una función de notificación de aplicación para cada cola y la adición de un semáforo de recuento adicional.</span><span class="sxs-lookup"><span data-stu-id="5a912-517">This is easily accomplished by registering an application notification function for each queue and introducing an additional counting semaphore.</span></span> <span data-ttu-id="5a912-518">En concreto, la función de notificación de aplicación ejecuta *tx_semaphore_put* cada vez que se la llama (el recuento del semáforo representa el número total de mensajes de las cinco colas).</span><span class="sxs-lookup"><span data-stu-id="5a912-518">Specifically, the application notification function performs a *tx_semaphore_put* whenever it is called (the semaphore count represents the total number of messages in all five queues).</span></span> <span data-ttu-id="5a912-519">El subproceso de procesamiento se suspende en este semáforo por medio del servicio *tx_semaphore_get*.</span><span class="sxs-lookup"><span data-stu-id="5a912-519">The processing thread suspends on this semaphore via the *tx_semaphore_get* service.</span></span> <span data-ttu-id="5a912-520">Cuando el semáforo está disponible (en este caso, cuando hay un mensaje disponible), se reanuda el subproceso de procesamiento.</span><span class="sxs-lookup"><span data-stu-id="5a912-520">When the semaphore is available (in this case, when a message is available!), the processing thread is resumed.</span></span> <span data-ttu-id="5a912-521">Después, solicita un mensaje a cada cola, procesa el mensaje encontrado y vuelve a ejecutar *tx_semaphore_get* para esperar al siguiente mensaje.</span><span class="sxs-lookup"><span data-stu-id="5a912-521">It then interrogates each queue for a message, processes the found message, and performs another *tx_semaphore_get* to wait for the next message.</span></span> <span data-ttu-id="5a912-522">La realización de esta tarea sin el encadenamiento de eventos es bastante difícil, y es probable que se necesiten más subprocesos o código de aplicación adicional.</span><span class="sxs-lookup"><span data-stu-id="5a912-522">Accomplishing this without event-chaining is quite difficult and likely would require more threads and/or additional application code.</span></span>

<span data-ttu-id="5a912-523">En general, el *encadenamiento de eventos* genera menos subprocesos, menos sobrecarga y menos requisitos de RAM.</span><span class="sxs-lookup"><span data-stu-id="5a912-523">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="5a912-524">También proporciona un mecanismo muy flexible para controlar los requisitos de sincronización de sistemas más complejos.</span><span class="sxs-lookup"><span data-stu-id="5a912-524">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span>

### <a name="run-time-queue-performance-information"></a><span data-ttu-id="5a912-525">Información de rendimiento de colas en tiempo de ejecución</span><span class="sxs-lookup"><span data-stu-id="5a912-525">Run-time Queue Performance Information</span></span>  
<span data-ttu-id="5a912-526">ThreadX SMP proporciona información opcional sobre el rendimiento de las colas en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="5a912-526">ThreadX SMP provides optional run-time queue performance information.</span></span> <span data-ttu-id="5a912-527">Si la biblioteca de ThreadX SMP y la aplicación se compilan con ***TX_QUEUE_ENABLE_PERFORMANCE_INFO*** definido, ThreadX SMP acumula la información siguiente:</span><span class="sxs-lookup"><span data-stu-id="5a912-527">If the ThreadX SMP library and application is built with ***TX_QUEUE_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information:</span></span>

<span data-ttu-id="5a912-528">Número total en el sistema general:</span><span class="sxs-lookup"><span data-stu-id="5a912-528">Total number for the overall system:</span></span>

- <span data-ttu-id="5a912-529">mensajes enviados</span><span class="sxs-lookup"><span data-stu-id="5a912-529">messages sent</span></span>
- <span data-ttu-id="5a912-530">mensajes recibidos</span><span class="sxs-lookup"><span data-stu-id="5a912-530">messages received</span></span>
- <span data-ttu-id="5a912-531">suspensiones de cola vacía</span><span class="sxs-lookup"><span data-stu-id="5a912-531">queue empty suspensions</span></span>
- <span data-ttu-id="5a912-532">suspensiones de cola llena</span><span class="sxs-lookup"><span data-stu-id="5a912-532">queue full suspensions</span></span>
- <span data-ttu-id="5a912-533">devoluciones de error de cola completa (suspensión sin especificar)</span><span class="sxs-lookup"><span data-stu-id="5a912-533">queue full error returns (suspension not speci-fied)</span></span>
- <span data-ttu-id="5a912-534">tiempos de espera de cola</span><span class="sxs-lookup"><span data-stu-id="5a912-534">queue timeouts</span></span>

<span data-ttu-id="5a912-535">Número total en cada cola:</span><span class="sxs-lookup"><span data-stu-id="5a912-535">Total number for each queue:</span></span>

- <span data-ttu-id="5a912-536">mensajes enviados</span><span class="sxs-lookup"><span data-stu-id="5a912-536">messages sent</span></span>
- <span data-ttu-id="5a912-537">mensajes recibidos</span><span class="sxs-lookup"><span data-stu-id="5a912-537">messages received</span></span>
- <span data-ttu-id="5a912-538">suspensiones de cola vacía</span><span class="sxs-lookup"><span data-stu-id="5a912-538">queue empty suspensions</span></span>
- <span data-ttu-id="5a912-539">suspensiones de cola llena</span><span class="sxs-lookup"><span data-stu-id="5a912-539">queue full suspensions</span></span>
- <span data-ttu-id="5a912-540">devoluciones de error de cola completa (suspensión sin especificar)</span><span class="sxs-lookup"><span data-stu-id="5a912-540">queue full error returns (suspension not speci-fied)</span></span>
- <span data-ttu-id="5a912-541">tiempos de espera de cola</span><span class="sxs-lookup"><span data-stu-id="5a912-541">queue timeouts</span></span>

<span data-ttu-id="5a912-542">Esta información está disponible en tiempo de ejecución por medio de los servicios *tx_queue_performance_info_get* y *tx_queue_performance_system_info_get*.</span><span class="sxs-lookup"><span data-stu-id="5a912-542">This information is available at run-time through the services *tx_queue_performance_info_get* and *tx_queue_performance_system_info_get*.</span></span> <span data-ttu-id="5a912-543">La información de rendimiento de las colas resulta útil para determinar si la aplicación se comporta de manera correcta.</span><span class="sxs-lookup"><span data-stu-id="5a912-543">Queue performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="5a912-544">También es útil para optimizar la aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-544">It is also useful in optimizing the application.</span></span> <span data-ttu-id="5a912-545">Por ejemplo, un número relativamente alto de "suspensiones de cola completa" sugiere que un aumento del tamaño de la cola podría ser beneficioso.</span><span class="sxs-lookup"><span data-stu-id="5a912-545">For example, a relatively high number of “queue full suspensions” suggests an increase in the queue size might be beneficial.</span></span>

### <a name="queue-control-block-tx_queue"></a><span data-ttu-id="5a912-546">Bloque de control de cola TX_QUEUE</span><span class="sxs-lookup"><span data-stu-id="5a912-546">Queue Control Block TX_QUEUE</span></span> 
<span data-ttu-id="5a912-547">Las características de cada cola de mensajes se encuentran en su bloque de control.</span><span class="sxs-lookup"><span data-stu-id="5a912-547">The characteristics of each message queue are found in its control block.</span></span> <span data-ttu-id="5a912-548">Contiene información interesante, como el número de mensajes de la cola.</span><span class="sxs-lookup"><span data-stu-id="5a912-548">It contains interesting information such as the number of messages in the queue.</span></span> <span data-ttu-id="5a912-549">Esta estructura se define en el archivo ***tx_api.h***.</span><span class="sxs-lookup"><span data-stu-id="5a912-549">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="5a912-550">Los bloques de control de cola de mensajes también se pueden colocar en cualquier parte de la memoria, pero es más común convertir el bloque de control en una estructura global mediante su definición fuera del ámbito de cualquier función.</span><span class="sxs-lookup"><span data-stu-id="5a912-550">Message queue control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="message-destination-pitfall"></a><span data-ttu-id="5a912-551">Problema de destino de mensajes</span><span class="sxs-lookup"><span data-stu-id="5a912-551">Message Destination Pitfall</span></span>  
<span data-ttu-id="5a912-552">Como se ha mencionado antes, los mensajes se copian entre el área de cola y las áreas de datos de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-552">As mentioned previously, messages are copied between the queue area and application data areas.</span></span> <span data-ttu-id="5a912-553">Es importante asegurarse de que el destino de un mensaje recibido sea lo suficientemente grande como para contener todo el mensaje.</span><span class="sxs-lookup"><span data-stu-id="5a912-553">It is important to ensure the destination for a received message is large enough to hold the entire message.</span></span> <span data-ttu-id="5a912-554">De lo contrario, es probable que la memoria que sigue al destino del mensaje resulte dañada.</span><span class="sxs-lookup"><span data-stu-id="5a912-554">If not, the memory following the message destination will likely be corrupted.</span></span> 

> [!WARNING]
> <span data-ttu-id="5a912-555">Esto es especialmente grave cuando un destino de mensaje demasiado pequeño está en la pila; no hay nada peor que los daños en la dirección de devolución de una función.</span><span class="sxs-lookup"><span data-stu-id="5a912-555">This is especially lethal when a too-small message destination is on the stack—nothing like corrupting the return address of a function!</span></span>

## <a name="counting-semaphores"></a><span data-ttu-id="5a912-556">Semáforos de recuento</span><span class="sxs-lookup"><span data-stu-id="5a912-556">Counting Semaphores</span></span>

<span data-ttu-id="5a912-557">ThreadX SMP proporciona semáforos de recuento de 32 bits con un valor que oscila entre 0 y 4 294 967 295.</span><span class="sxs-lookup"><span data-stu-id="5a912-557">ThreadX SMP provides 32-bit counting semaphores that range in value between 0 and 4,294,967,295.</span></span> <span data-ttu-id="5a912-558">Hay dos operaciones en los semáforos de recuento: *tx_semaphore_get* y *tx_semaphore_put*.</span><span class="sxs-lookup"><span data-stu-id="5a912-558">There are two operations for counting semaphores: *tx_semaphore_get* and *tx_semaphore_put*.</span></span> <span data-ttu-id="5a912-559">La operación Get reduce el semáforo en uno.</span><span class="sxs-lookup"><span data-stu-id="5a912-559">The get operation decreases the semaphore by one.</span></span> <span data-ttu-id="5a912-560">Si el semáforo es 0, la operación Get no se realiza correctamente.</span><span class="sxs-lookup"><span data-stu-id="5a912-560">If the semaphore is 0, the get operation is not successful.</span></span> <span data-ttu-id="5a912-561">La operación Put es la inversa de la operación Get.</span><span class="sxs-lookup"><span data-stu-id="5a912-561">The inverse of the get operation is the put operation.</span></span> <span data-ttu-id="5a912-562">Aumenta el semáforo en uno.</span><span class="sxs-lookup"><span data-stu-id="5a912-562">It increases the semaphore by one.</span></span>

<span data-ttu-id="5a912-563">Cada semáforo de recuento es un recurso público.</span><span class="sxs-lookup"><span data-stu-id="5a912-563">Each counting semaphore is a public resource.</span></span> <span data-ttu-id="5a912-564">ThreadX SMP no aplica restricciones al modo de uso de los semáforos de recuento.</span><span class="sxs-lookup"><span data-stu-id="5a912-564">ThreadX SMP places no constraints on how counting semaphores are used.</span></span>

<span data-ttu-id="5a912-565">Los semáforos de recuento se suelen usar para la *exclusión mutua*.</span><span class="sxs-lookup"><span data-stu-id="5a912-565">Counting semaphores are typically used for *mutual exclusion*.</span></span> <span data-ttu-id="5a912-566">Pero también se pueden usar como un método para la notificación de eventos.</span><span class="sxs-lookup"><span data-stu-id="5a912-566">However, counting semaphores can also be used as a method for event notification.</span></span>

### <a name="mutual-exclusion"></a><span data-ttu-id="5a912-567">Exclusión mutua</span><span class="sxs-lookup"><span data-stu-id="5a912-567">Mutual Exclusion</span></span> 
<span data-ttu-id="5a912-568">La exclusión mutua se refiere al control del acceso de los subprocesos a determinadas áreas de la aplicación (también denominadas *secciones críticas* o *recursos de aplicación*).</span><span class="sxs-lookup"><span data-stu-id="5a912-568">Mutual exclusion pertains to controlling the access of threads to certain application areas (also called *critical sections* or *application resources*).</span></span> <span data-ttu-id="5a912-569">Cuando se usa para la exclusión mutua, el "recuento actual" de un semáforo representa el número total de subprocesos a los que se permite el acceso.</span><span class="sxs-lookup"><span data-stu-id="5a912-569">When used for mutual exclusion, the “current count” of a semaphore represents the total number of threads that are allowed access.</span></span> <span data-ttu-id="5a912-570">En la mayoría de los casos, los semáforos de recuento usados para la exclusión mutua tienen un valor inicial de 1, lo que significa que solo un subproceso puede acceder al recurso asociado cada vez.</span><span class="sxs-lookup"><span data-stu-id="5a912-570">In most cases, counting semaphores used for mutual exclusion will have an initial value of 1, meaning that only one thread can access the associated resource at a time.</span></span> <span data-ttu-id="5a912-571">Los semáforos de recuento que solo tienen los valores 0 o 1 se denominan normalmente *semáforos binarios*.</span><span class="sxs-lookup"><span data-stu-id="5a912-571">Counting semaphores that only have values of 0 or 1 are commonly called *binary semaphores*.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5a912-572">Si se utiliza un semáforo binario, el usuario debe evitar que el mismo subproceso realice una operación Get en un semáforo que ya posee.</span><span class="sxs-lookup"><span data-stu-id="5a912-572">If a binary semaphore is being used, the user must prevent the same thread from performing a get operation on a semaphore it already owns.</span></span> <span data-ttu-id="5a912-573">Una segunda operación Get no se realizaría correctamente y podría provocar una suspensión indefinida del subproceso que realiza la llamada, así como la falta de disponibilidad permanente del recurso.</span><span class="sxs-lookup"><span data-stu-id="5a912-573">A second get would be unsuccessful and could cause indefinite suspension of the calling thread and permanent unavailability of the resource.</span></span>

### <a name="event-notification"></a><span data-ttu-id="5a912-574">Notificación de evento</span><span class="sxs-lookup"><span data-stu-id="5a912-574">Event Notification</span></span> 
<span data-ttu-id="5a912-575">También es posible usar semáforos de recuento como notificación de eventos, a modo productor-consumidor.</span><span class="sxs-lookup"><span data-stu-id="5a912-575">It is also possible to use counting semaphores as event notification, in a producer-consumer fashion.</span></span> <span data-ttu-id="5a912-576">El consumidor intenta obtener el semáforo de recuento mientras el productor lo aumenta siempre que hay algo disponible.</span><span class="sxs-lookup"><span data-stu-id="5a912-576">The consumer attempts to get the counting semaphore while the producer increases the semaphore whenever something is available.</span></span> <span data-ttu-id="5a912-577">Estos semáforos suelen tener un valor inicial de 0 y no aumentan hasta que el productor tiene algo preparado para el consumidor.</span><span class="sxs-lookup"><span data-stu-id="5a912-577">Such semaphores usually have an initial value of 0 and will not increase until the producer has something ready for the consumer.</span></span> <span data-ttu-id="5a912-578">Los semáforos que se usan para la notificación de eventos también se pueden beneficiar del uso de la llamada al servicio *tx_semaphore_ceiling_put*.</span><span class="sxs-lookup"><span data-stu-id="5a912-578">Semaphores used for event notification may also benefit from use of the *tx_semaphore_ceiling_put* service call.</span></span> <span data-ttu-id="5a912-579">Este servicio garantiza que el recuento del semáforo nunca supere el valor proporcionado en la llamada.</span><span class="sxs-lookup"><span data-stu-id="5a912-579">This service ensures that the semaphore count never exceeds the value supplied in the call.</span></span>

### <a name="creating-counting-semaphores"></a><span data-ttu-id="5a912-580">Creación de semáforos de recuento</span><span class="sxs-lookup"><span data-stu-id="5a912-580">Creating Counting Semaphores</span></span> 
<span data-ttu-id="5a912-581">Los semáforos de recuento se crean durante la inicialización o en tiempo de ejecución mediante subprocesos de aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-581">Counting semaphores are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="5a912-582">El recuento inicial del semáforo se especifica durante la creación.</span><span class="sxs-lookup"><span data-stu-id="5a912-582">The initial count of the semaphore is specified during creation.</span></span> <span data-ttu-id="5a912-583">No hay ningún límite en cuanto al número de semáforos de recuento de una aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-583">There is no limit on the number of counting semaphores in an application.</span></span> 

### <a name="thread-suspension"></a><span data-ttu-id="5a912-584">Suspensión de subprocesos</span><span class="sxs-lookup"><span data-stu-id="5a912-584">Thread Suspension</span></span>  
<span data-ttu-id="5a912-585">Los subprocesos de aplicación se pueden suspender mientras se intenta realizar una operación Get en un semáforo con un recuento actual de 0.</span><span class="sxs-lookup"><span data-stu-id="5a912-585">Application threads can suspend while attempting to perform a get operation on a semaphore with a current count of 0.</span></span> 

<span data-ttu-id="5a912-586">Después de realizar una operación Put, se realiza la operación Get del subproceso suspendido y se reanuda.</span><span class="sxs-lookup"><span data-stu-id="5a912-586">After a put operation is performed, the suspended thread’s get operation is performed and the thread is resumed.</span></span> <span data-ttu-id="5a912-587">Si se suspenden varios subprocesos en el mismo semáforo de recuento, se reanudan en el mismo orden en el que se suspendieron (FIFO).</span><span class="sxs-lookup"><span data-stu-id="5a912-587">If multiple threads are suspended on the same counting semaphore, they are resumed in the same order they were suspended (FIFO).</span></span>

<span data-ttu-id="5a912-588">Pero la reanudación por prioridad también es posible si la aplicación llama a ***tx_semaphore_prioritize*** antes de la llamada a Put del semáforo que anula la suspensión de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="5a912-588">However, priority resumption is also possible if the application calls ***tx_semaphore_prioritize*** prior to the semaphore put call that lifts thread suspension.</span></span> <span data-ttu-id="5a912-589">El servicio de clasificación por orden de prioridad del semáforo coloca al subproceso de mayor prioridad al principio de la lista de suspensión y deja a todos los demás subprocesos suspendidos en el mismo orden FIFO.</span><span class="sxs-lookup"><span data-stu-id="5a912-589">The semaphore prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="semaphore-put-notification"></a><span data-ttu-id="5a912-590">Notificación Put de semáforo</span><span class="sxs-lookup"><span data-stu-id="5a912-590">Semaphore Put Notification</span></span> 
<span data-ttu-id="5a912-591">Para algunas aplicaciones puede resultar beneficioso recibir una notificación cada vez que se coloca un semáforo.</span><span class="sxs-lookup"><span data-stu-id="5a912-591">Some applications may find it advantageous to be notified whenever a semaphore is put.</span></span> <span data-ttu-id="5a912-592">ThreadX SMP proporciona esta capacidad por medio del servicio *tx_semaphore_put_notify*.</span><span class="sxs-lookup"><span data-stu-id="5a912-592">ThreadX SMP provides this ability through the *tx_semaphore_put_notify* service.</span></span> <span data-ttu-id="5a912-593">Este servicio registra la función de notificación de aplicación proporcionada en el semáforo especificado.</span><span class="sxs-lookup"><span data-stu-id="5a912-593">This service registers the supplied application notification function with the specified semaphore.</span></span> <span data-ttu-id="5a912-594">Después, ThreadX SMP invoca a esta función de notificación de aplicación cada vez que se coloca el semáforo.</span><span class="sxs-lookup"><span data-stu-id="5a912-594">ThreadX SMP will subsequently invoke this application notification function whenever the semaphore is put.</span></span> <span data-ttu-id="5a912-595">El procesamiento exacto dentro de la función de notificación de aplicación viene determinado por la aplicación, aunque normalmente consiste en reanudar el subproceso adecuado para procesar el nuevo evento Put del semáforo.</span><span class="sxs-lookup"><span data-stu-id="5a912-595">The exact processing within the application notification function is determined by the application; however, it typically consists of resuming the appropriate thread for processing the new semaphore put event.</span></span>

### <a name="semaphore-eventchaining"></a><span data-ttu-id="5a912-596">Eventchaining™ de semáforo</span><span class="sxs-lookup"><span data-stu-id="5a912-596">Semaphore Eventchaining™</span></span> 
<span data-ttu-id="5a912-597">Las capacidades de notificación de ThreadX SMP se pueden usar para encadenar varios eventos de sincronización.</span><span class="sxs-lookup"><span data-stu-id="5a912-597">The notification capabilities in ThreadX SMP can be used to chain various synchronization events together.</span></span> <span data-ttu-id="5a912-598">Esto suele ser útil cuando un único subproceso debe procesar varios eventos de sincronización.</span><span class="sxs-lookup"><span data-stu-id="5a912-598">This is typically useful when a single thread must process multiple synchronization events.</span></span>

<span data-ttu-id="5a912-599">Por ejemplo, en lugar de suspender subprocesos independientes para un mensaje de cola, marcas de evento y un semáforo, la aplicación puede registrar una rutina de notificación para cada objeto.</span><span class="sxs-lookup"><span data-stu-id="5a912-599">For example, instead of having separate threads suspend for a queue message, event flags, and a semaphore, the application can register a notification routine for each object.</span></span> <span data-ttu-id="5a912-600">Cuando se invoca, la rutina de notificación de aplicación puede reanudar un solo subproceso, que puede solicitar a cada objeto que busque y procese el nuevo evento.</span><span class="sxs-lookup"><span data-stu-id="5a912-600">When invoked, the application notification routine can then resume a single thread, which can interrogate each object to find and process the new event.</span></span>

<span data-ttu-id="5a912-601">En general, el *encadenamiento de eventos* genera menos subprocesos, menos sobrecarga y menos requisitos de RAM.</span><span class="sxs-lookup"><span data-stu-id="5a912-601">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="5a912-602">También proporciona un mecanismo muy flexible para controlar los requisitos de sincronización de sistemas más complejos.</span><span class="sxs-lookup"><span data-stu-id="5a912-602">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span>

### <a name="run-time-semaphore-performance-information"></a><span data-ttu-id="5a912-603">Información de rendimiento de semáforos en tiempo de ejecución</span><span class="sxs-lookup"><span data-stu-id="5a912-603">Run-time Semaphore Performance Information</span></span> 
<span data-ttu-id="5a912-604">ThreadX SMP proporciona información opcional sobre el rendimiento de los semáforos en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="5a912-604">ThreadX SMP provides optional run-time semaphore performance information.</span></span> <span data-ttu-id="5a912-605">Si la biblioteca de ThreadX SMP y la aplicación se compilan con ***TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO*** definido, ThreadX SMP acumula la información siguiente.</span><span class="sxs-lookup"><span data-stu-id="5a912-605">If the ThreadX SMP library and application is built with ***TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information.</span></span> 

<span data-ttu-id="5a912-606">Número total en el sistema general:</span><span class="sxs-lookup"><span data-stu-id="5a912-606">Total number for the overall system:</span></span>

- <span data-ttu-id="5a912-607">operaciones Put de semáforo</span><span class="sxs-lookup"><span data-stu-id="5a912-607">semaphore puts</span></span>
- <span data-ttu-id="5a912-608">operaciones Get de semáforo</span><span class="sxs-lookup"><span data-stu-id="5a912-608">semaphore gets</span></span>
- <span data-ttu-id="5a912-609">suspensiones de operaciones Get de semáforo</span><span class="sxs-lookup"><span data-stu-id="5a912-609">semaphore get suspensions</span></span>
- <span data-ttu-id="5a912-610">tiempos de espera de operaciones Get de semáforo</span><span class="sxs-lookup"><span data-stu-id="5a912-610">semaphore get timeouts</span></span>

<span data-ttu-id="5a912-611">Número total en cada semáforo:</span><span class="sxs-lookup"><span data-stu-id="5a912-611">Total number for each semaphore:</span></span>

- <span data-ttu-id="5a912-612">operaciones Put de semáforo</span><span class="sxs-lookup"><span data-stu-id="5a912-612">semaphore puts</span></span>
- <span data-ttu-id="5a912-613">operaciones Get de semáforo</span><span class="sxs-lookup"><span data-stu-id="5a912-613">semaphore gets</span></span>
- <span data-ttu-id="5a912-614">suspensiones de operaciones Get de semáforo</span><span class="sxs-lookup"><span data-stu-id="5a912-614">semaphore get suspensions</span></span>
- <span data-ttu-id="5a912-615">tiempos de espera de operaciones Get de semáforo</span><span class="sxs-lookup"><span data-stu-id="5a912-615">semaphore get timeouts</span></span>

<span data-ttu-id="5a912-616">Esta información está disponible en tiempo de ejecución por medio de los servicios *tx_semaphore_performance_info_get* y *tx_semaphore_performance_system_info_get*.</span><span class="sxs-lookup"><span data-stu-id="5a912-616">This information is available at run-time through the services *tx_semaphore_performance_info_get* and *tx_semaphore_performance_system_info_get*.</span></span> <span data-ttu-id="5a912-617">La información de rendimiento de los semáforos resulta útil para determinar si la aplicación se comporta de manera correcta.</span><span class="sxs-lookup"><span data-stu-id="5a912-617">Semaphore performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="5a912-618">También es útil para optimizar la aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-618">It is also useful in optimizing the application.</span></span> <span data-ttu-id="5a912-619">Por ejemplo, un número relativamente alto de "tiempos de espera de operaciones Get de semáforo" podría sugerir que otros subprocesos conservan los recursos durante demasiado tiempo.</span><span class="sxs-lookup"><span data-stu-id="5a912-619">For example, a relatively high number of “semaphore get timeouts” might suggest that other threads are holding resources too long.</span></span>

### <a name="semaphore-control-block-tx_semaphore"></a><span data-ttu-id="5a912-620">Bloque de control de semáforos TX_SEMAPHORE</span><span class="sxs-lookup"><span data-stu-id="5a912-620">Semaphore Control Block TX_SEMAPHORE</span></span> 
<span data-ttu-id="5a912-621">Las características de cada semáforo de recuento se encuentran en su bloque de control.</span><span class="sxs-lookup"><span data-stu-id="5a912-621">The characteristics of each counting semaphore are found in its control block.</span></span> <span data-ttu-id="5a912-622">Contiene información como el recuento de semáforos actual.</span><span class="sxs-lookup"><span data-stu-id="5a912-622">It contains information such as the current semaphore count.</span></span> <span data-ttu-id="5a912-623">Esta estructura se define en el archivo ***tx_api.h***.</span><span class="sxs-lookup"><span data-stu-id="5a912-623">This structure is defined in the ***tx_api.h*** file.</span></span> 

<span data-ttu-id="5a912-624">Los bloques de control de semáforos se pueden colocar en cualquier parte de la memoria, pero es más común convertir el bloque de control en una estructura global mediante su definición fuera del ámbito de cualquier función.</span><span class="sxs-lookup"><span data-stu-id="5a912-624">Semaphore control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span> 

### <a name="deadly-embrace"></a><span data-ttu-id="5a912-625">Adopción letal</span><span class="sxs-lookup"><span data-stu-id="5a912-625">Deadly Embrace</span></span> 
<span data-ttu-id="5a912-626">Uno de los problemas más interesantes y peligrosos asociados a los semáforos que se usan para la exclusión mutua es la *adopción letal*.</span><span class="sxs-lookup"><span data-stu-id="5a912-626">One of the most interesting and dangerous pitfalls associated with semaphores used for mutual exclusion is the *deadly embrace*.</span></span> <span data-ttu-id="5a912-627">Una adopción letal, o *interbloqueo*, es una condición en la que dos o más subprocesos se suspenden indefinidamente mientras intentan obtener semáforos que ya son propiedad de cada uno.</span><span class="sxs-lookup"><span data-stu-id="5a912-627">A deadly embrace, or *deadlock*, is a condition in which two or more threads are suspended indefinitely while attempting to get semaphores already owned by each other.</span></span>

<span data-ttu-id="5a912-628">Esta condición se ilustra mejor con un ejemplo de dos subprocesos y dos semáforos.</span><span class="sxs-lookup"><span data-stu-id="5a912-628">This condition is best illustrated by a two thread, two semaphore example.</span></span> <span data-ttu-id="5a912-629">Imagine que el primer subproceso posee el primer semáforo y el segundo subproceso posee el segundo semáforo.</span><span class="sxs-lookup"><span data-stu-id="5a912-629">Suppose the first thread owns the first semaphore and the second thread owns the second semaphore.</span></span> <span data-ttu-id="5a912-630">Si el primer subproceso intenta obtener el segundo semáforo y, al mismo tiempo, el segundo subproceso intenta obtener el primer semáforo, los dos subprocesos entran en una condición de interbloqueo.</span><span class="sxs-lookup"><span data-stu-id="5a912-630">If the first thread attempts to get the second semaphore and at the same time the second thread attempts to get the first semaphore, both threads enter a deadlock condition.</span></span> <span data-ttu-id="5a912-631">Además, si estos subprocesos permanecen suspendidos de manera indefinida, sus recursos asociados también se bloquean para siempre.</span><span class="sxs-lookup"><span data-stu-id="5a912-631">In addition, if these threads stay suspended forever, their associated resources are locked-out forever as well.</span></span> <span data-ttu-id="5a912-632">En la figura 7 de la página 78 se ilustra este ejemplo.</span><span class="sxs-lookup"><span data-stu-id="5a912-632">Figure 7 on page 78 illustrates this example.</span></span>

![Adopción letal](media/image10.png)

<span data-ttu-id="5a912-634">**FIGURA 7. Ejemplo de subprocesos suspendidos**</span><span class="sxs-lookup"><span data-stu-id="5a912-634">**FIGURE 7. Example of Suspended Threads**</span></span>

<span data-ttu-id="5a912-635">En el caso de los sistemas en tiempo real, los interbloqueos se pueden evitar si se aplican determinadas restricciones al modo en que los subprocesos obtienen los semáforos.</span><span class="sxs-lookup"><span data-stu-id="5a912-635">For real-time systems, deadly embraces can be prevented by placing certain restrictions on how threads obtain semaphores.</span></span> <span data-ttu-id="5a912-636">Los subprocesos solo pueden tener un semáforo a la vez.</span><span class="sxs-lookup"><span data-stu-id="5a912-636">Threads can only have one semaphore at a time.</span></span> <span data-ttu-id="5a912-637">Como alternativa, los subprocesos pueden poseer varios semáforos si los obtienen en el mismo orden.</span><span class="sxs-lookup"><span data-stu-id="5a912-637">Alternatively, threads can own multiple semaphores if they gather them in the same order.</span></span> <span data-ttu-id="5a912-638">En el ejemplo anterior, si el primer y el segundo subproceso obtienen el primer y el segundo semáforo en orden, se evita el interbloqueo.</span><span class="sxs-lookup"><span data-stu-id="5a912-638">In the previous example, if the first and second thread obtain the first and second semaphore in order, the deadly embrace is prevented.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5a912-639">También es posible usar el tiempo de espera de suspensión asociado a la operación Get para recuperarse de un interbloqueo.</span><span class="sxs-lookup"><span data-stu-id="5a912-639">It is also possible to use the suspension time-out associated with the get operation to recover from a deadly embrace.</span></span>

### <a name="priority-inversion"></a><span data-ttu-id="5a912-640">Inversión de prioridades</span><span class="sxs-lookup"><span data-stu-id="5a912-640">Priority Inversion</span></span> 
<span data-ttu-id="5a912-641">Otro problema asociado a los semáforos de exclusión mutua es la inversión de prioridades.</span><span class="sxs-lookup"><span data-stu-id="5a912-641">Another pitfall associated with mutual exclusion semaphores is priority inversion.</span></span> <span data-ttu-id="5a912-642">Este tema se trata con más detalle en "Problemas de prioridad de subprocesos" en la página 64.</span><span class="sxs-lookup"><span data-stu-id="5a912-642">This topic is discussed more fully in “Thread Priority Pitfalls” on page 64.</span></span>

<span data-ttu-id="5a912-643">El problema básico se debe a una situación en la que un subproceso de prioridad baja tiene un semáforo que necesita un subproceso de mayor prioridad.</span><span class="sxs-lookup"><span data-stu-id="5a912-643">The basic problem results from a situation in which a lower-priority thread has a semaphore that a higher priority thread needs.</span></span> <span data-ttu-id="5a912-644">En sí mismo, esto es normal.</span><span class="sxs-lookup"><span data-stu-id="5a912-644">This in itself is normal.</span></span> <span data-ttu-id="5a912-645">Pero los subprocesos con prioridades intermedias pueden provocar que la inversión de prioridades dure una cantidad de tiempo no determinista.</span><span class="sxs-lookup"><span data-stu-id="5a912-645">However, threads with priorities in between them may cause the priority inversion to last a nondeterministic amount of time.</span></span> <span data-ttu-id="5a912-646">Esto se puede controlar mediante la selección cuidadosa de las prioridades de los subprocesos, con el umbral de adelantamiento y la elevación temporal de la prioridad del subproceso que posee el recurso a la del subproceso de mayor prioridad.</span><span class="sxs-lookup"><span data-stu-id="5a912-646">This can be handled through careful selection of thread priorities, using preemption-threshold, and temporarily raising the priority of the thread that owns the resource to that of the high priority thread.</span></span>

## <a name="mutexes"></a><span data-ttu-id="5a912-647">Mutexes</span><span class="sxs-lookup"><span data-stu-id="5a912-647">Mutexes</span></span>

<span data-ttu-id="5a912-648">Además de los semáforos, ThreadX SMP también proporciona un objeto de exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="5a912-648">In addition to semaphores, ThreadX SMP also provides a mutex object.</span></span> <span data-ttu-id="5a912-649">Una exclusión mutua es básicamente un semáforo binario, lo que significa que solo un subproceso puede poseer una exclusión mutua cada vez.</span><span class="sxs-lookup"><span data-stu-id="5a912-649">A mutex is basically a binary semaphore, which means that only one thread can own a mutex at a time.</span></span> <span data-ttu-id="5a912-650">Además, el mismo subproceso puede realizar varias veces una operación Get de exclusión mutua correcta en una exclusión mutua en propiedad, 4 294 967 295 para ser exactos.</span><span class="sxs-lookup"><span data-stu-id="5a912-650">In addition, the same thread may perform a successful mutex get operation on an owned mutex multiple times, 4,294,967,295 to be exact.</span></span> <span data-ttu-id="5a912-651">En el objeto de exclusión mutua hay dos operaciones: ***tx_mutex_get** _ y _*_tx_mutex_put_\*\*.</span><span class="sxs-lookup"><span data-stu-id="5a912-651">There are two operations on the mutex object: ***tx_mutex_get** _ and _*_tx_mutex_put_\*\*.</span></span> <span data-ttu-id="5a912-652">La operación Get obtiene una exclusión mutua que no pertenece a otro subproceso, mientras que la operación Put libera una exclusión mutua obtenida previamente.</span><span class="sxs-lookup"><span data-stu-id="5a912-652">The get operation obtains a mutex not owned by another thread, while the put operation releases a previously obtained mutex.</span></span> <span data-ttu-id="5a912-653">Para que un subproceso libere una exclusión mutua, el número de operaciones Put debe ser igual al número de operaciones Get anteriores.</span><span class="sxs-lookup"><span data-stu-id="5a912-653">For a thread to release a mutex, the number of put operations must equal the number of prior get operations.</span></span>

<span data-ttu-id="5a912-654">Cada exclusión mutua es un recurso público.</span><span class="sxs-lookup"><span data-stu-id="5a912-654">Each mutex is a public resource.</span></span> <span data-ttu-id="5a912-655">ThreadX SMP no aplica restricciones al modo de uso de las exclusiones mutuas.</span><span class="sxs-lookup"><span data-stu-id="5a912-655">ThreadX SMP places no constraints on how mutexes are used.</span></span>

<span data-ttu-id="5a912-656">Las exclusiones mutuas de ThreadX SMP se usan únicamente para la *exclusión mutua*.</span><span class="sxs-lookup"><span data-stu-id="5a912-656">ThreadX mutexes are used solely for *mutual exclusion*.</span></span> <span data-ttu-id="5a912-657">A diferencia de los semáforos de recuento, las exclusiones mutuas no se usan como método para la notificación de eventos.</span><span class="sxs-lookup"><span data-stu-id="5a912-657">Unlike counting semaphores, mutexes have no use as a method for event notification.</span></span>

### <a name="mutex-mutual-exclusion"></a><span data-ttu-id="5a912-658">Exclusión mutua de exclusiones mutuas</span><span class="sxs-lookup"><span data-stu-id="5a912-658">Mutex Mutual Exclusion</span></span> 
<span data-ttu-id="5a912-659">De forma similar a la descripción de la sección sobre semáforos de recuento, la exclusión mutua se refiere al control del acceso de los subprocesos a determinadas áreas de la aplicación (también denominadas *secciones críticas* o *recursos de aplicación*).</span><span class="sxs-lookup"><span data-stu-id="5a912-659">Similar to the discussion in the counting semaphore section, mutual exclusion pertains to controlling the access of threads to certain application areas (also called *critical sections* or *application resources*).</span></span> <span data-ttu-id="5a912-660">Cuando está disponible, una exclusión mutua de ThreadX SMP tiene un recuento de propiedad de 0.</span><span class="sxs-lookup"><span data-stu-id="5a912-660">When available, a ThreadX SMP mutex will have an ownership count of 0.</span></span> <span data-ttu-id="5a912-661">Una vez que un subproceso obtiene la exclusión mutua, el recuento de propiedad se incrementa una vez por cada operación Get correcta realizada en la exclusión mutua y se reduce por cada operación Put correcta.</span><span class="sxs-lookup"><span data-stu-id="5a912-661">After the mutex is obtained by a thread, the ownership count is incremented once for every successful get operation performed on the mutex and decremented for every successful put operation.</span></span>

### <a name="creating-mutexes"></a><span data-ttu-id="5a912-662">Creación de exclusiones mutuas</span><span class="sxs-lookup"><span data-stu-id="5a912-662">Creating Mutexes</span></span> 
<span data-ttu-id="5a912-663">Las exclusiones mutuas de ThreadX SMP se crean durante la inicialización o en tiempo de ejecución mediante subprocesos de aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-663">ThreadX SMP mutexes are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="5a912-664">El estado inicial de una exclusión mutua siempre es "disponible".</span><span class="sxs-lookup"><span data-stu-id="5a912-664">The initial condition of a mutex is always “available.”</span></span> <span data-ttu-id="5a912-665">También se puede crear una exclusión mutua con la *herencia de prioridad* seleccionada.</span><span class="sxs-lookup"><span data-stu-id="5a912-665">A mutex may also be created with *priority inheritance* selected.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="5a912-666">Suspensión de subprocesos</span><span class="sxs-lookup"><span data-stu-id="5a912-666">Thread Suspension</span></span> 
<span data-ttu-id="5a912-667">Los subprocesos de aplicación se pueden suspender mientras se intenta realizar una operación Get en una exclusión mutua que ya pertenece a otro subproceso.</span><span class="sxs-lookup"><span data-stu-id="5a912-667">Application threads can suspend while attempting to perform a get operation on a mutex already owned by another thread.</span></span>

<span data-ttu-id="5a912-668">Una vez que el subproceso propietario realiza el mismo número de operaciones Put, se realiza la operación Get del subproceso suspendido, se le asigna la propiedad de la exclusión mutua y se reanuda el subproceso.</span><span class="sxs-lookup"><span data-stu-id="5a912-668">After the same number of put operations are performed by the owning thread, the suspended thread’s get operation is performed, giving it ownership of the mutex, and the thread is resumed.</span></span> <span data-ttu-id="5a912-669">Si se suspenden varios subprocesos en la misma exclusión mutua, se reanudan en el mismo orden en el que se suspendieron (FIFO).</span><span class="sxs-lookup"><span data-stu-id="5a912-669">If multiple threads are suspended on the same mutex, they are resumed in the same order they were suspended (FIFO).</span></span>

<span data-ttu-id="5a912-670">Pero la reanudación por prioridad se realiza de forma automática si durante la creación se ha seleccionado la herencia de prioridad de exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="5a912-670">However, priority resumption is done automatically if the mutex priority inheritance was selected during creation.</span></span> <span data-ttu-id="5a912-671">La reanudación por prioridad también es posible si la aplicación llama a ***tx_mutex_prioritize*** antes de la llamada a Put de la exclusión mutua que anula la suspensión de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="5a912-671">Priority resumption is also possible if the application calls ***tx_mutex_prioritize*** prior to the mutex put call that lifts thread suspension.</span></span> <span data-ttu-id="5a912-672">El servicio de clasificación por orden de prioridad de las exclusiones mutuas coloca al subproceso de mayor prioridad al principio de la lista de suspensión y deja a todos los demás subprocesos suspendidos en el mismo orden FIFO.</span><span class="sxs-lookup"><span data-stu-id="5a912-672">The mutex prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-mutex-performance-information"></a><span data-ttu-id="5a912-673">Información de rendimiento de exclusiones mutuas en tiempo de ejecución</span><span class="sxs-lookup"><span data-stu-id="5a912-673">Run-time Mutex Performance Information</span></span> 
<span data-ttu-id="5a912-674">ThreadX SMP proporciona información opcional sobre el rendimiento de las exclusiones mutuas en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="5a912-674">ThreadX SMP provides optional run-time mutex performance information.</span></span> <span data-ttu-id="5a912-675">Si la biblioteca de ThreadX SMP y la aplicación se compilan con ***TX_MUTEX_ENABLE_PERFORMANCE_INFO*** definido, ThreadX SMP acumula la información siguiente.</span><span class="sxs-lookup"><span data-stu-id="5a912-675">If the ThreadX SMP library and application is built with ***TX_MUTEX_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information.</span></span>

<span data-ttu-id="5a912-676">Número total en el sistema general:</span><span class="sxs-lookup"><span data-stu-id="5a912-676">Total number for the overall system:</span></span>

- <span data-ttu-id="5a912-677">operaciones Put de exclusión mutua</span><span class="sxs-lookup"><span data-stu-id="5a912-677">mutex puts</span></span>
- <span data-ttu-id="5a912-678">operaciones Get de exclusión mutua</span><span class="sxs-lookup"><span data-stu-id="5a912-678">mutex gets</span></span>
- <span data-ttu-id="5a912-679">suspensiones de operaciones Get de exclusión mutua</span><span class="sxs-lookup"><span data-stu-id="5a912-679">mutex get suspensions</span></span>
- <span data-ttu-id="5a912-680">tiempos de espera de operaciones Get de exclusión mutua</span><span class="sxs-lookup"><span data-stu-id="5a912-680">mutex get timeouts</span></span>
- <span data-ttu-id="5a912-681">inversiones de prioridades de exclusión mutua</span><span class="sxs-lookup"><span data-stu-id="5a912-681">mutex priority inversions</span></span>
- <span data-ttu-id="5a912-682">herencia de prioridad de exclusión mutua</span><span class="sxs-lookup"><span data-stu-id="5a912-682">mutex priority inheritances</span></span>

<span data-ttu-id="5a912-683">Número total en cada exclusión mutua:</span><span class="sxs-lookup"><span data-stu-id="5a912-683">Total number for each mutex:</span></span>

- <span data-ttu-id="5a912-684">operaciones Put de exclusión mutua</span><span class="sxs-lookup"><span data-stu-id="5a912-684">mutex puts</span></span>
- <span data-ttu-id="5a912-685">operaciones Get de exclusión mutua</span><span class="sxs-lookup"><span data-stu-id="5a912-685">mutex gets</span></span>
- <span data-ttu-id="5a912-686">suspensiones de operaciones Get de exclusión mutua</span><span class="sxs-lookup"><span data-stu-id="5a912-686">mutex get suspensions</span></span>
- <span data-ttu-id="5a912-687">tiempos de espera de operaciones Get de exclusión mutua</span><span class="sxs-lookup"><span data-stu-id="5a912-687">mutex get timeouts</span></span>
- <span data-ttu-id="5a912-688">inversiones de prioridades de exclusión mutua</span><span class="sxs-lookup"><span data-stu-id="5a912-688">mutex priority inversions</span></span>
- <span data-ttu-id="5a912-689">herencia de prioridad de exclusión mutua</span><span class="sxs-lookup"><span data-stu-id="5a912-689">mutex priority inheritances</span></span>

<span data-ttu-id="5a912-690">Esta información está disponible en tiempo de ejecución por medio de los servicios *tx_mutex_performance_info_get* y *tx_mutex_performance_system_info_get*.</span><span class="sxs-lookup"><span data-stu-id="5a912-690">This information is available at run-time through the services *tx_mutex_performance_info_get* and *tx_mutex_performance_system_info_get*.</span></span> <span data-ttu-id="5a912-691">La información de rendimiento de las exclusiones mutuas resulta útil para determinar si la aplicación se comporta de manera correcta.</span><span class="sxs-lookup"><span data-stu-id="5a912-691">Mutex performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="5a912-692">También es útil para optimizar la aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-692">It is also useful in optimizing the application.</span></span> <span data-ttu-id="5a912-693">Por ejemplo, un número relativamente alto de "tiempos de espera de operaciones Get de exclusiones mutuas" podría sugerir que otros subprocesos conservan los recursos durante demasiado tiempo.</span><span class="sxs-lookup"><span data-stu-id="5a912-693">For example, a relatively high number of “mutex get timeouts” might suggest that other threads are holding resources too long.</span></span>

### <a name="mutex-control-block-tx_mutex"></a><span data-ttu-id="5a912-694">Bloque de control de exclusiones mutuas TX_MUTEX</span><span class="sxs-lookup"><span data-stu-id="5a912-694">Mutex Control Block TX_MUTEX</span></span> 
<span data-ttu-id="5a912-695">Las características de cada exclusión mutua se encuentran en su bloque de control.</span><span class="sxs-lookup"><span data-stu-id="5a912-695">The characteristics of each mutex are found in its control block.</span></span> <span data-ttu-id="5a912-696">Contiene información como el recuento de propiedad de la exclusión mutua actual junto con el puntero del subproceso propietario de la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="5a912-696">It contains information such as the current mutex ownership count along with the pointer of the thread that owns the mutex.</span></span> <span data-ttu-id="5a912-697">Esta estructura se define en el archivo ***tx_api.h***.</span><span class="sxs-lookup"><span data-stu-id="5a912-697">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="5a912-698">Los bloques de control de exclusiones mutuas se pueden colocar en cualquier parte de la memoria, pero es más común convertir el bloque de control en una estructura global mediante su definición fuera del ámbito de cualquier función.</span><span class="sxs-lookup"><span data-stu-id="5a912-698">Mutex control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="deadly-embrace"></a><span data-ttu-id="5a912-699">Adopción letal</span><span class="sxs-lookup"><span data-stu-id="5a912-699">Deadly Embrace</span></span>  
<span data-ttu-id="5a912-700">Uno de los problemas más interesantes y peligrosos asociados a la propiedad de la exclusión mutua es la *adopción letal*.</span><span class="sxs-lookup"><span data-stu-id="5a912-700">One of the most interesting and dangerous pitfalls associated with mutex ownership is the *deadly embrace*.</span></span> <span data-ttu-id="5a912-701">Una adopción letal, o *interbloqueo*, es una condición en la que dos o más subprocesos se suspenden indefinidamente mientras intentan obtener una exclusión mutua que ya pertenece a los otros subprocesos.</span><span class="sxs-lookup"><span data-stu-id="5a912-701">A deadly embrace, or *deadlock*, is a condition where two or more threads are suspended indefinitely while attempting to get a mutex already owned by the other threads.</span></span> <span data-ttu-id="5a912-702">La descripción de *adopción letal* y sus correcciones de la página 77 también es totalmente válida para el objeto de exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="5a912-702">The discussion of *deadly embrace* and its remedies found on page 77 is completely valid for the mutex object as well.</span></span>

### <a name="priority-inversion"></a><span data-ttu-id="5a912-703">Inversión de prioridades</span><span class="sxs-lookup"><span data-stu-id="5a912-703">Priority Inversion</span></span> 
<span data-ttu-id="5a912-704">Como se ha mencionado antes, un problema importante asociado a la exclusión mutua es la inversión de prioridades.</span><span class="sxs-lookup"><span data-stu-id="5a912-704">As mentioned previously, a major pitfall associated with mutual exclusion is priority inversion.</span></span> <span data-ttu-id="5a912-705">Este tema se trata con más detalle en "Problemas de prioridad de subprocesos" en la página 64.</span><span class="sxs-lookup"><span data-stu-id="5a912-705">This topic is discussed more fully in “Thread Priority Pitfalls” on page 64.</span></span> 

<span data-ttu-id="5a912-706">El problema básico se debe a una situación en la que un subproceso de prioridad baja tiene un semáforo que necesita un subproceso de prioridad superior.</span><span class="sxs-lookup"><span data-stu-id="5a912-706">The basic problem results from a situation in which a lower priority thread has a semaphore that a higher priority thread needs.</span></span> <span data-ttu-id="5a912-707">En sí mismo, esto es normal.</span><span class="sxs-lookup"><span data-stu-id="5a912-707">This in itself is normal.</span></span> <span data-ttu-id="5a912-708">Pero los subprocesos con prioridades intermedias pueden provocar que la inversión de prioridades dure una cantidad de tiempo no determinista.</span><span class="sxs-lookup"><span data-stu-id="5a912-708">However, threads with priorities in between them may cause the priority inversion to last a nondeterministic amount of time.</span></span> <span data-ttu-id="5a912-709">A diferencia de los semáforos descritos anteriormente, el objeto de exclusión mutua de ThreadX SMP tiene *herencia de prioridad* opcional.</span><span class="sxs-lookup"><span data-stu-id="5a912-709">Unlike semaphores discussed previously, the ThreadX SMP mutex object has optional *priority inheritance*.</span></span> <span data-ttu-id="5a912-710">La idea básica que subyace a la herencia de prioridad es que se aumenta temporalmente la prioridad de un subproceso de prioridad inferior a la de un subproceso de mayor prioridad que quiere la misma exclusión mutua propiedad del subproceso de prioridad inferior.</span><span class="sxs-lookup"><span data-stu-id="5a912-710">The basic idea behind priority inheritance is that a lower priority thread has its priority raised temporarily to the priority of a high priority thread that wants the same mutex owned by the lower priority thread.</span></span> <span data-ttu-id="5a912-711">Cuando el subproceso de prioridad baja libera la exclusión mutua, se restaura su prioridad original y la propiedad de la exclusión mutua se asigna al subproceso de mayor prioridad.</span><span class="sxs-lookup"><span data-stu-id="5a912-711">When the lower priority thread releases the mutex, its original priority is then restored and the higher priority thread is given ownership of the mutex.</span></span> <span data-ttu-id="5a912-712">Esta característica elimina la inversión de prioridades no determinista mediante el enlace de la cantidad de inversión al tiempo en que el subproceso de prioridad baja conserva la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="5a912-712">This feature eliminates nondeterministic priority inversion by bounding the amount of inversion to the time the lower priority thread holds the mutex.</span></span> <span data-ttu-id="5a912-713">Por supuesto, las técnicas descritas anteriormente en este capítulo para controlar la inversión de prioridades no determinista también son válidas con las exclusiones mutuas.</span><span class="sxs-lookup"><span data-stu-id="5a912-713">Of course, the techniques discussed earlier in this chapter to handle nondeterministic priority inversion are also valid with mutexes as well.</span></span>

## <a name="event-flags"></a><span data-ttu-id="5a912-714">Marcas de eventos</span><span class="sxs-lookup"><span data-stu-id="5a912-714">Event Flags</span></span>

<span data-ttu-id="5a912-715">Las marcas de eventos proporcionan una herramienta eficaz para la sincronización de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="5a912-715">Event flags provide a powerful tool for thread synchronization.</span></span> <span data-ttu-id="5a912-716">Cada marca de evento se representa con un solo bit.</span><span class="sxs-lookup"><span data-stu-id="5a912-716">Each event flag is represented by a single bit.</span></span> <span data-ttu-id="5a912-717">Las marcas de eventos se organizan en grupos de 32.</span><span class="sxs-lookup"><span data-stu-id="5a912-717">Event flags are arranged in groups of 32.</span></span>

<span data-ttu-id="5a912-718">Los subprocesos pueden operar en las 32 marcas de eventos de un grupo al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="5a912-718">Threads can operate on all 32 event flags in a group at the same time.</span></span> <span data-ttu-id="5a912-719">Los eventos se establecen mediante *tx_event_flags_set* y se recuperan con *tx_event_flags_get*.</span><span class="sxs-lookup"><span data-stu-id="5a912-719">Events are set by *tx_event_flags_set* and are retrieved by *tx_event_flags_get*.</span></span>

<span data-ttu-id="5a912-720">Para establecer las marcas de eventos, se realiza una operación AND/OR lógica entre las marcas de eventos actuales y las nuevas.</span><span class="sxs-lookup"><span data-stu-id="5a912-720">Setting event flags is done with a logical AND/OR operation between the current event flags and the new event flags.</span></span> <span data-ttu-id="5a912-721">El tipo de operación lógica (OR o AND) se especifica en la llamada a *tx_event_flags_set*.</span><span class="sxs-lookup"><span data-stu-id="5a912-721">The type of logical operation (either an AND or OR) is specified in the *tx_event_flags_set* call.</span></span>

<span data-ttu-id="5a912-722">Existen opciones lógicas similares para la recuperación de marcas de eventos.</span><span class="sxs-lookup"><span data-stu-id="5a912-722">There are similar logical options for retrieval of event flags.</span></span> <span data-ttu-id="5a912-723">Una solicitud Get puede especificar que todas las marcas de eventos especificadas sean obligatorias (una operación AND lógica).</span><span class="sxs-lookup"><span data-stu-id="5a912-723">A get request can specify that all specified event flags are required (a logical AND).</span></span> <span data-ttu-id="5a912-724">Como alternativa, una solicitud Get puede especificar que cualquiera de las marcas de eventos especificadas satisfaga la solicitud (una operación OR lógica).</span><span class="sxs-lookup"><span data-stu-id="5a912-724">Alternatively, a get request can specify that any of the specified event flags will satisfy the request (a logical OR).</span></span> <span data-ttu-id="5a912-725">El tipo de operación lógica asociada a la recuperación de marcas de eventos se especifica en la llamada a *tx_event_flags_get*.</span><span class="sxs-lookup"><span data-stu-id="5a912-725">The type of logical operation associated with event flags retrieval is specified in the *tx_event_flags_get* call.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5a912-726">Las marcas de eventos que satisfacen una solicitud Get se consumen, es decir, se establecen en cero, si la solicitud especifica **TX_OR_CLEAR** o **TX_AND_CLEAR**.</span><span class="sxs-lookup"><span data-stu-id="5a912-726">Event flags that satisfy a get request are consumed, i.e., set to zero, if **TX_OR_CLEAR** or **TX_AND_CLEAR** are specified by the request.</span></span>

<span data-ttu-id="5a912-727">Cada grupo de marcas de eventos es un recurso público.</span><span class="sxs-lookup"><span data-stu-id="5a912-727">Each event flags group is a public resource.</span></span> <span data-ttu-id="5a912-728">ThreadX SMP no aplica restricciones al modo de uso de los grupos de marcas de eventos.</span><span class="sxs-lookup"><span data-stu-id="5a912-728">ThreadX SMP places no constraints on how event flags groups are used.</span></span>

### <a name="creating-event-flags-groups"></a><span data-ttu-id="5a912-729">Creación de grupos de marcas de eventos</span><span class="sxs-lookup"><span data-stu-id="5a912-729">Creating Event Flags Groups</span></span>
<span data-ttu-id="5a912-730">Los grupos de marcas de eventos se crean durante la inicialización o en tiempo de ejecución mediante subprocesos de aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-730">Event flags groups are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="5a912-731">En el momento de su creación, todas las marcas de eventos del grupo se establecen en cero.</span><span class="sxs-lookup"><span data-stu-id="5a912-731">At the time of their creation, all event flags in the group are set to zero.</span></span> <span data-ttu-id="5a912-732">No hay ningún límite en cuanto al número de grupos de marcas de eventos de una aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-732">There is no limit on the number of event flags groups in an application.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="5a912-733">Suspensión de subprocesos</span><span class="sxs-lookup"><span data-stu-id="5a912-733">Thread Suspension</span></span> 
<span data-ttu-id="5a912-734">Los subprocesos de aplicación se pueden suspender mientras se intenta obtener una combinación lógica de marcas de eventos de un grupo.</span><span class="sxs-lookup"><span data-stu-id="5a912-734">Application threads can suspend while attempting to get any logical combination of event flags from a group.</span></span> <span data-ttu-id="5a912-735">Después de establecer una marca de evento, se revisan las solicitudes Get de todos los subprocesos suspendidos.</span><span class="sxs-lookup"><span data-stu-id="5a912-735">After an event flag is set, the get requests of all suspended threads are reviewed.</span></span> <span data-ttu-id="5a912-736">Se reanudan todos los subprocesos que ahora tienen las marcas de eventos necesarias.</span><span class="sxs-lookup"><span data-stu-id="5a912-736">All the threads that now have the required event flags are resumed.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5a912-737">Todos los subprocesos suspendidos de un grupo de marcas de eventos se revisan cuando se establecen sus marcas de eventos.</span><span class="sxs-lookup"><span data-stu-id="5a912-737">All suspended threads on an event flags group are reviewed when its event flags are set.</span></span> <span data-ttu-id="5a912-738">Esto, por supuesto, aplica una sobrecarga adicional.</span><span class="sxs-lookup"><span data-stu-id="5a912-738">This, of course, introduces additional overhead.</span></span> <span data-ttu-id="5a912-739">Por lo tanto, se recomienda limitar el número de subprocesos que usan el mismo grupo de marcas de eventos a un número razonable.</span><span class="sxs-lookup"><span data-stu-id="5a912-739">Therefore, it is good practice to limit the number of threads using the same event flags group to a reasonable number.</span></span>

### <a name="event-flags-set-notification"></a><span data-ttu-id="5a912-740">Notificación de establecimiento de marcas de eventos</span><span class="sxs-lookup"><span data-stu-id="5a912-740">Event Flags Set Notification</span></span> 
<span data-ttu-id="5a912-741">Para algunas aplicaciones puede resultar beneficioso recibir una notificación cada vez que se establece una marca de evento.</span><span class="sxs-lookup"><span data-stu-id="5a912-741">Some applications may find it advantageous to be notified whenever an event flag is set.</span></span> <span data-ttu-id="5a912-742">ThreadX SMP proporciona esta capacidad por medio del servicio *tx_event_flags_set_notify*.</span><span class="sxs-lookup"><span data-stu-id="5a912-742">ThreadX SMP provides this ability through the *tx_event_flags_set_notify* service.</span></span> <span data-ttu-id="5a912-743">Este servicio registra la función de notificación de aplicación proporcionada en el grupo de marcas de eventos especificado.</span><span class="sxs-lookup"><span data-stu-id="5a912-743">This service registers the supplied application notification function with the specified event flags group.</span></span> <span data-ttu-id="5a912-744">Después, ThreadX SMP invoca a esta función de notificación de aplicación cada vez que se establece una marca de evento en el grupo.</span><span class="sxs-lookup"><span data-stu-id="5a912-744">ThreadX SMP will subsequently invoke this application notification function whenever an event flag in the group is set.</span></span> <span data-ttu-id="5a912-745">El procesamiento exacto dentro de la función de notificación de aplicación viene determinado por la aplicación, pero normalmente consiste en reanudar el subproceso adecuado para procesar la nueva marca de evento.</span><span class="sxs-lookup"><span data-stu-id="5a912-745">The exact processing within the application notification function is determined by the application, but it typically consists of resuming the appropriate thread for processing the new event flag.</span></span> 

### <a name="event-flags-event-chaining"></a><span data-ttu-id="5a912-746">Event-chaining™ de marcas de eventos</span><span class="sxs-lookup"><span data-stu-id="5a912-746">Event Flags Event-chaining™</span></span> 
<span data-ttu-id="5a912-747">Las capacidades de notificación de ThreadX SMP se pueden usar para "encadenar" varios eventos de sincronización.</span><span class="sxs-lookup"><span data-stu-id="5a912-747">The notification capabilities in ThreadX SMP can be used to “chain” various synchronization events together.</span></span> <span data-ttu-id="5a912-748">Esto suele ser útil cuando un único subproceso debe procesar varios eventos de sincronización.</span><span class="sxs-lookup"><span data-stu-id="5a912-748">This is typically useful when a single thread must process multiple synchronization events.</span></span> 

<span data-ttu-id="5a912-749">Por ejemplo, en lugar de suspender subprocesos independientes para un mensaje de cola, marcas de evento y un semáforo, la aplicación puede registrar una rutina de notificación para cada objeto.</span><span class="sxs-lookup"><span data-stu-id="5a912-749">For example, instead of having separate threads suspend for a queue message, event flags, and a semaphore, the application can register a notification routine for each object.</span></span> <span data-ttu-id="5a912-750">Cuando se invoca, la rutina de notificación de aplicación puede reanudar un solo subproceso, que puede solicitar a cada objeto que busque y procese el nuevo evento.</span><span class="sxs-lookup"><span data-stu-id="5a912-750">When invoked, the application notification routine can then resume a single thread, which can interrogate each object to find and process the new event.</span></span> 

<span data-ttu-id="5a912-751">En general, el *encadenamiento de eventos* genera menos subprocesos, menos sobrecarga y menos requisitos de RAM.</span><span class="sxs-lookup"><span data-stu-id="5a912-751">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="5a912-752">También proporciona un mecanismo muy flexible para controlar los requisitos de sincronización de sistemas más complejos.</span><span class="sxs-lookup"><span data-stu-id="5a912-752">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span> 

### <a name="run-time-event-flags-performance-information"></a><span data-ttu-id="5a912-753">Información de rendimiento de marcas de eventos en tiempo de ejecución</span><span class="sxs-lookup"><span data-stu-id="5a912-753">Run-time Event Flags Performance Information</span></span> 
<span data-ttu-id="5a912-754">ThreadX SMP proporciona información opcional sobre el rendimiento de las marcas de eventos en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="5a912-754">ThreadX SMP provides optional run-time event flags performance information.</span></span> <span data-ttu-id="5a912-755">Si la biblioteca de ThreadX SMP y la aplicación se compilan con ***TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO*** definido, ThreadX SMP acumula la información siguiente.</span><span class="sxs-lookup"><span data-stu-id="5a912-755">If the ThreadX SMP library and application is built with ***TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information.</span></span>

<span data-ttu-id="5a912-756">Número total en el sistema general:</span><span class="sxs-lookup"><span data-stu-id="5a912-756">Total number for the overall system:</span></span>

- <span data-ttu-id="5a912-757">operaciones Set de marcas de eventos</span><span class="sxs-lookup"><span data-stu-id="5a912-757">event flags sets</span></span>
- <span data-ttu-id="5a912-758">operaciones Get de marcas de eventos</span><span class="sxs-lookup"><span data-stu-id="5a912-758">event flags gets</span></span>
- <span data-ttu-id="5a912-759">suspensiones de operaciones Get de marcas de eventos</span><span class="sxs-lookup"><span data-stu-id="5a912-759">event flags get suspensions</span></span>
- <span data-ttu-id="5a912-760">tiempos de espera de operaciones Get de marcas de eventos</span><span class="sxs-lookup"><span data-stu-id="5a912-760">event flags get timeouts</span></span>

<span data-ttu-id="5a912-761">Número total en cada grupo de marcas de eventos:</span><span class="sxs-lookup"><span data-stu-id="5a912-761">Total number for each event flags group:</span></span>

- <span data-ttu-id="5a912-762">operaciones Set de marcas de eventos</span><span class="sxs-lookup"><span data-stu-id="5a912-762">event flags sets</span></span>
- <span data-ttu-id="5a912-763">operaciones Get de marcas de eventos</span><span class="sxs-lookup"><span data-stu-id="5a912-763">event flags gets</span></span>
- <span data-ttu-id="5a912-764">suspensiones de operaciones Get de marcas de eventos</span><span class="sxs-lookup"><span data-stu-id="5a912-764">event flags get suspensions</span></span>
- <span data-ttu-id="5a912-765">tiempos de espera de operaciones Get de marcas de eventos</span><span class="sxs-lookup"><span data-stu-id="5a912-765">event flags get timeouts</span></span>

<span data-ttu-id="5a912-766">Esta información está disponible en tiempo de ejecución por medio de los servicios *tx_event_flags_performance_info_get* y *tx_event_flags_performance_system_info_get*.</span><span class="sxs-lookup"><span data-stu-id="5a912-766">This information is available at run-time through the services *tx_event_flags_performance_info_get* and *tx_event_flags_performance_system_info_get*.</span></span> <span data-ttu-id="5a912-767">La información de rendimiento de las marcas de eventos resulta útil para determinar si la aplicación se comporta de manera correcta.</span><span class="sxs-lookup"><span data-stu-id="5a912-767">Event Flags performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="5a912-768">También es útil para optimizar la aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-768">It is also useful in optimizing the application.</span></span> <span data-ttu-id="5a912-769">Por ejemplo, un número relativamente alto de tiempos de espera en el servicio *tx_event_flags_get* podría sugerir que el tiempo de espera de la suspensión de las marcas de eventos es demasiado corto.</span><span class="sxs-lookup"><span data-stu-id="5a912-769">For example, a relatively high number of timeouts on the *tx_event_flags_get* service might suggest that the event flags suspension timeout is too short.</span></span>

### <a name="event-flags-group-control-block-tx_event_flags_group"></a><span data-ttu-id="5a912-770">Bloque de control de grupos de marcas de eventos TX_EVENT_FLAGS_GROUP</span><span class="sxs-lookup"><span data-stu-id="5a912-770">Event Flags Group Control Block TX_EVENT_FLAGS_GROUP</span></span>
<span data-ttu-id="5a912-771">Las características de cada grupo de marcas de eventos se encuentran en su bloque de control.</span><span class="sxs-lookup"><span data-stu-id="5a912-771">The characteristics of each event flags group are found in its control block.</span></span> <span data-ttu-id="5a912-772">Contiene información como la configuración actual de las marcas de eventos y el número de subprocesos suspendidos para eventos.</span><span class="sxs-lookup"><span data-stu-id="5a912-772">It contains information such as the current event flags settings and the number of threads suspended for events.</span></span> <span data-ttu-id="5a912-773">Esta estructura se define en el archivo ***tx_api.h***.</span><span class="sxs-lookup"><span data-stu-id="5a912-773">This structure is defined in the ***tx_api.h*** file.</span></span> 

<span data-ttu-id="5a912-774">Los bloques de control de grupos de eventos se pueden colocar en cualquier parte de la memoria, pero es más común convertir el bloque de control en una estructura global mediante su definición fuera del ámbito de cualquier función.</span><span class="sxs-lookup"><span data-stu-id="5a912-774">Event group control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

## <a name="memory-block-pools"></a><span data-ttu-id="5a912-775">Grupos de bloques de memoria</span><span class="sxs-lookup"><span data-stu-id="5a912-775">Memory Block Pools</span></span>  

<span data-ttu-id="5a912-776">En las aplicaciones en tiempo real, la asignación de memoria de una manera rápida y determinista siempre es un desafío.</span><span class="sxs-lookup"><span data-stu-id="5a912-776">Allocating memory in a fast and deterministic manner is always a challenge in real-time applications.</span></span> <span data-ttu-id="5a912-777">Con esto en mente, ThreadX SMP ofrece la posibilidad de crear y administrar varios grupos de bloques de memoria de tamaño fijo.</span><span class="sxs-lookup"><span data-stu-id="5a912-777">With this in mind, ThreadX SMP provides the ability to create and manage multiple pools of fixed-size memory blocks.</span></span>

<span data-ttu-id="5a912-778">Como los grupos de bloques de memoria se componen de bloques de tamaño fijo, nunca hay problemas de fragmentación.</span><span class="sxs-lookup"><span data-stu-id="5a912-778">Because memory block pools consist of fixed-size blocks, there are never any fragmentation problems.</span></span> <span data-ttu-id="5a912-779">Por supuesto, la fragmentación provoca un comportamiento que es inherentemente no determinista.</span><span class="sxs-lookup"><span data-stu-id="5a912-779">Of course, fragmentation causes behavior that is inherently nondeterministic.</span></span> <span data-ttu-id="5a912-780">Además, el tiempo necesario para asignar y liberar un bloque de memoria de tamaño fijo es comparable al de la manipulación de la lista de vínculo simple.</span><span class="sxs-lookup"><span data-stu-id="5a912-780">In addition, the time required to allocate and free a fixed-size memory block is comparable to that of simple linked-list manipulation.</span></span> <span data-ttu-id="5a912-781">Además, la asignación y desasignación de bloques de memoria se realiza al inicio de la lista disponible.</span><span class="sxs-lookup"><span data-stu-id="5a912-781">Furthermore, memory block allocation and de-allocation is done at the head of the available list.</span></span> <span data-ttu-id="5a912-782">Esto proporciona el procesamiento de la lista de vínculo más rápido posible y puede ayudar a mantener el bloque de memoria real en caché.</span><span class="sxs-lookup"><span data-stu-id="5a912-782">This provides the fastest possible linked list processing and might help keep the actual memory block in cache.</span></span>

<span data-ttu-id="5a912-783">La falta de flexibilidad es el principal inconveniente de los grupos de memoria de tamaño fijo.</span><span class="sxs-lookup"><span data-stu-id="5a912-783">Lack of flexibility is the main drawback of fixed-size memory pools.</span></span> <span data-ttu-id="5a912-784">El tamaño de bloque de un grupo debe ser lo suficientemente grande como para controlar los requisitos de memoria de peor caso de sus usuarios.</span><span class="sxs-lookup"><span data-stu-id="5a912-784">The block size of a pool must be large enough to handle the worst case memory requirements of its users.</span></span> <span data-ttu-id="5a912-785">Por supuesto, es posible que se desperdicie memoria si se realizan muchas solicitudes de memoria de tamaño diferente al mismo grupo.</span><span class="sxs-lookup"><span data-stu-id="5a912-785">Of course, memory may be wasted if many different size memory requests are made to the same pool.</span></span> <span data-ttu-id="5a912-786">Una posible solución es crear varios grupos de bloques de memoria diferentes que contengan bloques de memoria de diferente tamaño.</span><span class="sxs-lookup"><span data-stu-id="5a912-786">A possible solution is to make several different memory block pools that contain different sized memory blocks.</span></span>

<span data-ttu-id="5a912-787">Cada grupo de bloques de memoria es un recurso público.</span><span class="sxs-lookup"><span data-stu-id="5a912-787">Each memory block pool is a public resource.</span></span> <span data-ttu-id="5a912-788">ThreadX SMP no aplica restricciones al modo de uso de los grupos.</span><span class="sxs-lookup"><span data-stu-id="5a912-788">ThreadX SMP places no constraints on how pools are used.</span></span>

### <a name="creating-memory-block-pools"></a><span data-ttu-id="5a912-789">Creación de grupos de bloques de memoria</span><span class="sxs-lookup"><span data-stu-id="5a912-789">Creating Memory Block Pools</span></span>  
<span data-ttu-id="5a912-790">Los grupos de bloques de memoria se crean durante la inicialización o en tiempo de ejecución mediante subprocesos de aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-790">Memory block pools are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="5a912-791">No hay ningún límite en cuanto al número de grupos de bloques de memoria de una aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-791">There is no limit on the number of memory block pools in an application.</span></span>

### <a name="memory-block-size"></a><span data-ttu-id="5a912-792">Tamaño de bloques de memoria</span><span class="sxs-lookup"><span data-stu-id="5a912-792">Memory Block Size</span></span>  
<span data-ttu-id="5a912-793">Como se ha mencionado antes, los grupos de bloques de memoria contienen una serie de bloques de tamaño fijo.</span><span class="sxs-lookup"><span data-stu-id="5a912-793">As mentioned earlier, memory block pools contain a number of fixed-size blocks.</span></span> <span data-ttu-id="5a912-794">El tamaño de bloque, en bytes, se especifica durante la creación del grupo.</span><span class="sxs-lookup"><span data-stu-id="5a912-794">The block size, in bytes, is specified during creation of the pool.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5a912-795">ThreadX SMP agrega una pequeña cantidad de sobrecarga (el tamaño de un puntero de C) a cada bloque de memoria del grupo.</span><span class="sxs-lookup"><span data-stu-id="5a912-795">ThreadX SMP adds a small amount of overhead— the size of a C pointer—to each memory block in the pool.</span></span> <span data-ttu-id="5a912-796">Además, es posible que ThreadX SMP tenga que rellenar el tamaño de bloque para mantener correctamente alineado el principio de cada bloque de memoria.</span><span class="sxs-lookup"><span data-stu-id="5a912-796">In addition, ThreadX SMP might have to pad the block size to keep the beginning of each memory block on proper alignment.</span></span>

### <a name="pool-capacity"></a><span data-ttu-id="5a912-797">Capacidad del grupo</span><span class="sxs-lookup"><span data-stu-id="5a912-797">Pool Capacity</span></span> 
<span data-ttu-id="5a912-798">El número de bloques de memoria de un grupo es una función del tamaño de bloque y el número total de bytes del área de memoria proporcionada durante la creación.</span><span class="sxs-lookup"><span data-stu-id="5a912-798">The number of memory blocks in a pool is a function of the block size and the total number of bytes in the memory area supplied during creation.</span></span> <span data-ttu-id="5a912-799">Para calcular la capacidad de un grupo, se divide el tamaño de bloque (incluido el relleno y los bytes de sobrecarga del puntero) entre el número total de bytes del área de memoria proporcionada.</span><span class="sxs-lookup"><span data-stu-id="5a912-799">The capacity of a pool is calculated by dividing the block size (including padding and the pointer overhead bytes) into the total number of bytes in the supplied memory area.</span></span>

### <a name="pools-memory-area"></a><span data-ttu-id="5a912-800">Área de memoria del grupo</span><span class="sxs-lookup"><span data-stu-id="5a912-800">Pool’s Memory Area</span></span> 
<span data-ttu-id="5a912-801">Como se ha mencionado antes, el área de memoria del grupo de bloques se especifica durante la creación.</span><span class="sxs-lookup"><span data-stu-id="5a912-801">As mentioned before, the memory area for the block pool is specified during creation.</span></span> <span data-ttu-id="5a912-802">Como sucede con otras áreas de memoria de ThreadX SMP, se puede colocar en cualquier parte del espacio de direcciones del destino.</span><span class="sxs-lookup"><span data-stu-id="5a912-802">Like other memory areas in ThreadX SMP, it can be located anywhere in the target’s address space.</span></span>

<span data-ttu-id="5a912-803">Esta es una característica importante debido a la gran flexibilidad que proporciona.</span><span class="sxs-lookup"><span data-stu-id="5a912-803">This is an important feature because of the considerable flexibility it provides.</span></span> <span data-ttu-id="5a912-804">Por ejemplo, imagine que un producto de comunicación tiene un área de memoria de alta velocidad para E/S.</span><span class="sxs-lookup"><span data-stu-id="5a912-804">For example, suppose that a communication product has a highspeed memory area for I/O.</span></span> <span data-ttu-id="5a912-805">Esta área de memoria se administra fácilmente si se convierte en un grupo de bloques de memoria de ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="5a912-805">This memory area is easily managed by making it into a ThreadX SMP memory block pool.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="5a912-806">Suspensión de subprocesos</span><span class="sxs-lookup"><span data-stu-id="5a912-806">Thread Suspension</span></span> 
<span data-ttu-id="5a912-807">Los subprocesos de aplicación se pueden suspender mientras se espera un bloque de memoria de un grupo vacío.</span><span class="sxs-lookup"><span data-stu-id="5a912-807">Application threads can suspend while waiting for a memory block from an empty pool.</span></span> <span data-ttu-id="5a912-808">Cuando se devuelve un bloque al grupo, el subproceso suspendido lo recibe y se reanuda.</span><span class="sxs-lookup"><span data-stu-id="5a912-808">When a block is returned to the pool, the suspended thread is given this block and the thread is resumed.</span></span>

<span data-ttu-id="5a912-809">Si se suspenden varios subprocesos en el mismo grupo de bloques de memoria, se reanudan en el orden en el que se suspendieron (FIFO).</span><span class="sxs-lookup"><span data-stu-id="5a912-809">If multiple threads are suspended on the same memory block pool, they are resumed in the order they were suspended (FIFO).</span></span>

<span data-ttu-id="5a912-810">Pero la reanudación por prioridad también es posible si la aplicación llama a ***tx_block_pool_prioritize*** antes de la llamada de liberación del bloque que anula la suspensión de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="5a912-810">However, priority resumption is also possible if the application calls ***tx_block_pool_prioritize*** prior to the block release call that lifts thread suspension.</span></span> <span data-ttu-id="5a912-811">El servicio de clasificación por orden de prioridad de los grupos de bloques coloca el subproceso de mayor prioridad al principio de la lista de suspensión y deja a todos los demás subprocesos suspendidos en el mismo orden FIFO.</span><span class="sxs-lookup"><span data-stu-id="5a912-811">The block pool prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-block-pool-performance-information"></a><span data-ttu-id="5a912-812">Información de rendimiento de grupos de bloques en tiempo de ejecución</span><span class="sxs-lookup"><span data-stu-id="5a912-812">Run-time Block Pool Performance Information</span></span>  
<span data-ttu-id="5a912-813">ThreadX SMP proporciona información opcional sobre el rendimiento de los grupos de bloques en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="5a912-813">ThreadX SMP provides optional run-time block pool performance information.</span></span> <span data-ttu-id="5a912-814">Si la biblioteca de ThreadX SMP y la aplicación se compilan con ***TX_BLOCK_POOL_ENABLE_PERFORMANCE_INFO*** definido, ThreadX SMP acumula la información siguiente.</span><span class="sxs-lookup"><span data-stu-id="5a912-814">If the ThreadX SMP library and application is built with ***TX_BLOCK_POOL_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information.</span></span>

<span data-ttu-id="5a912-815">Número total en el sistema general:</span><span class="sxs-lookup"><span data-stu-id="5a912-815">Total number for the overall system:</span></span>

- <span data-ttu-id="5a912-816">bloques asignados</span><span class="sxs-lookup"><span data-stu-id="5a912-816">blocks allocated</span></span>
- <span data-ttu-id="5a912-817">bloques liberados</span><span class="sxs-lookup"><span data-stu-id="5a912-817">blocks released</span></span>
- <span data-ttu-id="5a912-818">suspensiones de asignación</span><span class="sxs-lookup"><span data-stu-id="5a912-818">allocation suspensions</span></span>
- <span data-ttu-id="5a912-819">tiempos de espera de asignación</span><span class="sxs-lookup"><span data-stu-id="5a912-819">allocation timeouts</span></span>

<span data-ttu-id="5a912-820">Número total en cada grupo de bloques:</span><span class="sxs-lookup"><span data-stu-id="5a912-820">Total number for each block pool:</span></span>

- <span data-ttu-id="5a912-821">bloques asignados</span><span class="sxs-lookup"><span data-stu-id="5a912-821">blocks allocated</span></span>
- <span data-ttu-id="5a912-822">bloques liberados</span><span class="sxs-lookup"><span data-stu-id="5a912-822">blocks released</span></span>
- <span data-ttu-id="5a912-823">suspensiones de asignación</span><span class="sxs-lookup"><span data-stu-id="5a912-823">allocation suspensions</span></span>
- <span data-ttu-id="5a912-824">tiempos de espera de asignación</span><span class="sxs-lookup"><span data-stu-id="5a912-824">allocation timeouts</span></span>

<span data-ttu-id="5a912-825">Esta información está disponible en tiempo de ejecución por medio de los servicios *tx_block_pool_performance_info_get* y *tx_block_pool_performance_system_info_get*.</span><span class="sxs-lookup"><span data-stu-id="5a912-825">This information is available at run-time through the services *tx_block_pool_performance_info_get* and *tx_block_pool_performance_system_info_get*.</span></span> <span data-ttu-id="5a912-826">La información de rendimiento de los grupos de bloques resulta útil para determinar si la aplicación se comporta de manera correcta.</span><span class="sxs-lookup"><span data-stu-id="5a912-826">Block pool performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="5a912-827">También es útil para optimizar la aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-827">It is also useful in optimizing the application.</span></span> <span data-ttu-id="5a912-828">Por ejemplo, un número relativamente alto de "suspensiones de asignación" podría sugerir que el grupo de bloques es demasiado pequeño.</span><span class="sxs-lookup"><span data-stu-id="5a912-828">For example, a relatively high number of “allocation suspensions” might suggest that the block pool is too small.</span></span>

### <a name="memory-block-pool-control-block-tx_block_pool"></a><span data-ttu-id="5a912-829">Bloque de control de grupos de bloques de memoria TX_BLOCK_POOL</span><span class="sxs-lookup"><span data-stu-id="5a912-829">Memory Block Pool Control Block TX_BLOCK_POOL</span></span>  
<span data-ttu-id="5a912-830">Las características de cada grupo de bloques de memoria se encuentran en su bloque de control.</span><span class="sxs-lookup"><span data-stu-id="5a912-830">The characteristics of each memory block pool are found in its control block.</span></span> <span data-ttu-id="5a912-831">Contiene información como el número de bloques de memoria disponibles y el tamaño de bloque de memoria.</span><span class="sxs-lookup"><span data-stu-id="5a912-831">It contains information such as the number of memory blocks available and the memory pool block size.</span></span> <span data-ttu-id="5a912-832">Esta estructura se define en el archivo ***tx_api.h***.</span><span class="sxs-lookup"><span data-stu-id="5a912-832">This structure is defined in the ***tx_api.h*** file.</span></span> 

<span data-ttu-id="5a912-833">Los bloques de control de grupos también se pueden colocar en cualquier parte de la memoria, pero es más común convertir el bloque de control en una estructura global mediante su definición fuera del ámbito de cualquier función.</span><span class="sxs-lookup"><span data-stu-id="5a912-833">Pool control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span> 

### <a name="overwriting-memory-blocks"></a><span data-ttu-id="5a912-834">Sobrescritura de bloques de memoria</span><span class="sxs-lookup"><span data-stu-id="5a912-834">Overwriting Memory Blocks</span></span>  
<span data-ttu-id="5a912-835">Es importante asegurarse de que el usuario de un bloque de memoria asignado no escriba fuera de sus límites.</span><span class="sxs-lookup"><span data-stu-id="5a912-835">It is important to ensure that the user of an allocated memory block does not write outside its boundaries.</span></span> <span data-ttu-id="5a912-836">Si esto ocurre, se producen daños en un área de memoria adyacente (normalmente posterior).</span><span class="sxs-lookup"><span data-stu-id="5a912-836">If this happens, corruption occurs in an adjacent (usually subsequent) memory area.</span></span> <span data-ttu-id="5a912-837">Los resultados son imprevisibles y, a menudo, graves.</span><span class="sxs-lookup"><span data-stu-id="5a912-837">The results are unpredictable and often fatal!</span></span> 

## <a name="memory-byte-pools"></a><span data-ttu-id="5a912-838">Grupos de bytes de memoria</span><span class="sxs-lookup"><span data-stu-id="5a912-838">Memory Byte Pools</span></span>

<span data-ttu-id="5a912-839">Los grupos de bytes de memoria de ThreadX SMP son similares a un montón de C estándar.</span><span class="sxs-lookup"><span data-stu-id="5a912-839">ThreadX SMP memory byte pools are similar to a standard C heap.</span></span> <span data-ttu-id="5a912-840">A diferencia del montón de C estándar, es posible tener varios grupos de bytes de memoria.</span><span class="sxs-lookup"><span data-stu-id="5a912-840">Unlike the standard C heap, it is possible to have multiple memory byte pools.</span></span> <span data-ttu-id="5a912-841">Además, los subprocesos se pueden suspender en un grupo hasta que la memoria solicitada está disponible.</span><span class="sxs-lookup"><span data-stu-id="5a912-841">In addition, threads can suspend on a pool until the requested memory is available.</span></span>

<span data-ttu-id="5a912-842">Las asignaciones de grupos de bytes de memoria son similares a las llamadas a *malloc* tradicionales, que incluyen la cantidad de memoria deseada (en bytes).</span><span class="sxs-lookup"><span data-stu-id="5a912-842">Allocations from memory byte pools are similar to traditional *malloc* calls, which include the amount of memory desired (in bytes).</span></span> <span data-ttu-id="5a912-843">La asignación de memoria del grupo se hace de modo *el primer adecuado*, es decir, se usa el primer bloque de memoria libre que satisface la solicitud.</span><span class="sxs-lookup"><span data-stu-id="5a912-843">Memory is allocated from the pool in a *first-fit* manner; i.e., the first free memory block that satisfies the request is used.</span></span> <span data-ttu-id="5a912-844">El exceso de memoria de este bloque se convierte en un nuevo bloque y se vuelve a colocar en la lista de memoria libre.</span><span class="sxs-lookup"><span data-stu-id="5a912-844">Excess memory from this block is converted into a new block and placed back in the free memory list.</span></span> <span data-ttu-id="5a912-845">Este proceso se denomina *fragmentación*.</span><span class="sxs-lookup"><span data-stu-id="5a912-845">This process is called *fragmentation*.</span></span>

<span data-ttu-id="5a912-846">Los bloques de memoria libre adyacentes se *combinan* durante una búsqueda de asignación posterior de un bloque de memoria libre suficientemente grande.</span><span class="sxs-lookup"><span data-stu-id="5a912-846">Adjacent free memory blocks are *merged* together during a subsequent allocation search for a large enough free memory block.</span></span> <span data-ttu-id="5a912-847">Este proceso se denomina *desfragmentación*.</span><span class="sxs-lookup"><span data-stu-id="5a912-847">This process is called *de-fragmentation*.</span></span>

<span data-ttu-id="5a912-848">Cada grupo de bytes de memoria es un recurso público.</span><span class="sxs-lookup"><span data-stu-id="5a912-848">Each memory byte pool is a public resource.</span></span> <span data-ttu-id="5a912-849">ThreadX SMP no aplica restricciones al modo de uso de los grupos, a excepción de que no se puede llamar a los servicios de bytes de memoria desde ISR.</span><span class="sxs-lookup"><span data-stu-id="5a912-849">ThreadX SMP places no constraints on how pools are used, except that memory byte services cannot be called from ISRs.</span></span>

### <a name="creating-memory-byte-pools"></a><span data-ttu-id="5a912-850">Creación de grupos de bytes de memoria</span><span class="sxs-lookup"><span data-stu-id="5a912-850">Creating Memory Byte Pools</span></span> 
<span data-ttu-id="5a912-851">Los grupos de bytes de memoria se crean durante la inicialización o en tiempo de ejecución mediante subprocesos de aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-851">Memory byte pools are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="5a912-852">No hay ningún límite en cuanto al número de grupos de bytes de memoria de una aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-852">There is no limit on the number of memory byte pools in an application.</span></span>  

### <a name="pool-capacity"></a><span data-ttu-id="5a912-853">Capacidad del grupo</span><span class="sxs-lookup"><span data-stu-id="5a912-853">Pool Capacity</span></span> 
<span data-ttu-id="5a912-854">El número de bytes que se pueden asignar en un grupo de bytes de memoria es ligeramente inferior al especificado durante la creación.</span><span class="sxs-lookup"><span data-stu-id="5a912-854">The number of allocatable bytes in a memory byte pool is slightly less than what was specified during creation.</span></span> <span data-ttu-id="5a912-855">Esto se debe a que la administración del área de memoria libre genera cierta sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="5a912-855">This is because management of the free memory area introduces some overhead.</span></span> <span data-ttu-id="5a912-856">Cada bloque de memoria libre del grupo necesita el equivalente a dos punteros de C de sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="5a912-856">Each free memory block in the pool requires the equivalent of two C pointers of overhead.</span></span> <span data-ttu-id="5a912-857">Además, el grupo se crea con dos bloques, un bloque libre grande y uno pequeño asignado de forma permanente al final del área de memoria.</span><span class="sxs-lookup"><span data-stu-id="5a912-857">In addition, the pool is created with two blocks, a large free block and a small permanently allocated block at the end of the memory area.</span></span> <span data-ttu-id="5a912-858">Este bloque asignado se usa para mejorar el rendimiento del algoritmo de asignación.</span><span class="sxs-lookup"><span data-stu-id="5a912-858">This allocated block is used to improve performance of the allocation algorithm.</span></span> <span data-ttu-id="5a912-859">Elimina la necesidad de comprobar continuamente el final del área del grupo durante la combinación.</span><span class="sxs-lookup"><span data-stu-id="5a912-859">It eliminates the need to continuously check for the end of the pool area during merging.</span></span>  

<span data-ttu-id="5a912-860">Durante el tiempo de ejecución, la cantidad de sobrecarga del grupo suele aumentar.</span><span class="sxs-lookup"><span data-stu-id="5a912-860">During run-time, the amount of overhead in the pool typically increases.</span></span> <span data-ttu-id="5a912-861">Las asignaciones de un número impar de bytes se rellenan para garantizar la alineación adecuada del bloque de memoria siguiente.</span><span class="sxs-lookup"><span data-stu-id="5a912-861">Allocations of an odd number of bytes are padded to ensure proper alignment of the next memory block.</span></span> <span data-ttu-id="5a912-862">Además, la sobrecarga aumenta a medida que el grupo se va fragmentando.</span><span class="sxs-lookup"><span data-stu-id="5a912-862">In addition, overhead increases as the pool becomes more fragmented.</span></span>

### <a name="pools-memory-area"></a><span data-ttu-id="5a912-863">Área de memoria del grupo</span><span class="sxs-lookup"><span data-stu-id="5a912-863">Pool’s Memory Area</span></span>  
<span data-ttu-id="5a912-864">El área de memoria de un grupo de bytes de memoria se especifica durante la creación.</span><span class="sxs-lookup"><span data-stu-id="5a912-864">The memory area for a memory byte pool is specified during creation.</span></span> <span data-ttu-id="5a912-865">Como sucede con otras áreas de memoria de ThreadX SMP, se puede colocar en cualquier parte del espacio de direcciones del destino.</span><span class="sxs-lookup"><span data-stu-id="5a912-865">Like other memory areas in ThreadX SMP, it can be located anywhere in the target’s address space.</span></span> 

<span data-ttu-id="5a912-866">Esta es una característica importante debido a la gran flexibilidad que proporciona.</span><span class="sxs-lookup"><span data-stu-id="5a912-866">This is an important feature because of the considerable flexibility it provides.</span></span> <span data-ttu-id="5a912-867">Por ejemplo, si el hardware de destino tiene un área de memoria de alta velocidad y otra de baja velocidad, el usuario puede administrar la asignación de memoria de las dos áreas si crea un grupo en cada una de ellas.</span><span class="sxs-lookup"><span data-stu-id="5a912-867">For example, if the target hardware has a high-speed memory area and a low-speed memory area, the user can manage memory allocation for both areas by creating a pool in each of them.</span></span> 

### <a name="thread-suspension"></a><span data-ttu-id="5a912-868">Suspensión de subprocesos</span><span class="sxs-lookup"><span data-stu-id="5a912-868">Thread Suspension</span></span>  
<span data-ttu-id="5a912-869">Los subprocesos de aplicación se pueden suspender mientras se esperan bytes de memoria de un grupo.</span><span class="sxs-lookup"><span data-stu-id="5a912-869">Application threads can suspend while waiting for memory bytes from a pool.</span></span> <span data-ttu-id="5a912-870">Cuando hay suficiente memoria contigua disponible, los subprocesos suspendidos reciben la memoria solicitada y se reanudan.</span><span class="sxs-lookup"><span data-stu-id="5a912-870">When sufficient contiguous memory becomes available, the suspended threads are given their requested memory and the threads are resumed.</span></span> 

<span data-ttu-id="5a912-871">Si se suspenden varios subprocesos en el mismo grupo de bytes de memoria, se les asigna memoria (se reanudan) en el orden en el que se suspendieron (FIFO).</span><span class="sxs-lookup"><span data-stu-id="5a912-871">If multiple threads are suspended on the same memory byte pool, they are given memory (resumed) in the order they were suspended (FIFO).</span></span> 

<span data-ttu-id="5a912-872">Pero la reanudación por prioridad también es posible si la aplicación llama a ***tx_byte_pool_prioritize*** antes de la llamada de liberación de bytes que anula la suspensión de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="5a912-872">However, priority resumption is also possible if the application calls ***tx_byte_pool_prioritize*** prior to the byte release call that lifts thread suspension.</span></span> <span data-ttu-id="5a912-873">El servicio de clasificación por orden de prioridad de los grupos de bytes coloca el subproceso de mayor prioridad al principio de la lista de suspensión y deja a todos los demás subprocesos suspendidos en el mismo orden FIFO.</span><span class="sxs-lookup"><span data-stu-id="5a912-873">The byte pool prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-byte-pool-performance-information"></a><span data-ttu-id="5a912-874">Información de rendimiento de grupos de bytes en tiempo de ejecución</span><span class="sxs-lookup"><span data-stu-id="5a912-874">Run-time Byte Pool Performance Information</span></span>  
<span data-ttu-id="5a912-875">ThreadX SMP proporciona información opcional sobre el rendimiento de los grupos de bytes en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="5a912-875">ThreadX SMP provides optional run-time byte pool performance information.</span></span> <span data-ttu-id="5a912-876">Si la biblioteca de ThreadX SMP y la aplicación se compilan con ***TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO*** definido, ThreadX SMP acumula la información siguiente.</span><span class="sxs-lookup"><span data-stu-id="5a912-876">If the ThreadX SMP library and application is built with ***TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information.</span></span>

<span data-ttu-id="5a912-877">Número total en el sistema general:</span><span class="sxs-lookup"><span data-stu-id="5a912-877">Total number for the overall system:</span></span>

- <span data-ttu-id="5a912-878">asignaciones</span><span class="sxs-lookup"><span data-stu-id="5a912-878">allocations</span></span>
- <span data-ttu-id="5a912-879">versiones</span><span class="sxs-lookup"><span data-stu-id="5a912-879">releases</span></span>
- <span data-ttu-id="5a912-880">fragmentos buscados</span><span class="sxs-lookup"><span data-stu-id="5a912-880">fragments searched</span></span>
- <span data-ttu-id="5a912-881">fragmentos combinados</span><span class="sxs-lookup"><span data-stu-id="5a912-881">fragments merged</span></span>
- <span data-ttu-id="5a912-882">fragmentos creados</span><span class="sxs-lookup"><span data-stu-id="5a912-882">fragments created</span></span>
- <span data-ttu-id="5a912-883">suspensiones de asignación</span><span class="sxs-lookup"><span data-stu-id="5a912-883">allocation suspensions</span></span>
- <span data-ttu-id="5a912-884">tiempos de espera de asignación</span><span class="sxs-lookup"><span data-stu-id="5a912-884">allocation timeouts</span></span>

<span data-ttu-id="5a912-885">Número total en cada grupo de bytes:</span><span class="sxs-lookup"><span data-stu-id="5a912-885">Total number for each byte pool:</span></span>

- <span data-ttu-id="5a912-886">asignaciones</span><span class="sxs-lookup"><span data-stu-id="5a912-886">allocations</span></span>
- <span data-ttu-id="5a912-887">versiones</span><span class="sxs-lookup"><span data-stu-id="5a912-887">releases</span></span>
- <span data-ttu-id="5a912-888">fragmentos buscados</span><span class="sxs-lookup"><span data-stu-id="5a912-888">fragments searched</span></span>
- <span data-ttu-id="5a912-889">fragmentos combinados</span><span class="sxs-lookup"><span data-stu-id="5a912-889">fragments merged</span></span>
- <span data-ttu-id="5a912-890">fragmentos creados</span><span class="sxs-lookup"><span data-stu-id="5a912-890">fragments created</span></span>
- <span data-ttu-id="5a912-891">suspensiones de asignación</span><span class="sxs-lookup"><span data-stu-id="5a912-891">allocation suspensions</span></span>
- <span data-ttu-id="5a912-892">tiempos de espera de asignación</span><span class="sxs-lookup"><span data-stu-id="5a912-892">allocation timeouts</span></span>

<span data-ttu-id="5a912-893">Esta información está disponible en tiempo de ejecución por medio de los servicios *tx_byte_pool_performance_info_get* y *tx_byte_pool_performance_system_info_get*.</span><span class="sxs-lookup"><span data-stu-id="5a912-893">This information is available at run-time through the services *tx_byte_pool_performance_info_get* and *tx_byte_pool_performance_system_info_get*.</span></span> <span data-ttu-id="5a912-894">La información de rendimiento de los grupos de bytes resulta útil para determinar si la aplicación se comporta de manera correcta.</span><span class="sxs-lookup"><span data-stu-id="5a912-894">Byte pool performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="5a912-895">También es útil para optimizar la aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-895">It is also useful in optimizing the application.</span></span> <span data-ttu-id="5a912-896">Por ejemplo, un número relativamente alto de "suspensiones de asignación" podría sugerir que el grupo de bytes es demasiado pequeño.</span><span class="sxs-lookup"><span data-stu-id="5a912-896">For example, a relatively high number of “allocation suspensions” might suggest that the byte pool is too small.</span></span>

### <a name="memory-byte-pool-control-block-tx_byte_pool"></a><span data-ttu-id="5a912-897">Bloque de control de grupos de bytes de memoria TX_BYTE_POOL</span><span class="sxs-lookup"><span data-stu-id="5a912-897">Memory Byte Pool Control Block TX_BYTE_POOL</span></span>  
<span data-ttu-id="5a912-898">Las características de cada grupo de bytes de memoria se encuentran en su bloque de control.</span><span class="sxs-lookup"><span data-stu-id="5a912-898">The characteristics of each memory byte pool are found in its control block.</span></span> <span data-ttu-id="5a912-899">Contiene información útil, como el número de bytes disponibles en el grupo.</span><span class="sxs-lookup"><span data-stu-id="5a912-899">It contains useful information such as the number of available bytes in the pool.</span></span> <span data-ttu-id="5a912-900">Esta estructura se define en el archivo ***tx_api.h***.</span><span class="sxs-lookup"><span data-stu-id="5a912-900">This structure is defined in the ***tx_api.h*** file.</span></span> 

<span data-ttu-id="5a912-901">Los bloques de control de grupos también se pueden colocar en cualquier parte de la memoria, pero es más común convertir el bloque de control en una estructura global mediante su definición fuera del ámbito de cualquier función.</span><span class="sxs-lookup"><span data-stu-id="5a912-901">Pool control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span> 

### <a name="nondeterministic-behavior"></a><span data-ttu-id="5a912-902">Comportamiento no determinista</span><span class="sxs-lookup"><span data-stu-id="5a912-902">Nondeterministic Behavior</span></span> 
<span data-ttu-id="5a912-903">Aunque los grupos de bytes de memoria proporcionan la asignación de memoria más flexible, también sufren un comportamiento no determinista.</span><span class="sxs-lookup"><span data-stu-id="5a912-903">Although memory byte pools provide the most flexible memory allocation, they also suffer from somewhat nondeterministic behavior.</span></span> <span data-ttu-id="5a912-904">Por ejemplo, un grupo de bytes de memoria puede tener 2000 bytes de memoria disponibles, pero es posible que no pueda satisfacer una solicitud de asignación de 1000 bytes.</span><span class="sxs-lookup"><span data-stu-id="5a912-904">For example, a memory byte pool may have 2,000 bytes of memory available but may not be able to satisfy an allocation request of 1,000 bytes.</span></span> <span data-ttu-id="5a912-905">Esto se debe a que no hay ninguna garantía sobre cuántos de los bytes libres son contiguos.</span><span class="sxs-lookup"><span data-stu-id="5a912-905">This is because there are no guarantees on how many of the free bytes are contiguous.</span></span> <span data-ttu-id="5a912-906">Incluso si existe un bloque libre de 1000 bytes, no hay ninguna garantía sobre el tiempo que se puede tardar en encontrar el bloque.</span><span class="sxs-lookup"><span data-stu-id="5a912-906">Even if a 1,000 byte free block exists, there are no guarantees on how long it might take to find the block.</span></span> <span data-ttu-id="5a912-907">Es totalmente posible que sea necesario buscar en todo el grupo de memoria para encontrar el bloque de 1000 bytes.</span><span class="sxs-lookup"><span data-stu-id="5a912-907">It is completely possible that the entire memory pool would need to be searched to find the 1,000 byte block.</span></span> 

> [!IMPORTANT]
> <span data-ttu-id="5a912-908">Por este motivo, suele ser recomendable evitar el uso de servicios de bytes de memoria en áreas donde se requiere un comportamiento determinista en tiempo real.</span><span class="sxs-lookup"><span data-stu-id="5a912-908">Because of this, it is generally good practice to avoid using memory byte services in areas where deterministic, real-time behavior is required.</span></span> <span data-ttu-id="5a912-909">Muchas aplicaciones preasignan su memoria necesaria durante la inicialización o la configuración en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="5a912-909">Many applications pre-allocate their required memory during initialization or run-time configuration.</span></span>

### <a name="overwriting-memory-blocks"></a><span data-ttu-id="5a912-910">Sobrescritura de bloques de memoria</span><span class="sxs-lookup"><span data-stu-id="5a912-910">Overwriting Memory Blocks</span></span> 
<span data-ttu-id="5a912-911">Es importante asegurarse de que el usuario de la memoria asignada no escriba fuera de sus límites.</span><span class="sxs-lookup"><span data-stu-id="5a912-911">It is important to ensure that the user of allocated memory does not write outside its boundaries.</span></span> <span data-ttu-id="5a912-912">Si esto ocurre, se producen daños en un área de memoria adyacente (normalmente posterior).</span><span class="sxs-lookup"><span data-stu-id="5a912-912">If this happens, corruption occurs in an adjacent (usually subsequent) memory area.</span></span> <span data-ttu-id="5a912-913">Los resultados son imprevisibles y, a menudo, graves.</span><span class="sxs-lookup"><span data-stu-id="5a912-913">The results are unpredictable and often fatal!</span></span> 

## <a name="application-timers"></a><span data-ttu-id="5a912-914">Temporizadores de aplicación</span><span class="sxs-lookup"><span data-stu-id="5a912-914">Application Timers</span></span>

<span data-ttu-id="5a912-915">La respuesta rápida a los eventos externos asincrónicos es la función más importante de las aplicaciones insertadas en tiempo real.</span><span class="sxs-lookup"><span data-stu-id="5a912-915">Fast response to asynchronous external events is the most important function of real-time, embedded applications.</span></span> <span data-ttu-id="5a912-916">Pero muchas de estas aplicaciones también deben realizar determinadas actividades a intervalos de tiempo predeterminados.</span><span class="sxs-lookup"><span data-stu-id="5a912-916">However, many of these applications must also perform certain activities at pre-determined intervals of time.</span></span>

<span data-ttu-id="5a912-917">Los temporizadores de aplicación de ThreadX SMP ofrecen a las aplicaciones la posibilidad de ejecutar funciones de aplicaciones de C a intervalos de tiempo concretos.</span><span class="sxs-lookup"><span data-stu-id="5a912-917">ThreadX SMP application timers provide applications with the ability to execute application C functions at specific intervals of time.</span></span> <span data-ttu-id="5a912-918">También es posible que un temporizador de aplicación expire una sola vez.</span><span class="sxs-lookup"><span data-stu-id="5a912-918">It is also possible for an application timer to expire only once.</span></span> <span data-ttu-id="5a912-919">Este tipo de temporizador se denomina *temporizador único*, mientras que los temporizadores con intervalos repetidos se denominan *temporizadores periódicos*.</span><span class="sxs-lookup"><span data-stu-id="5a912-919">This type of timer is called a *one-shot timer*, while repeating interval timers are called *periodic timers*.</span></span>

<span data-ttu-id="5a912-920">Cada temporizador de aplicación es un recurso público.</span><span class="sxs-lookup"><span data-stu-id="5a912-920">Each application timer is a public resource.</span></span> <span data-ttu-id="5a912-921">ThreadX SMP no aplica restricciones al modo de uso de los temporizadores de aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-921">ThreadX SMP places no constraints on how application timers are used.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5a912-922">Los temporizadores de aplicación se pueden excluir de la ejecución en cualquier núcleo por medio de la API tx_timer_smp_core_exclude.</span><span class="sxs-lookup"><span data-stu-id="5a912-922">Application timers can be excluded from execution on any core via the tx_timer_smp_core_exclude API.</span></span>

### <a name="timer-intervals"></a><span data-ttu-id="5a912-923">Intervalos de temporizador</span><span class="sxs-lookup"><span data-stu-id="5a912-923">Timer Intervals</span></span> 
<span data-ttu-id="5a912-924">En ThreadX SMP, los intervalos de tiempo se miden mediante interrupciones periódicas de temporizador.</span><span class="sxs-lookup"><span data-stu-id="5a912-924">In ThreadX SMP time intervals are measured by periodic timer interrupts.</span></span> <span data-ttu-id="5a912-925">Cada interrupción de temporizador se denomina *tic* de temporizador.</span><span class="sxs-lookup"><span data-stu-id="5a912-925">Each timer interrupt is called a timer *tick*.</span></span> <span data-ttu-id="5a912-926">La aplicación especifica el tiempo real entre tics de temporizador, pero 10 ms es la norma en la mayoría de las implementaciones.</span><span class="sxs-lookup"><span data-stu-id="5a912-926">The actual time between timer ticks is specified by the application, but 10ms is the norm for most implementations.</span></span> <span data-ttu-id="5a912-927">La configuración del temporizador periódico normalmente se encuentra en el archivo de ensamblado ***tx_initialize_low_level***.</span><span class="sxs-lookup"><span data-stu-id="5a912-927">The periodic timer setup is typically found in the ***tx_initialize_low_level*** assembly file.</span></span>

<span data-ttu-id="5a912-928">Merece la pena mencionar que el hardware subyacente debe tener la capacidad de generar interrupciones periódicas para que los temporizadores de aplicación funcionen.</span><span class="sxs-lookup"><span data-stu-id="5a912-928">It is worth mentioning that the underlying hardware must have the ability to generate periodic interrupts for application timers to function.</span></span> <span data-ttu-id="5a912-929">En algunos casos, el procesador tiene una capacidad de interrupción periódica integrada.</span><span class="sxs-lookup"><span data-stu-id="5a912-929">In some cases, the processor has a built-in periodic interrupt capability.</span></span> <span data-ttu-id="5a912-930">Si el procesador no tiene esta capacidad, el panel del usuario debe tener un dispositivo periférico que pueda generar interrupciones periódicas.</span><span class="sxs-lookup"><span data-stu-id="5a912-930">If the processor doesn’t have this ability, the user’s board must have a peripheral device that can generate periodic interrupts.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5a912-931">ThreadX SMP puede seguir funcionando incluso sin origen de interrupción periódico,</span><span class="sxs-lookup"><span data-stu-id="5a912-931">ThreadX SMP can still function even without a periodic interrupt source.</span></span> <span data-ttu-id="5a912-932">aunque en ese caso se deshabilita todo el procesamiento relacionado con el temporizador.</span><span class="sxs-lookup"><span data-stu-id="5a912-932">However, all timer-related processing is then disabled.</span></span> <span data-ttu-id="5a912-933">Esto incluye la segmentación temporal, los tiempos de espera de suspensión y los servicios de temporizador.</span><span class="sxs-lookup"><span data-stu-id="5a912-933">This includes timeslicing, suspension time-outs, and timer services.</span></span>

### <a name="timer-accuracy"></a><span data-ttu-id="5a912-934">Precisión del temporizador</span><span class="sxs-lookup"><span data-stu-id="5a912-934">Timer Accuracy</span></span> 
<span data-ttu-id="5a912-935">Las expiraciones del temporizador se especifican en tics.</span><span class="sxs-lookup"><span data-stu-id="5a912-935">Timer expirations are specified in terms of ticks.</span></span> <span data-ttu-id="5a912-936">El valor de expiración especificado se reduce en uno en cada tic del temporizador.</span><span class="sxs-lookup"><span data-stu-id="5a912-936">The specified expiration value is decreased by one on each timer tick.</span></span> <span data-ttu-id="5a912-937">Como un temporizador de aplicación se puede habilitar justo antes de una interrupción del temporizador (o tic), el tiempo de expiración real puede ser hasta un tic anterior.</span><span class="sxs-lookup"><span data-stu-id="5a912-937">Because an application timer could be enabled just prior to a timer interrupt (or timer tick), the actual expiration time could be up to one tick early.</span></span>

<span data-ttu-id="5a912-938">Si la tasa de tics del temporizador es de 10 ms, los temporizadores de aplicación pueden expirar hasta 10 ms antes.</span><span class="sxs-lookup"><span data-stu-id="5a912-938">If the timer tick rate is 10ms, application timers may expire up to 10ms early.</span></span> <span data-ttu-id="5a912-939">Esto es más importante para temporizadores de 10 ms que para los de 1 segundo.</span><span class="sxs-lookup"><span data-stu-id="5a912-939">This is more significant for 10ms timers than 1 second timers.</span></span> <span data-ttu-id="5a912-940">Evidentemente, el aumento de la frecuencia de interrupción del temporizador reduce este margen de error.</span><span class="sxs-lookup"><span data-stu-id="5a912-940">Of course, increasing the timer interrupt frequency decreases this margin of error.</span></span>

### <a name="timer-execution"></a><span data-ttu-id="5a912-941">Ejecución del temporizador</span><span class="sxs-lookup"><span data-stu-id="5a912-941">Timer Execution</span></span> 
<span data-ttu-id="5a912-942">Los temporizadores de aplicación se ejecutan en el orden en que se activan.</span><span class="sxs-lookup"><span data-stu-id="5a912-942">Application timers execute in the order they become active.</span></span> <span data-ttu-id="5a912-943">Por ejemplo, si se crean tres temporizadores con el mismo valor de expiración y se activan, se garantiza que sus funciones de expiración correspondientes se ejecuten en el orden en el que se han activado.</span><span class="sxs-lookup"><span data-stu-id="5a912-943">For example, if three timers are created with the same expiration value and activated, their corresponding expiration functions are guaranteed to execute in the order they were activated.</span></span> 

### <a name="creating-application-timers"></a><span data-ttu-id="5a912-944">Creación de temporizadores de aplicación</span><span class="sxs-lookup"><span data-stu-id="5a912-944">Creating Application Timers</span></span> 
<span data-ttu-id="5a912-945">Los temporizadores de aplicación se crean durante la inicialización o en tiempo de ejecución mediante subprocesos de aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-945">Application timers are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="5a912-946">No hay ningún límite en cuanto al número de temporizadores de aplicación en una aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-946">There is no limit on the number of application timers in an application.</span></span> 

### <a name="run-time-application-timer-performance-information"></a><span data-ttu-id="5a912-947">Información de rendimiento del temporizador de aplicación en tiempo de ejecución</span><span class="sxs-lookup"><span data-stu-id="5a912-947">Run-time Application Timer Performance Information</span></span>  
<span data-ttu-id="5a912-948">ThreadX SMP proporciona información opcional sobre el rendimiento de los temporizadores de aplicación en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="5a912-948">ThreadX SMP provides optional run-time application timer performance information.</span></span> <span data-ttu-id="5a912-949">Si la biblioteca y la aplicación de ThreadX SMP se compilan con ***TX_TIMER_ENABLE_PERFORMANCE_INFO*** definido, ThreadX SMP acumula la información siguiente.</span><span class="sxs-lookup"><span data-stu-id="5a912-949">If the ThreadX SMP library and application are built with ***TX_TIMER_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information.</span></span> 

<span data-ttu-id="5a912-950">Número total en el sistema general:</span><span class="sxs-lookup"><span data-stu-id="5a912-950">Total number for the overall system:</span></span>

- <span data-ttu-id="5a912-951">activaciones</span><span class="sxs-lookup"><span data-stu-id="5a912-951">activations</span></span>
- <span data-ttu-id="5a912-952">desactivaciones</span><span class="sxs-lookup"><span data-stu-id="5a912-952">deactivations</span></span>
- <span data-ttu-id="5a912-953">reactivaciones (temporizadores periódicos)</span><span class="sxs-lookup"><span data-stu-id="5a912-953">reactivations (periodic timers)</span></span>
- <span data-ttu-id="5a912-954">expirations</span><span class="sxs-lookup"><span data-stu-id="5a912-954">expirations</span></span>
- <span data-ttu-id="5a912-955">ajustes de expiración</span><span class="sxs-lookup"><span data-stu-id="5a912-955">expiration adjustments</span></span>

<span data-ttu-id="5a912-956">Número total en cada temporizador de aplicación:</span><span class="sxs-lookup"><span data-stu-id="5a912-956">Total number for each application timer:</span></span>

- <span data-ttu-id="5a912-957">activaciones</span><span class="sxs-lookup"><span data-stu-id="5a912-957">activations</span></span>
- <span data-ttu-id="5a912-958">desactivaciones</span><span class="sxs-lookup"><span data-stu-id="5a912-958">deactivations</span></span>
- <span data-ttu-id="5a912-959">reactivaciones (temporizadores periódicos)</span><span class="sxs-lookup"><span data-stu-id="5a912-959">reactivations (periodic timers)</span></span>
- <span data-ttu-id="5a912-960">expirations</span><span class="sxs-lookup"><span data-stu-id="5a912-960">expirations</span></span>
- <span data-ttu-id="5a912-961">ajustes de expiración</span><span class="sxs-lookup"><span data-stu-id="5a912-961">expiration adjustments</span></span>

<span data-ttu-id="5a912-962">Esta información está disponible en tiempo de ejecución por medio de los servicios *tx_timer_performance_info_get* y *tx_timer_performance_system_info_get*.</span><span class="sxs-lookup"><span data-stu-id="5a912-962">This information is available at run-time through the services *tx_timer_performance_info_get* and *tx_timer_performance_system_info_get*.</span></span> <span data-ttu-id="5a912-963">La información de rendimiento de los temporizadores de aplicación resulta útil para determinar si la aplicación se comporta de manera correcta.</span><span class="sxs-lookup"><span data-stu-id="5a912-963">Application Timer performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="5a912-964">También es útil para optimizar la aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-964">It is also useful in optimizing the application.</span></span>

### <a name="application-timer-control-block-tx_timer"></a><span data-ttu-id="5a912-965">Bloque de control de temporizador de aplicación TX_TIMER</span><span class="sxs-lookup"><span data-stu-id="5a912-965">Application Timer Control Block TX_TIMER</span></span> 
<span data-ttu-id="5a912-966">Las características de cada temporizador de aplicación se encuentran en su bloque de control.</span><span class="sxs-lookup"><span data-stu-id="5a912-966">The characteristics of each application timer are found in its control block.</span></span> <span data-ttu-id="5a912-967">Contiene información útil, como el valor de identificación de expiración de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="5a912-967">It contains useful information such as the 32-bit expiration identification value.</span></span> <span data-ttu-id="5a912-968">Esta estructura se define en el archivo ***tx_api.h***.</span><span class="sxs-lookup"><span data-stu-id="5a912-968">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="5a912-969">Los bloques de control de temporizador de aplicación se pueden colocar en cualquier parte de la memoria, pero es más común convertir el bloque de control en una estructura global definiéndolo fuera del ámbito de cualquier función.</span><span class="sxs-lookup"><span data-stu-id="5a912-969">Application timer control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span> 

### <a name="excessive-timers"></a><span data-ttu-id="5a912-970">Temporizadores excesivos</span><span class="sxs-lookup"><span data-stu-id="5a912-970">Excessive Timers</span></span> 
<span data-ttu-id="5a912-971">De manera predeterminada, los temporizadores de aplicación se ejecutan desde dentro de un subproceso del sistema oculto que se ejecuta con prioridad cero, que suele ser mayor que cualquier subproceso de aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-971">By default, application timers execute from within a hidden system thread that runs at priority zero, which is typically higher than any application thread.</span></span> <span data-ttu-id="5a912-972">Por este motivo, el procesamiento dentro de los temporizadores de aplicación debe ser mínimo.</span><span class="sxs-lookup"><span data-stu-id="5a912-972">Because of this, processing inside application timers should be kept to a minimum.</span></span> 

<span data-ttu-id="5a912-973">También es importante evitar, siempre que sea posible, temporizadores que expiren en cada tic del temporizador.</span><span class="sxs-lookup"><span data-stu-id="5a912-973">It is also important to avoid, whenever possible, timers that expire every timer tick.</span></span> <span data-ttu-id="5a912-974">Esa situación podría inducir una sobrecarga excesiva en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-974">Such a situation might induce excessive overhead in the application.</span></span>

> [!WARNING]
> <span data-ttu-id="5a912-975">Como se ha mencionado anteriormente, los temporizadores de aplicación se ejecutan desde un subproceso del sistema oculto.</span><span class="sxs-lookup"><span data-stu-id="5a912-975">As mentioned previously, application timers are executed from a hidden system thread.</span></span> <span data-ttu-id="5a912-976">Por lo tanto, es importante no seleccionar suspensión en ninguna llamada al servicio ThreadX SMP realizada desde dentro de la función de expiración del temporizador de aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-976">It is, therefore, important not to select suspension on any ThreadX SMP service calls made from within the application timer’s expiration function.</span></span>

## <a name="relative-time"></a><span data-ttu-id="5a912-977">Tiempo relativo</span><span class="sxs-lookup"><span data-stu-id="5a912-977">Relative Time</span></span>

<span data-ttu-id="5a912-978">Además de los temporizadores de aplicación mencionados antes, ThreadX SMP proporciona un único contador de tics de 32 bits que aumenta continuamente.</span><span class="sxs-lookup"><span data-stu-id="5a912-978">In addition to the application timers mentioned previously, ThreadX SMP provides a single continuously incrementing 32-bit tick counter.</span></span> <span data-ttu-id="5a912-979">El contador o *tiempo* se incrementa en uno en cada interrupción del temporizador.</span><span class="sxs-lookup"><span data-stu-id="5a912-979">The tick counter or *time* is increased by one on each timer interrupt.</span></span>

<span data-ttu-id="5a912-980">La aplicación puede leer o establecer este contador de 32 bits mediante llamadas a *tx_time_get* y *tx_time_set* respectivamente.</span><span class="sxs-lookup"><span data-stu-id="5a912-980">The application can read or set this 32-bit counter through calls to *tx_time_get* and *tx_time_set*, respectively.</span></span> <span data-ttu-id="5a912-981">La aplicación determina el uso de este contador.</span><span class="sxs-lookup"><span data-stu-id="5a912-981">The use of this tick counter is determined completely by the application.</span></span> <span data-ttu-id="5a912-982">ThreadX SMP no lo usa de forma interna.</span><span class="sxs-lookup"><span data-stu-id="5a912-982">It is not used internally by ThreadX SMP.</span></span>

### <a name="interrupts"></a><span data-ttu-id="5a912-983">Interrupciones</span><span class="sxs-lookup"><span data-stu-id="5a912-983">Interrupts</span></span> 
<span data-ttu-id="5a912-984">La respuesta rápida a los eventos asincrónicos es la función principal de las aplicaciones insertadas en tiempo real.</span><span class="sxs-lookup"><span data-stu-id="5a912-984">Fast response to asynchronous events is the principal function of real-time, embedded applications.</span></span> <span data-ttu-id="5a912-985">La aplicación sabe que hay un evento de ese tipo presente por medio de interrupciones de hardware.</span><span class="sxs-lookup"><span data-stu-id="5a912-985">The application knows such an event is present through hardware interrupts.</span></span> 

<span data-ttu-id="5a912-986">Una interrupción es un cambio asincrónico en la ejecución del procesador.</span><span class="sxs-lookup"><span data-stu-id="5a912-986">An interrupt is an asynchronous change in processor execution.</span></span> <span data-ttu-id="5a912-987">Normalmente, cuando se produce una interrupción, el procesador guarda una pequeña parte de la ejecución actual en la pila y transfiere el control al vector de interrupción adecuado.</span><span class="sxs-lookup"><span data-stu-id="5a912-987">Typically, when an interrupt occurs, the processor saves a small portion of the current execution on the stack and transfers control to the appropriate interrupt vector.</span></span> <span data-ttu-id="5a912-988">El vector de interrupción es básicamente la dirección de la rutina responsable de controlar la interrupción de tipo específica.</span><span class="sxs-lookup"><span data-stu-id="5a912-988">The interrupt vector is basically just the address of the routine responsible for handling the specific type interrupt.</span></span> <span data-ttu-id="5a912-989">El procedimiento exacto de control de la interrupción es específico del procesador.</span><span class="sxs-lookup"><span data-stu-id="5a912-989">The exact interrupt handling procedure is processor specific.</span></span> 

### <a name="interrupt-control"></a><span data-ttu-id="5a912-990">Control de interrupción</span><span class="sxs-lookup"><span data-stu-id="5a912-990">Interrupt Control</span></span> 
<span data-ttu-id="5a912-991">El servicio *tx_interrupt_control* permite a las aplicaciones habilitar y deshabilitar las interrupciones.</span><span class="sxs-lookup"><span data-stu-id="5a912-991">The *tx_interrupt_control* service allows applications to enable and disable interrupts.</span></span> <span data-ttu-id="5a912-992">Este servicio devuelve la posición de habilitación o deshabilitación de la interrupción anterior.</span><span class="sxs-lookup"><span data-stu-id="5a912-992">The previous interrupt enable/disable posture is returned by this service.</span></span> <span data-ttu-id="5a912-993">Es importante mencionar que el control de interrupción solo afecta al segmento del programa en ejecución.</span><span class="sxs-lookup"><span data-stu-id="5a912-993">It is important to mention that interrupt control only affects the currently executing program segment.</span></span> <span data-ttu-id="5a912-994">Por ejemplo, si un subproceso deshabilita las interrupciones, solo permanecen deshabilitadas durante la ejecución de ese subproceso.</span><span class="sxs-lookup"><span data-stu-id="5a912-994">For example, if a thread disables interrupts, they only remain disabled during execution of that thread.</span></span> 

> [!WARNING]
> <span data-ttu-id="5a912-995">Una interrupción no enmascarable (NMI) es una interrupción que el hardware no puede deshabilitar.</span><span class="sxs-lookup"><span data-stu-id="5a912-995">A Non-Maskable Interrupt (NMI) is an interrupt that cannot be disabled by the hardware.</span></span> <span data-ttu-id="5a912-996">Las aplicaciones de ThreadX SMP pueden usar este tipo de interrupción.</span><span class="sxs-lookup"><span data-stu-id="5a912-996">Such an interrupt may be used by ThreadX SMP applications.</span></span> <span data-ttu-id="5a912-997">Sin embargo, no se permite que la rutina de control de NMI de la aplicación use la administración de contexto de ThreadX SMP ni ningún servicio de API.</span><span class="sxs-lookup"><span data-stu-id="5a912-997">However, the application’s NMI handling routine is not allowed to use ThreadX SMP context management or any API services.</span></span> <span data-ttu-id="5a912-998">Interrupciones administradas de ThreadX SMP</span><span class="sxs-lookup"><span data-stu-id="5a912-998">ThreadX SMP Managed Interrupts</span></span>

<span data-ttu-id="5a912-999">ThreadX SMP proporciona a las aplicaciones administración completa de las interrupciones.</span><span class="sxs-lookup"><span data-stu-id="5a912-999">ThreadX SMP provides applications with complete interrupt management.</span></span> <span data-ttu-id="5a912-1000">Esta administración incluye el guardado y la restauración del contexto de la ejecución interrumpida.</span><span class="sxs-lookup"><span data-stu-id="5a912-1000">This management includes saving and restoring the context of the interrupted execution.</span></span> <span data-ttu-id="5a912-1001">Además, ThreadX SMP permite que se llame a determinados servicios desde rutinas de servicio de interrupción (ISR).</span><span class="sxs-lookup"><span data-stu-id="5a912-1001">In addition, ThreadX SMP allows certain services to be called from within Interrupt Service Routines (ISRs).</span></span> <span data-ttu-id="5a912-1002">A continuación se muestra una lista de los servicios de ThreadX SMP permitidos desde ISR de aplicación:</span><span class="sxs-lookup"><span data-stu-id="5a912-1002">The following is a list of ThreadX SMPservices allowed from application ISRs:</span></span>

- <span data-ttu-id="5a912-1003">tx_block_allocate</span><span class="sxs-lookup"><span data-stu-id="5a912-1003">tx_block_allocate</span></span> 
- <span data-ttu-id="5a912-1004">tx_block_pool_info_get</span><span class="sxs-lookup"><span data-stu-id="5a912-1004">tx_block_pool_info_get</span></span> 
- <span data-ttu-id="5a912-1005">tx_block_pool_prioritize</span><span class="sxs-lookup"><span data-stu-id="5a912-1005">tx_block_pool_prioritize</span></span> 
- <span data-ttu-id="5a912-1006">tx_block_pool_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="5a912-1006">tx_block_pool_performance_info_get</span></span> 
- <span data-ttu-id="5a912-1007">tx_block_pool_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="5a912-1007">tx_block_pool_performance_system_info_get</span></span> 
- <span data-ttu-id="5a912-1008">tx_block_release</span><span class="sxs-lookup"><span data-stu-id="5a912-1008">tx_block_release</span></span> 
- <span data-ttu-id="5a912-1009">tx_byte_pool_info_get</span><span class="sxs-lookup"><span data-stu-id="5a912-1009">tx_byte_pool_info_get</span></span> 
- <span data-ttu-id="5a912-1010">tx_byte_pool_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="5a912-1010">tx_byte_pool_performance_info_get</span></span> 
- <span data-ttu-id="5a912-1011">tx_byte_pool_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="5a912-1011">tx_byte_pool_performance_system_info_get</span></span> 
- <span data-ttu-id="5a912-1012">tx_byte_pool_prioritize</span><span class="sxs-lookup"><span data-stu-id="5a912-1012">tx_byte_pool_prioritize</span></span> 
- <span data-ttu-id="5a912-1013">tx_event_flags_info_get</span><span class="sxs-lookup"><span data-stu-id="5a912-1013">tx_event_flags_info_get</span></span> 
- <span data-ttu-id="5a912-1014">tx_event_flags_get</span><span class="sxs-lookup"><span data-stu-id="5a912-1014">tx_event_flags_get</span></span> 
- <span data-ttu-id="5a912-1015">tx_event_flags_set</span><span class="sxs-lookup"><span data-stu-id="5a912-1015">tx_event_flags_set</span></span> 
- <span data-ttu-id="5a912-1016">tx_event_flags_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="5a912-1016">tx_event_flags_performance_info_get</span></span> 
- <span data-ttu-id="5a912-1017">tx_event_flags_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="5a912-1017">tx_event_flags_performance_system_info_get</span></span> 
- <span data-ttu-id="5a912-1018">tx_event_flags_set_notify</span><span class="sxs-lookup"><span data-stu-id="5a912-1018">tx_event_flags_set_notify</span></span> 
- <span data-ttu-id="5a912-1019">tx_interrupt_control</span><span class="sxs-lookup"><span data-stu-id="5a912-1019">tx_interrupt_control</span></span> 
- <span data-ttu-id="5a912-1020">tx_mutex_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="5a912-1020">tx_mutex_performance_info_get</span></span> 
- <span data-ttu-id="5a912-1021">tx_mutex_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="5a912-1021">tx_mutex_performance_system_info_get</span></span> 
- <span data-ttu-id="5a912-1022">tx_queue_front_send</span><span class="sxs-lookup"><span data-stu-id="5a912-1022">tx_queue_front_send</span></span> 
- <span data-ttu-id="5a912-1023">tx_queue_info_get</span><span class="sxs-lookup"><span data-stu-id="5a912-1023">tx_queue_info_get</span></span> 
- <span data-ttu-id="5a912-1024">tx_queue_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="5a912-1024">tx_queue_performance_info_get</span></span> 
- <span data-ttu-id="5a912-1025">tx_queue_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="5a912-1025">tx_queue_performance_system_info_get</span></span> 
- <span data-ttu-id="5a912-1026">tx_queue_prioritize</span><span class="sxs-lookup"><span data-stu-id="5a912-1026">tx_queue_prioritize</span></span> 
- <span data-ttu-id="5a912-1027">tx_queue_receive</span><span class="sxs-lookup"><span data-stu-id="5a912-1027">tx_queue_receive</span></span> 
- <span data-ttu-id="5a912-1028">tx_queue_send</span><span class="sxs-lookup"><span data-stu-id="5a912-1028">tx_queue_send</span></span> 
- <span data-ttu-id="5a912-1029">tx_semaphore_get</span><span class="sxs-lookup"><span data-stu-id="5a912-1029">tx_semaphore_get</span></span> 
- <span data-ttu-id="5a912-1030">tx_queue_send_notify</span><span class="sxs-lookup"><span data-stu-id="5a912-1030">tx_queue_send_notify</span></span> 
- <span data-ttu-id="5a912-1031">tx_semaphore_ceiling_put</span><span class="sxs-lookup"><span data-stu-id="5a912-1031">tx_semaphore_ceiling_put</span></span> 
- <span data-ttu-id="5a912-1032">tx_semaphore_info_get</span><span class="sxs-lookup"><span data-stu-id="5a912-1032">tx_semaphore_info_get</span></span> 
- <span data-ttu-id="5a912-1033">tx_semaphore_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="5a912-1033">tx_semaphore_performance_info_get</span></span> 
- <span data-ttu-id="5a912-1034">tx_semaphore_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="5a912-1034">tx_semaphore_performance_system_info_get</span></span> 
- <span data-ttu-id="5a912-1035">tx_semaphore_prioritize</span><span class="sxs-lookup"><span data-stu-id="5a912-1035">tx_semaphore_prioritize</span></span> 
- <span data-ttu-id="5a912-1036">tx_semaphore_put</span><span class="sxs-lookup"><span data-stu-id="5a912-1036">tx_semaphore_put</span></span> 
- <span data-ttu-id="5a912-1037">tx_thread_identify</span><span class="sxs-lookup"><span data-stu-id="5a912-1037">tx_thread_identify</span></span> 
- <span data-ttu-id="5a912-1038">tx_semaphore_put_notify</span><span class="sxs-lookup"><span data-stu-id="5a912-1038">tx_semaphore_put_notify</span></span> 
- <span data-ttu-id="5a912-1039">tx_thread_entry_exit_notify</span><span class="sxs-lookup"><span data-stu-id="5a912-1039">tx_thread_entry_exit_notify</span></span> 
- <span data-ttu-id="5a912-1040">tx_thread_info_get</span><span class="sxs-lookup"><span data-stu-id="5a912-1040">tx_thread_info_get</span></span> 
- <span data-ttu-id="5a912-1041">tx_thread_resume</span><span class="sxs-lookup"><span data-stu-id="5a912-1041">tx_thread_resume</span></span> 
- <span data-ttu-id="5a912-1042">tx_thread_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="5a912-1042">tx_thread_performance_info_get</span></span> 
- <span data-ttu-id="5a912-1043">tx_thread_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="5a912-1043">tx_thread_performance_system_info_get</span></span> 
- <span data-ttu-id="5a912-1044">tx_thread_stack_error_notify</span><span class="sxs-lookup"><span data-stu-id="5a912-1044">tx_thread_stack_error_notify</span></span> 
- <span data-ttu-id="5a912-1045">tx_thread_wait_abort</span><span class="sxs-lookup"><span data-stu-id="5a912-1045">tx_thread_wait_abort</span></span> 
- <span data-ttu-id="5a912-1046">tx_time_get</span><span class="sxs-lookup"><span data-stu-id="5a912-1046">tx_time_get</span></span> 
- <span data-ttu-id="5a912-1047">tx_time_set</span><span class="sxs-lookup"><span data-stu-id="5a912-1047">tx_time_set</span></span> 
- <span data-ttu-id="5a912-1048">tx_timer_activate</span><span class="sxs-lookup"><span data-stu-id="5a912-1048">tx_timer_activate</span></span> 
- <span data-ttu-id="5a912-1049">tx_timer_change</span><span class="sxs-lookup"><span data-stu-id="5a912-1049">tx_timer_change</span></span> 
- <span data-ttu-id="5a912-1050">tx_timer_deactivate</span><span class="sxs-lookup"><span data-stu-id="5a912-1050">tx_timer_deactivate</span></span> 
- <span data-ttu-id="5a912-1051">tx_timer_info_get</span><span class="sxs-lookup"><span data-stu-id="5a912-1051">tx_timer_info_get</span></span> 
- <span data-ttu-id="5a912-1052">tx_timer_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="5a912-1052">tx_timer_performance_info_get</span></span> 
- <span data-ttu-id="5a912-1053">tx_timer_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="5a912-1053">tx_timer_performance_system_info_get</span></span>

> [!WARNING]
> <span data-ttu-id="5a912-1054">No se permite la suspensión desde ISR.</span><span class="sxs-lookup"><span data-stu-id="5a912-1054">Suspension is not allowed from ISRs.</span></span> <span data-ttu-id="5a912-1055">Por tanto, el parámetro **wait_option** de todas las llamadas al servicio ThreadX SMP realizadas desde una ISR se debe establecer en **TX_NO_WAIT**.</span><span class="sxs-lookup"><span data-stu-id="5a912-1055">Therefore, the **wait_option** parameter for all ThreadX SMP service calls made from an ISR must be set to **TX_NO_WAIT**.</span></span>

### <a name="isr-template"></a><span data-ttu-id="5a912-1056">Plantilla de ISR</span><span class="sxs-lookup"><span data-stu-id="5a912-1056">ISR Template</span></span> 
<span data-ttu-id="5a912-1057">Para administrar las interrupciones de aplicación, se debe llamar a varias utilidades de ThreadX SMP al principio y al final de las ISR de aplicación.</span><span class="sxs-lookup"><span data-stu-id="5a912-1057">To manage application interrupts, several ThreadX SMP utilities must be called in the beginning and end of application ISRs.</span></span> <span data-ttu-id="5a912-1058">El formato exacto para el control de interrupciones varía entre puertos.</span><span class="sxs-lookup"><span data-stu-id="5a912-1058">The exact format for interrupt handling varies between ports.</span></span> <span data-ttu-id="5a912-1059">Revise el archivo ***readme_threadx.txt*** en el disco de distribución para obtener instrucciones específicas sobre la administración de ISR.</span><span class="sxs-lookup"><span data-stu-id="5a912-1059">Review the ***readme_threadx.txt*** file on the distribution disk for specific instructions on managing ISRs.</span></span>

<span data-ttu-id="5a912-1060">El pequeño segmento de código siguiente es típico de la mayoría de las ISR administradas de ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="5a912-1060">The following small code segment is typical of most ThreadX SMP managed ISRs.</span></span> <span data-ttu-id="5a912-1061">En la mayoría de los casos, este procesamiento está en lenguaje de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="5a912-1061">In most cases, this processing is in assembly language.</span></span>

<span data-ttu-id="5a912-1062">**_application_ISR_vector_entry**:</span><span class="sxs-lookup"><span data-stu-id="5a912-1062">**_application_ISR_vector_entry**:</span></span>  
<span data-ttu-id="5a912-1063">; Save context and prepare for</span><span class="sxs-lookup"><span data-stu-id="5a912-1063">; Save context and prepare for</span></span>  
<span data-ttu-id="5a912-1064">; ThreadX SMP use by calling the ISR</span><span class="sxs-lookup"><span data-stu-id="5a912-1064">; ThreadX SMP use by calling the ISR</span></span>  
<span data-ttu-id="5a912-1065">; entry function.</span><span class="sxs-lookup"><span data-stu-id="5a912-1065">; entry function.</span></span>  
<span data-ttu-id="5a912-1066">CALL **_tx_thread_context_save**</span><span class="sxs-lookup"><span data-stu-id="5a912-1066">CALL **_tx_thread_context_save**</span></span>  

<span data-ttu-id="5a912-1067">; The ISR can now call ThreadX SMP</span><span class="sxs-lookup"><span data-stu-id="5a912-1067">; The ISR can now call ThreadX SMP</span></span>  
<span data-ttu-id="5a912-1068">; services and its own C functions</span><span class="sxs-lookup"><span data-stu-id="5a912-1068">; services and its own C functions</span></span>  

<span data-ttu-id="5a912-1069">; When the ISR is finished, context</span><span class="sxs-lookup"><span data-stu-id="5a912-1069">; When the ISR is finished, context</span></span>  
<span data-ttu-id="5a912-1070">; is restored (or thread preemption)</span><span class="sxs-lookup"><span data-stu-id="5a912-1070">; is restored (or thread preemption)</span></span>  
<span data-ttu-id="5a912-1071">; by calling the context restore</span><span class="sxs-lookup"><span data-stu-id="5a912-1071">; by calling the context restore</span></span>  
<span data-ttu-id="5a912-1072">; function.</span><span class="sxs-lookup"><span data-stu-id="5a912-1072">; function.</span></span> <span data-ttu-id="5a912-1073">Control does not return!</span><span class="sxs-lookup"><span data-stu-id="5a912-1073">Control does not return!</span></span>  
<span data-ttu-id="5a912-1074">JUMP **_tx_thread_context_restore**</span><span class="sxs-lookup"><span data-stu-id="5a912-1074">JUMP **_tx_thread_context_restore**</span></span>

### <a name="high-frequency-interrupts"></a><span data-ttu-id="5a912-1075">Interrupciones de alta frecuencia</span><span class="sxs-lookup"><span data-stu-id="5a912-1075">High-frequency Interrupts</span></span>  
<span data-ttu-id="5a912-1076">Algunas interrupciones se producen con una frecuencia tan alta que al guardar y restaurar el contexto completo en cada interrupción se consumiría un ancho de banda de procesamiento excesivo.</span><span class="sxs-lookup"><span data-stu-id="5a912-1076">Some interrupts occur at such a high frequency that saving and restoring full context upon each interrupt would consume excessive processing bandwidth.</span></span> <span data-ttu-id="5a912-1077">En esos casos, es habitual que la aplicación tenga una ISR de lenguaje de ensamblado pequeña que realiza una cantidad limitada de procesamiento para una mayoría de estas interrupciones de alta frecuencia.</span><span class="sxs-lookup"><span data-stu-id="5a912-1077">In such cases, it is common for the application to have a small assembly language ISR that does a limited amount of processing for a majority of these highfrequency interrupts.</span></span> 

<span data-ttu-id="5a912-1078">Después de un momento determinado, es posible que la ISR pequeña tenga que interactuar con ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="5a912-1078">After a certain point in time, the small ISR may need to interact with ThreadX SMP.</span></span> <span data-ttu-id="5a912-1079">Esto se logra mediante una llamada a las funciones de entrada y salida descritas en la plantilla anterior.</span><span class="sxs-lookup"><span data-stu-id="5a912-1079">This is accomplished by calling the entry and exit functions described in the above template.</span></span> 

### <a name="interrupt-latency"></a><span data-ttu-id="5a912-1080">Latencia de interrupción</span><span class="sxs-lookup"><span data-stu-id="5a912-1080">Interrupt Latency</span></span>  
<span data-ttu-id="5a912-1081">ThreadX SMP bloquea las interrupciones durante breves periodos de tiempo.</span><span class="sxs-lookup"><span data-stu-id="5a912-1081">ThreadX SMP locks out interrupts over brief periods of time.</span></span> <span data-ttu-id="5a912-1082">La cantidad máxima de tiempo que las interrupciones se deshabilitan es del orden del tiempo necesario para guardar o restaurar el contexto de un subproceso.</span><span class="sxs-lookup"><span data-stu-id="5a912-1082">The maximum amount of time interrupts are disabled is on the order of the time required to save or restore a thread’s context.</span></span> 