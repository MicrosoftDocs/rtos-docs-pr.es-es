---
title: 'Capítulo 3: Descripción funcional del servicio DTLS de Azure RTOS NetX Secure'
description: Este capítulo contiene una descripción funcional del servicio DTLS de Azure RTOS NetX Secure.
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 347bd83fa8c72ced2e8678a92ec5c5f8393c136d
ms.sourcegitcommit: 60ad844b58639d88830f2660ab0c4ff86b92c10f
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 04/07/2021
ms.locfileid: "106550208"
---
# <a name="chapter-3-functional-description-of-azure-rtos-netx-secure-dtls"></a><span data-ttu-id="5589a-103">Capítulo 3: Descripción funcional del servicio DTLS de Azure RTOS NetX Secure</span><span class="sxs-lookup"><span data-stu-id="5589a-103">Chapter 3: Functional description of Azure RTOS NetX Secure DTLS</span></span>

## <a name="execution-overview"></a><span data-ttu-id="5589a-104">Información general sobre la ejecución</span><span class="sxs-lookup"><span data-stu-id="5589a-104">Execution Overview</span></span>

<span data-ttu-id="5589a-105">Este capítulo contiene una descripción funcional del servicio DTLS de Azure RTOS NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="5589a-105">This chapter contains a functional description of Azure RTOS NetX Secure DTLS.</span></span> <span data-ttu-id="5589a-106">Hay dos tipos principales de ejecución de programa en una aplicación DTLS de NetX Secure: inicialización y llamadas a la interfaz de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="5589a-106">There are two primary types of program execution in a NetX Secure DTLS application: initialization and application interface calls.</span></span> 

<span data-ttu-id="5589a-107">NetX Secure presupone la existencia de ThreadX y NetX/NetXDuo.</span><span class="sxs-lookup"><span data-stu-id="5589a-107">NetX Secure assumes the existence of ThreadX and NetX/NetXDuo.</span></span> <span data-ttu-id="5589a-108">En ThreadX, se requiere la ejecución de subprocesos, la suspensión, temporizadores periódicos e instalaciones de exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="5589a-108">From ThreadX, it requires thread execution, suspension, periodic timers, and mutual exclusion facilities.</span></span> <span data-ttu-id="5589a-109">En NetX/NetXDuo, se necesitan los controladores y los dispositivos de red de IP y UDP.</span><span class="sxs-lookup"><span data-stu-id="5589a-109">From NetX/NetXDuo it requires the UDP and IP networking facilities and drivers.</span></span>

## <a name="datagram-transport-layer-security-dtls-and-transport-layer-security-tls"></a><span data-ttu-id="5589a-110">Seguridad de la capa de transporte de datagramas (DTLS) y Seguridad de la capa de transporte (TLS)</span><span class="sxs-lookup"><span data-stu-id="5589a-110">Datagram Transport Layer Security (DTLS) and Transport Layer Security (TLS)</span></span>

<span data-ttu-id="5589a-111">El servicio DTLS de NetX Secure implementa la versión 1.2 del protocolo DTLS (Seguridad de la capa de transporte de datagramas) definido en la RFC 6347.</span><span class="sxs-lookup"><span data-stu-id="5589a-111">NetX Secure DTLS implements the Datagram Transport Layer Security protocol version 1.2 defined in RFC 6347.</span></span> <span data-ttu-id="5589a-112">La versión 1.0 de DTLS se definió en la RFC 4347 y correspondía a la versión de 1.1 de TLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-112">DTLS version 1.0 was defined in RFC 4347 and corresponded to TLS version 1.1.</span></span> <span data-ttu-id="5589a-113">Dado que DTLS es esencialmente una extensión de TLS, se decidió que la versión siguiente usaría el mismo número de versión que la versión de TLS correspondiente.</span><span class="sxs-lookup"><span data-stu-id="5589a-113">Due to DTLS being essentially an extension to TLS, it was decided that the next version would use the same version number as the corresponding TLS version.</span></span> <span data-ttu-id="5589a-114">Por lo tanto, no hay ninguna versión de 1.1 de DTLS porque la versión 1.2 de DTLS corresponde a la versión de 1.2 de TLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-114">Thus, there is no DTLS version 1.1 as DTLS version 1.2 corresponds to TLS version 1.2.</span></span>

> [!NOTE]
> <span data-ttu-id="5589a-115">NetX Secure admite la versión 1.2 de DTLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-115">NetX Secure supports DTLS version 1.2.</span></span> <span data-ttu-id="5589a-116">DTLS 1.0 (RFC 4347) **no** se admite actualmente.</span><span class="sxs-lookup"><span data-stu-id="5589a-116">DTLS 1.0 (RFC 4347) is **not** currently supported.</span></span>

<span data-ttu-id="5589a-117">*Capa de sockets seguros* (SSL) era el nombre original de TLS antes de que se convirtiera en un estándar en la RFC 2246 y “SSL” se utiliza a menudo como nombre genérico para los protocolos TLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-117">*Secure Sockets Layer* (SSL) was the original name of TLS before it became a standard in RFC 2246 and “SSL” is often used as a generic name for the TLS protocols.</span></span> <span data-ttu-id="5589a-118">La última versión de SSL era 3.0 y TLS 1.0 a veces se denomina SSL 3.1.</span><span class="sxs-lookup"><span data-stu-id="5589a-118">The last version of SSL was 3.0, and TLS 1.0 is sometimes referred to as SSL version 3.1.</span></span> <span data-ttu-id="5589a-119">Todas las versiones del protocolo “SSL” oficial se consideran obsoletas y no seguras; actualmente NetX Secure no ofrece una implementación de SSL.</span><span class="sxs-lookup"><span data-stu-id="5589a-119">All versions of the official “SSL” protocol are considered obsolete and insecure and currently NetX Secure does not provide an SSL implementation.</span></span>

<span data-ttu-id="5589a-120">TLS especifica un protocolo para generar *claves de sesión* que se crean durante *el protocolo de enlace* de TLS entre un cliente y un servidor de TLS, y dichas claves se utilizan para cifrar los datos enviados por la aplicación durante la *sesión* de TLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-120">TLS specifies a protocol to generate *session keys* which are created during the TLS *handshake* between a TLS client and server and those keys are used to encrypt data sent by the application during the TLS *session.*</span></span>

<span data-ttu-id="5589a-121">DTLS está estrechamente relacionado con TLS, ya que ambos protocolos comparten mecanismos de seguridad subyacentes.</span><span class="sxs-lookup"><span data-stu-id="5589a-121">DTLS is closely coupled with TLS, as the underlying security mechansims are shared between the protocols.</span></span> <span data-ttu-id="5589a-122">Sin embargo, TLS está diseñado para funcionar a través de un protocolo de capa de transporte que proporciona garantías sobre la entrega y el orden de paquetes (casi siempre TCP en la práctica) y no funcionará a través de un protocolo no confiable como UDP.</span><span class="sxs-lookup"><span data-stu-id="5589a-122">However, TLS is designed to work over a transport layer protocol that provides guarantees about packet delivery and order (almost always TCP in practice) and will not function over an unreliable protocol like UDP.</span></span> <span data-ttu-id="5589a-123">DTLS se incorporó precisamente debido a UDP: DTLS se diseñó para tratar la naturaleza no confiable de UDP y de protocolos similares.</span><span class="sxs-lookup"><span data-stu-id="5589a-123">It is precisely because of UDP that DTLS was introduced: DTLS was designed handle the unreliable nature of UDP and similar protocols.</span></span> <span data-ttu-id="5589a-124">Para ello, incluye la lógica de ordenación y confiabilidad (por ejemplo, la retransmisión de datos anulados) de manera similar a protocolos confiables como TCP.</span><span class="sxs-lookup"><span data-stu-id="5589a-124">It does this by including ordering and reliability logic (e.g. retransmission of dropped data) similar to reliable protocols like TCP.</span></span>

<span data-ttu-id="5589a-125">En el capítulo 3 de la guía de usuario del servicio TLS de NetX Secure se incluye un análisis completo de TLS, por lo que este documento se centrará en las diferencias entre TLS y DTLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-125">A complete discussion of TLS is included in Chapter 3 of the NetX Secure TLS User’s Guide, so this document will focus on the differences between TLS and DTLS.</span></span>

### <a name="dtls-record-header"></a><span data-ttu-id="5589a-126">Encabezado de registro DTLS</span><span class="sxs-lookup"><span data-stu-id="5589a-126">DTLS Record header</span></span>

<span data-ttu-id="5589a-127">Cualquier registro DTLS válido debe tener un encabezado DTLS, como se muestra en la figura 1.</span><span class="sxs-lookup"><span data-stu-id="5589a-127">Any valid DTLS record must have a DTLS header, as shown in Figure 1.</span></span> <span data-ttu-id="5589a-128">El encabezado es igual que el TLS pero incluye dos nuevos campos: la *época* de 16 bits y el *número de secuencia* de 48 bits (se describen a continuación).</span><span class="sxs-lookup"><span data-stu-id="5589a-128">The header is the same as TLS with the addition of two new fields: the 16-bit *epoch* and the 48-bit *sequence number*, described below.</span></span>

![Diagrama de un encabezado de registro DTLS.](media/image2.png)

<span data-ttu-id="5589a-130">**Figura 1: Encabezado de registro DTLS**</span><span class="sxs-lookup"><span data-stu-id="5589a-130">**Figure 1 - DTLS record header**</span></span>

<span data-ttu-id="5589a-131">Los campos del encabezado de registro TLS se definen de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="5589a-131">The fields of the TLS record header are defined as follows:</span></span>

| <span data-ttu-id="5589a-132">Campo de encabezado TLS</span><span class="sxs-lookup"><span data-stu-id="5589a-132">TLS Header Field</span></span> | <span data-ttu-id="5589a-133">Fin</span><span class="sxs-lookup"><span data-stu-id="5589a-133">Purpose</span></span>  |
| ---------------- | --------- |
| <span data-ttu-id="5589a-134">**Tipo de mensaje de 8 bits**</span><span class="sxs-lookup"><span data-stu-id="5589a-134">**8-bit Message Type**</span></span> | <span data-ttu-id="5589a-135">Este campo contiene el tipo de registro DTLS que se está enviando.</span><span class="sxs-lookup"><span data-stu-id="5589a-135">This field contains the type of DTLS record being sent.</span></span> <span data-ttu-id="5589a-136">Los tipos válidos son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="5589a-136">Valid types are as follows:</span></span><br /><span data-ttu-id="5589a-137">- ChangeCipherSpec: 0x14</span><span class="sxs-lookup"><span data-stu-id="5589a-137">- ChangeCipherSpec: 0x14</span></span><br /><span data-ttu-id="5589a-138">- Alert: 0x15</span><span class="sxs-lookup"><span data-stu-id="5589a-138">- Alert: 0x15</span></span><br /><span data-ttu-id="5589a-139">- Handshake: 0x16</span><span class="sxs-lookup"><span data-stu-id="5589a-139">- Handshake: 0x16</span></span><br /><span data-ttu-id="5589a-140">- ApplicationData: 0x17</span><span class="sxs-lookup"><span data-stu-id="5589a-140">- Application Data: 0x17</span></span><br /> |
| <span data-ttu-id="5589a-141">**Versión del protocolo de 16 bits**</span><span class="sxs-lookup"><span data-stu-id="5589a-141">**16-bit Protocol Version**</span></span> | <span data-ttu-id="5589a-142">Este campo contiene la versión del protocolo DTLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-142">This field contains the DTLS protocol version.</span></span> <span data-ttu-id="5589a-143">Los valores válidos son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="5589a-143">Valid values are as follows:</span></span><br /><span data-ttu-id="5589a-144">- DTLS 1.1: 0xFEFD</span><span class="sxs-lookup"><span data-stu-id="5589a-144">- DTLS 1.1: 0xFEFD</span></span> |
|  <span data-ttu-id="5589a-145">**Época de 16 bits**</span><span class="sxs-lookup"><span data-stu-id="5589a-145">**16-bit Epoch**</span></span> |  <span data-ttu-id="5589a-146">Este campo contiene la “época” de DTLS, que es un contador que se incrementa cada vez que se cambia el estado de cifrado (por ejemplo, al generar nuevas claves de sesión).</span><span class="sxs-lookup"><span data-stu-id="5589a-146">This field contains the DTLS “epoch” which is a counter that is incremented each time the encryption state is changed (e.g. when generating new session keys).</span></span>  |
|  <span data-ttu-id="5589a-147">**Número de secuencia de 48 bits**</span><span class="sxs-lookup"><span data-stu-id="5589a-147">**48-bit Sequence Number**</span></span> |  <span data-ttu-id="5589a-148">Este campo contiene un número de secuencia que identifica este registro en particular.</span><span class="sxs-lookup"><span data-stu-id="5589a-148">This field contains a sequence number which identifies this particular record.</span></span> <span data-ttu-id="5589a-149">Lo usa DTLS para mantener el orden de los registros y comprobar la necesidad de retransmisión.</span><span class="sxs-lookup"><span data-stu-id="5589a-149">It is used by DTLS to maintain record ordering and check for retransmission need.</span></span> |
|  <span data-ttu-id="5589a-150">**Longitud de 16 bits**</span><span class="sxs-lookup"><span data-stu-id="5589a-150">**16-bit Length**</span></span> |  <span data-ttu-id="5589a-151">Este campo contiene la longitud de los datos encapsulados en el registro DTLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-151">This field contains the length of the data encapsulated in the DTLS record.</span></span>  |

### <a name="dtls-handshake-record-header"></a><span data-ttu-id="5589a-152">Encabezado de registro de protocolo de enlace DTLS</span><span class="sxs-lookup"><span data-stu-id="5589a-152">DTLS Handshake Record header</span></span>

<span data-ttu-id="5589a-153">Cualquier registro de protocolo de enlace DTLS válido debe tener un encabezado de protocolo de enlace DTLS, como se muestra en la figura 2.</span><span class="sxs-lookup"><span data-stu-id="5589a-153">Any valid DTLS handshake record must have a DTLS Handshake header, as shown in Figure 2.</span></span>

![Diagrama de un encabezado de registro de protocolo de enlace DTLS.](media/image3.png)

<span data-ttu-id="5589a-155">**Figura 2: Encabezado de registro de protocolo de enlace DTLS**</span><span class="sxs-lookup"><span data-stu-id="5589a-155">**Figure 2 - DTLS Handshake record header**</span></span>

<span data-ttu-id="5589a-156">Los campos del encabezado de registro de protocolo de enlace DTLS se definen de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="5589a-156">The fields of the DTLS Handshake record header are defined as follows:</span></span>

| <span data-ttu-id="5589a-157">Campo de encabezado TLS</span><span class="sxs-lookup"><span data-stu-id="5589a-157">TLS Header Field</span></span> | <span data-ttu-id="5589a-158">Fin</span><span class="sxs-lookup"><span data-stu-id="5589a-158">Purpose</span></span>  |
| ---------------- | ------------------------------------------------ |
| <span data-ttu-id="5589a-159">**Tipo de mensaje de 8 bits**</span><span class="sxs-lookup"><span data-stu-id="5589a-159">**8-bit Message Type**</span></span> | <span data-ttu-id="5589a-160">Este campo contiene el tipo de registro DTLS que se está enviando.</span><span class="sxs-lookup"><span data-stu-id="5589a-160">This field contains the type of DTLS record being sent.</span></span> <span data-ttu-id="5589a-161">Los tipos válidos son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="5589a-161">Valid types are as follows:</span></span><br /><span data-ttu-id="5589a-162">- ChangeCipherSpec: 0x14</span><span class="sxs-lookup"><span data-stu-id="5589a-162">- ChangeCipherSpec: 0x14</span></span><br /><span data-ttu-id="5589a-163">- Alert: 0x15</span><span class="sxs-lookup"><span data-stu-id="5589a-163">- Alert: 0x15</span></span><br /><span data-ttu-id="5589a-164">- Handshake: 0x16</span><span class="sxs-lookup"><span data-stu-id="5589a-164">- Handshake: 0x16</span></span><br /><span data-ttu-id="5589a-165">- ApplicationData: 0x17</span><span class="sxs-lookup"><span data-stu-id="5589a-165">- Application Data: 0x17</span></span> |
|  <span data-ttu-id="5589a-166">**Época de 16 bits**</span><span class="sxs-lookup"><span data-stu-id="5589a-166">**16-bit Epoch**</span></span> | <span data-ttu-id="5589a-167">Este campo contiene la “época” de DTLS, que es un contador que se incrementa cada vez que se cambia el estado de cifrado (por ejemplo, al generar nuevas claves de sesión).</span><span class="sxs-lookup"><span data-stu-id="5589a-167">This field contains the DTLS “epoch” which is a counter that is incremented each time the encryption state is changed (e.g. when generating new session keys).</span></span> |
|  <span data-ttu-id="5589a-168">**Número de secuencia de 48 bits**</span><span class="sxs-lookup"><span data-stu-id="5589a-168">**48-bit Sequence Number**</span></span> | <span data-ttu-id="5589a-169">Este campo contiene un número de secuencia que identifica este registro en particular.</span><span class="sxs-lookup"><span data-stu-id="5589a-169">This field contains a sequence number which identifies this particular record.</span></span> <span data-ttu-id="5589a-170">Lo usa DTLS para mantener el orden de los registros y comprobar la necesidad de retransmisión.</span><span class="sxs-lookup"><span data-stu-id="5589a-170">It is used by DTLS to maintain record ordering and check for retransmission need.</span></span> |
|  <span data-ttu-id="5589a-171">**Versión del protocolo de 16 bits**</span><span class="sxs-lookup"><span data-stu-id="5589a-171">**16-bit Protocol Version**</span></span> | <span data-ttu-id="5589a-172">Este campo contiene la versión del protocolo DTLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-172">This field contains the DTLS protocol version.</span></span> <span data-ttu-id="5589a-173">Los valores válidos son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="5589a-173">Valid values are as follows:</span></span><br /><span data-ttu-id="5589a-174">- DTLS 1.1: 0xFEFD</span><span class="sxs-lookup"><span data-stu-id="5589a-174">- DTLS 1.1: 0xFEFD</span></span> |
| <span data-ttu-id="5589a-175">**Longitud de 16 bits**</span><span class="sxs-lookup"><span data-stu-id="5589a-175">**16-bit Length**</span></span> | <span data-ttu-id="5589a-176">Este campo contiene la longitud de los datos encapsulados en el registro DTLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-176">This field contains the length of the data encapsulated in the DTLS record.</span></span> |
| <span data-ttu-id="5589a-177">**Tipo de protocolo de enlace de 8 bits**</span><span class="sxs-lookup"><span data-stu-id="5589a-177">**8-bit Handshake Type**</span></span> | <span data-ttu-id="5589a-178">Este campo contiene el tipo de mensaje del protocolo de enlace.</span><span class="sxs-lookup"><span data-stu-id="5589a-178">This field contains the handshake message type.</span></span> <span data-ttu-id="5589a-179">Los valores válidos son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="5589a-179">Valid values are as follows:</span></span><br /><span data-ttu-id="5589a-180">- HelloRequest: 0x00</span><span class="sxs-lookup"><span data-stu-id="5589a-180">- HelloRequest: 0x00</span></span><br /><span data-ttu-id="5589a-181">- ClientHello: 0x01</span><span class="sxs-lookup"><span data-stu-id="5589a-181">- ClientHello: 0x01</span></span><br /><span data-ttu-id="5589a-182">- ServerHello: 0x02</span><span class="sxs-lookup"><span data-stu-id="5589a-182">- ServerHello: 0x02</span></span><br /><span data-ttu-id="5589a-183">- Certificate: 0x0B</span><span class="sxs-lookup"><span data-stu-id="5589a-183">- Certificate: 0x0B</span></span><br /><span data-ttu-id="5589a-184">- ServerKeyExchange: 0x0C</span><span class="sxs-lookup"><span data-stu-id="5589a-184">- ServerKeyExchange: 0x0C</span></span><br /><span data-ttu-id="5589a-185">- CertificateRequest: 0x0D</span><span class="sxs-lookup"><span data-stu-id="5589a-185">- CertificateRequest: 0x0D</span></span><br /><span data-ttu-id="5589a-186">- ServerHelloDone: 0x0E</span><span class="sxs-lookup"><span data-stu-id="5589a-186">- ServerHelloDone: 0x0E</span></span><br /><span data-ttu-id="5589a-187">- CertificateVerify: 0x0F</span><span class="sxs-lookup"><span data-stu-id="5589a-187">- CertificateVerify: 0x0F</span></span><br /><span data-ttu-id="5589a-188">- ClientKeyExchange: 0x10</span><span class="sxs-lookup"><span data-stu-id="5589a-188">- ClientKeyExchange: 0x10</span></span><br /><span data-ttu-id="5589a-189">- Finished: 0x14</span><span class="sxs-lookup"><span data-stu-id="5589a-189">- Finished: 0x14</span></span> |
| <span data-ttu-id="5589a-190">**Longitud de 24 bits**</span><span class="sxs-lookup"><span data-stu-id="5589a-190">**24-bit Length**</span></span> | <span data-ttu-id="5589a-191">Este campo contiene la longitud de los datos del mensaje del protocolo de enlace.</span><span class="sxs-lookup"><span data-stu-id="5589a-191">This field contains the length of the handshake message data.</span></span> |
| <span data-ttu-id="5589a-192">**Número de secuencia de 16 bits**</span><span class="sxs-lookup"><span data-stu-id="5589a-192">**16-bit Sequence Number**</span></span> | <span data-ttu-id="5589a-193">Este campo contiene un número de secuencia.</span><span class="sxs-lookup"><span data-stu-id="5589a-193">This field contains a sequence number.</span></span> |

### <a name="the-dtls-handshake-and-dtls-session"></a><span data-ttu-id="5589a-194">El protocolo de enlace DTLS y la sesión de DTLS</span><span class="sxs-lookup"><span data-stu-id="5589a-194">The DTLS Handshake and DTLS Session</span></span>

<span data-ttu-id="5589a-195">En la figura 3 se muestra un protocolo de enlace DTLS típico.</span><span class="sxs-lookup"><span data-stu-id="5589a-195">A typical DTLS handshake is shown in Figure 3.</span></span> <span data-ttu-id="5589a-196">Es casi idéntico al protocolo de enlace TLS típico con una diferencia importante: cuando el mensaje ClientHello se envía por primera vez, el servidor responde con un nuevo mensaje específico de DTLS, *HelloVerifyRequest* que contiene una “cookie”.</span><span class="sxs-lookup"><span data-stu-id="5589a-196">It is nearly identical to the typical TLS handshake with an important difference – when the ClientHello message is first sent, the server responds with a new DTLS-specific message, *HelloVerifyRequest* which contains a “cookie”.</span></span> <span data-ttu-id="5589a-197">El cliente DTLS debe responder con un segundo mensaje ClientHello que contenga esa cookie antes de que el protocolo de enlace pueda continuar.</span><span class="sxs-lookup"><span data-stu-id="5589a-197">The DTLS Client must respond with a second ClientHello message containing that cookie before the handshake can proceed.</span></span> <span data-ttu-id="5589a-198">Este mecanismo se ha agregado a DTLS para evitar determinados ataques de denegación de servicio (DoS), ya que UDP es un protocolo sin conexión (TCP requiere una conexión o un puerto dedicados para que TLS no sufra el mismo problema).</span><span class="sxs-lookup"><span data-stu-id="5589a-198">This mechanism was added to DTLS to prevent certain Denial of Service (DoS) attacks since UDP is a connectionless protocol (TCP requires a dedicated connection/port so TLS does not suffer from the same issue).</span></span>

<span data-ttu-id="5589a-199">Un protocolo de enlace DTLS comienza cuando el cliente envía un mensaje *ClientHello* a un servidor DTLS e indica su deseo de iniciar una sesión de DTLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-199">A DTLS handshake begins when the Client sends a *ClientHello* message to a DTLS server, indicating its desire to start a DTLS session.</span></span> <span data-ttu-id="5589a-200">El mensaje contiene información sobre el cifrado que el cliente desea utilizar para la sesión, junto con la información utilizada para generar las claves de sesión más adelante en el protocolo de enlace.</span><span class="sxs-lookup"><span data-stu-id="5589a-200">The message contains information about the encryption the client would like to use for the session, along with information used to generate the session keys later in the handshake.</span></span> <span data-ttu-id="5589a-201">Hasta que no se generen las claves de sesión, no se cifrarán todos los mensajes del protocolo de enlace DTLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-201">Until the session keys are generated, all messages in the DTLS handshake are not encrypted.</span></span> <span data-ttu-id="5589a-202">Como se mencionó anteriormente, el servidor DTLS puede enviar un valor HelloVerifyRequest en la respuesta a ClientHello, lo que obliga al cliente a responder con un segundo ClientHello actualizado.</span><span class="sxs-lookup"><span data-stu-id="5589a-202">As mentioned above, the DTLS Server may send a HelloVerifyRequest in response to the ClientHello, forcing the client to respond with a second updated ClientHello.</span></span>

<span data-ttu-id="5589a-203">Tras recibir el segundo mensaje ClientHello, el servidor DTLS comprobará la cookie y, si la respuesta es correcta, responderá con un mensaje ServerHello que indica una selección de las opciones de cifrado proporcionadas por el cliente.</span><span class="sxs-lookup"><span data-stu-id="5589a-203">Upon receiving the second ClientHello message, the DTLS Server will verify the cookie and if correct will respond with a ServerHello message indicating a selection from the encryption options provided by the client.</span></span> <span data-ttu-id="5589a-204">ServerHello va seguido de un mensaje de certificado en el que el servidor proporciona un certificado digital para autenticar su identidad en el cliente (si se usa la comprobación X.509).</span><span class="sxs-lookup"><span data-stu-id="5589a-204">The ServerHello is followed by a Certificate message, in which the server provides a digital certificate to authenticate its identity to the client (if X.509 verification is used).</span></span> <span data-ttu-id="5589a-205">Por último, el servidor envía un mensaje ServerHelloDone para indicar que no tiene más mensajes para enviar.</span><span class="sxs-lookup"><span data-stu-id="5589a-205">Finally, the server sends a ServerHelloDone message to indicate it has no more messages to send.</span></span> <span data-ttu-id="5589a-206">Opcionalmente, el servidor puede enviar otros mensajes después de ServerHello y, en algunos casos, puede no enviar un mensaje de certificado (por ejemplo, cuando se usan claves previamente compartidas), de ahí que el mensaje ServerHelloDone sea necesario.</span><span class="sxs-lookup"><span data-stu-id="5589a-206">The server may optionally send other messages following the ServerHello and in some cases it may not send a Certificate message (such as when Pre-Shared Keys are used), hence the need for the ServerHelloDone message.</span></span>

<span data-ttu-id="5589a-207">Una vez que el cliente ha recibido todos los mensajes del servidor, tiene suficiente información para generar las claves de sesión.</span><span class="sxs-lookup"><span data-stu-id="5589a-207">Once the client has received all the server’s messages, it has enough information to generate the session keys.</span></span> <span data-ttu-id="5589a-208">TLS/DTLS lo hace mediante la creación de un bit compartido de datos aleatorios denominado *secreto premaestro*, que tiene un tamaño fijo y se utiliza como un valor de inicialización para generar todas las claves necesarias una vez habilitado el cifrado.</span><span class="sxs-lookup"><span data-stu-id="5589a-208">TLS/DTLS does this by creating a shared bit of random data called the *Pre-Master Secret*, which is a fixed-size and is used as a seed to generate all the keys needed once encryption is enabled.</span></span> <span data-ttu-id="5589a-209">El secreto premaestro se cifra mediante el algoritmo de clave pública (por ejemplo, RSA) especificado en los mensajes Hello (consulte más abajo para obtener información sobre los algoritmos de clave pública) y la clave pública proporcionada por el servidor en su certificado.</span><span class="sxs-lookup"><span data-stu-id="5589a-209">The Pre-Master Secret is encrypted using the public key algorithm (e.g. RSA) specified in the Hello messages (see below for information on public key algorithms) and the public key provided by the server in its certificate.</span></span> <span data-ttu-id="5589a-210">Una característica opcional de TLS/DTLS denominada claves precompartidas (PSK) admite conjuntos de cifrado que no usan un certificado, sino un valor de secreto compartido entre los hosts (normalmente a través de transferencia física u otro método protegido).</span><span class="sxs-lookup"><span data-stu-id="5589a-210">An optional TLS/DTLS feature called Pre-Shared Keys (PSK) enables ciphersuites that do not use a certificate but instead use a secret value shared between the hosts (usually through physical transfer or other secured method).</span></span> <span data-ttu-id="5589a-211">Cuando se habilita PSK, se usa la clave secreta precompartida para generar el secreto premaestro.</span><span class="sxs-lookup"><span data-stu-id="5589a-211">When PSK is enabled, the pre-shared secret key is used to generate the Pre-Master Secret.</span></span> <span data-ttu-id="5589a-212">Consulte la sección sobre las claves precompartidas en “Métodos de autenticación” a continuación.</span><span class="sxs-lookup"><span data-stu-id="5589a-212">See the section on Pre-Shared Keys in “Authentication Methods” below.</span></span>

<span data-ttu-id="5589a-213">En un protocolo de enlace TLS/DTLS habitual, el secreto premaestro cifrado se envía al servidor en el mensaje ClientKeyExchange.</span><span class="sxs-lookup"><span data-stu-id="5589a-213">In a usual TLS/DTLS handshake, the encrypted Pre-Master Secret is sent to the server in the ClientKeyExchange message.</span></span> <span data-ttu-id="5589a-214">El servidor, al recibir el mensaje ClientKeyExchange, descifra el secreto premaestro mediante su clave privada y continúa generando las claves de sesión en paralelo con el cliente TLS/DTLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-214">The server, upon receiving the ClientKeyExchange message, decrypts the Pre-Master Secret using its private key and proceeds to generate the session keys in parallel with the TLS/DTLS client.</span></span>

<span data-ttu-id="5589a-215">Una vez generadas las claves de sesión, todos los mensajes posteriores se pueden cifrar mediante el algoritmo de clave privada (por ejemplo, AES) seleccionado en los mensajes Hello.</span><span class="sxs-lookup"><span data-stu-id="5589a-215">Once the session keys are generated, all further messages can be encrypted using the private-key algorithm (e.g. AES) selected in the Hello messages.</span></span> <span data-ttu-id="5589a-216">El cliente y el servidor envían un mensaje no cifrado final denominado ChangeCipherSpec para indicar que se cifrarán todos los mensajes posteriores.</span><span class="sxs-lookup"><span data-stu-id="5589a-216">One final un-encrypted message called ChangeCipherSpec is sent by both the client and server to indicate that all further messages will be encrypted.</span></span>

<span data-ttu-id="5589a-217">El primer mensaje cifrado enviado por el cliente y el servidor también es el mensaje de protocolo de enlace TLS final, denominado Finished.</span><span class="sxs-lookup"><span data-stu-id="5589a-217">The first encrypted message sent by both the client and server is also the final TLS handshake message, called Finished.</span></span> <span data-ttu-id="5589a-218">Este mensaje contiene un hash de todos los mensajes de protocolo de enlace recibidos y enviados.</span><span class="sxs-lookup"><span data-stu-id="5589a-218">This message contains a hash of all the handshake messages received and sent.</span></span> <span data-ttu-id="5589a-219">Este hash se utiliza para comprobar que ninguno de los mensajes del protocolo de enlace se ha manipulado o dañado (lo que indica una posible infracción de seguridad).</span><span class="sxs-lookup"><span data-stu-id="5589a-219">This hash is used to verify that none of the messages in the handshake have been tampered with or corrupted (indicating a possible breach of security).</span></span>

<span data-ttu-id="5589a-220">Una vez recibidos los mensajes Finished y comprobados los hashes del protocolo de enlace, se inicia la sesión de TLS/DTLS y la aplicación comienza a enviar y recibir datos.</span><span class="sxs-lookup"><span data-stu-id="5589a-220">Once the Finished messages are received and the handshake hashes are verified, the TLS/DTLS session begins, and the application begins sending and receiving data.</span></span> <span data-ttu-id="5589a-221">En primer lugar, se aplica un algoritmo hash a todos los datos enviados desde cualquier lado durante la sesión de TLS/DTLS con el algoritmo hash elegido en los mensajes Hello (para proporcionar integridad del mensaje) y se cifran mediante el algoritmo de clave privada elegido con las claves de sesión generadas.</span><span class="sxs-lookup"><span data-stu-id="5589a-221">All data sent by either side during the TLS/DTLS session is first hashed using the hash algorithm chosen in the Hello messages (to provide message integrity) and encrypted using the chosen private-key algorithm with the generated session keys.</span></span>

<span data-ttu-id="5589a-222">Por último, una sesión de TLS/DTLS solo se puede finalizar correctamente si el cliente o el servidor decide hacerlo.</span><span class="sxs-lookup"><span data-stu-id="5589a-222">Finally, a TLS/DTLS session can only be successfully ended if either the Client or Server chooses to do so.</span></span> <span data-ttu-id="5589a-223">Una sesión truncada se considera una infracción de seguridad (ya que un atacante puede estar intentando impedir que se reciban todos los datos que se envían), por lo que se envía una notificación especial cuando uno de los lados desea finalizar la sesión (denominada alerta CloseNotify).</span><span class="sxs-lookup"><span data-stu-id="5589a-223">A truncated session is considered a security breach (since an attacker may be attempting to prevent all the data being sent from being received) so a special notification is sent when either side wants to end the session, called a CloseNotify alert.</span></span> <span data-ttu-id="5589a-224">Tanto el cliente como el servidor deben enviar y procesar una alerta CloseNotify para que se cierre correctamente la sesión.</span><span class="sxs-lookup"><span data-stu-id="5589a-224">Both the client and server must send and process a CloseNotify alert for a successful session shutdown.</span></span>

![Diagrama de una sesión de protocolo de enlace DTLS típica.](media/image4.png)

<span data-ttu-id="5589a-226">**Figura 3: Protocolo de enlace DTLS típico**</span><span class="sxs-lookup"><span data-stu-id="5589a-226">**Figure 3- Typical DTLS handshake**</span></span>

### <a name="initialization"></a><span data-ttu-id="5589a-227">Inicialización</span><span class="sxs-lookup"><span data-stu-id="5589a-227">Initialization</span></span>

<span data-ttu-id="5589a-228">La pila de NetX o NetXDuo debe inicializarse antes de usar el servicio DTLS de NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="5589a-228">The NetX or NetXDuo stack must be initialized prior to using NetX Secure DTLS.</span></span> <span data-ttu-id="5589a-229">Consulte la guía de usuario de NetX o NetXDuo para obtener información sobre cómo inicializar correctamente la pila TCP/IP para el funcionamiento de UDP.</span><span class="sxs-lookup"><span data-stu-id="5589a-229">Refer to the NetX or NetXDuo User Guide for information on how to properly initialize the TCP/IP stack for UDP operation.</span></span>

<span data-ttu-id="5589a-230">Una vez inicializado UDP en NetX, se puede habilitar DTLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-230">Once NetX UDP has been initialized, DTLS can be enabled.</span></span> <span data-ttu-id="5589a-231">Internamente, todo el tráfico de red y el procesamiento de DTLS se controla mediante la pila de NetX/NetXDuo sin necesidad de la intervención del usuario.</span><span class="sxs-lookup"><span data-stu-id="5589a-231">Internally, all DTLS network traffic and processing is handled by the NetX/NetXDuo stack without requiring user intervention.</span></span> <span data-ttu-id="5589a-232">Sin embargo, DTLS tiene algunos requisitos específicos que se deben controlar de forma independiente de la pila de red subyacente.</span><span class="sxs-lookup"><span data-stu-id="5589a-232">However, DTLS has some specific requirements that must be handled separately from the underlying network stack.</span></span> <span data-ttu-id="5589a-233">En el cliente DTLS, estos parámetros se asignan al bloque de control de DTLS llamado \***NX_SECURE_DTLS_SESSION** _.</span><span class="sxs-lookup"><span data-stu-id="5589a-233">DTLS Client operation these parameters are assigned to the DTLS control block called \***NX_SECURE_DTLS_SESSION** _.</span></span> <span data-ttu-id="5589a-234">En el servidor DTLS, el bloque de control se denomina _ *_NX_SECURE_DTLS_SERVER_*\* y contiene la infraestructura necesaria para controlar varias sesiones DTLS en un único puerto UDP; tenga en cuenta que esto es diferente en TLS, donde cada sesión de TLS está enlazada a un único puerto TCP.</span><span class="sxs-lookup"><span data-stu-id="5589a-234">For DTLS Server operation, control block is called _ *_NX_SECURE_DTLS_SERVER_*\* and it contains the infrastructure needed to handle multiple DTLS sessions on a single UDP port – note that this is different from TLS where a each TLS session is bound to a single TCP port.</span></span>

<span data-ttu-id="5589a-235">Los dos modos de DTLS, servidor y cliente, pueden estar habilitados en una aplicación (pero solo un modo por socket NetX). Cada uno tiene sus propios requisitos específicos y se detallan a continuación.</span><span class="sxs-lookup"><span data-stu-id="5589a-235">The two DTLS modes, Server and Client, may be enabled in an application (but only one mode per NetX socket), and each have their own specific requirements, detailed below.</span></span>

### <a name="initialization--dtls-server"></a><span data-ttu-id="5589a-236">Inicialización: Servidor DTLS</span><span class="sxs-lookup"><span data-stu-id="5589a-236">Initialization – DTLS Server</span></span>

<span data-ttu-id="5589a-237">El modo de servidor del servicio DTLS de NetX Secure difiere del modo de servidor TLS debido al uso de UDP para el protocolo de transporte de red subyacente.</span><span class="sxs-lookup"><span data-stu-id="5589a-237">NetX Secure DTLS Server mode differs from TLS Server mode due to the use of UDP for the underlying network transport protocol.</span></span> <span data-ttu-id="5589a-238">Con TCP, el puerto se enlaza a un único host remoto mientras dure la sesión de TLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-238">With TCP, the port is bound to a single remote host for the duration of the TLS session.</span></span> <span data-ttu-id="5589a-239">UDP no tiene ninguna noción de estado con respecto al host remoto, por lo que todas las solicitudes de DTLS de distintos hosts se recibirán en la misma interfaz de UDP.</span><span class="sxs-lookup"><span data-stu-id="5589a-239">UDP has no notion of state with regard to the remote host so DTLS requests from different hosts will all be received on the same UDP interface.</span></span> <span data-ttu-id="5589a-240">Por lo tanto, DTLS debe mantener el estado de la sesión en lugar de confiar en el socket (como sucede con TLS y TCP).</span><span class="sxs-lookup"><span data-stu-id="5589a-240">Therefore, DTLS must maintain session state rather than relying on the socket as with TLS and TCP.</span></span> <span data-ttu-id="5589a-241">Por esta razón, el bloque de control del servidor DTLS (NX_SECURE_DTLS_SERVER) mantiene una asignación de información de host remoto (dirección IP y puerto) con las sesiones DTLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-241">For this reason, the DTLS Server control block (NX_SECURE_DTLS_SERVER) maintains a mapping of remote host information (IP address and port) to DTLS sessions.</span></span> <span data-ttu-id="5589a-242">Todos los datos entrantes en el socket UDP asignado a un servidor DTLS se asignarán a una sesión de DTLS existente o nueva basada en el host remoto.</span><span class="sxs-lookup"><span data-stu-id="5589a-242">All incoming data on the UDP socket assigned to a DTLS Server will be mapped to an existing or new DTLS session based on the remote host.</span></span> <span data-ttu-id="5589a-243">Por esta razón, la creación del servidor de DTLS requiere varios parámetros adicionales más allá de lo que los clientes de TLS y DTLS necesitan.</span><span class="sxs-lookup"><span data-stu-id="5589a-243">For this reason, the DTLS server creation requires several additional parameters beyond what TLS and DTLS Client need.</span></span>

<span data-ttu-id="5589a-244">Además del bloque de control del servidor DTLS, los conjuntos de cifrado de TLS y el búfer de cifrado de ScratchSpace/metadatos, los servidores DTLS necesitan un búfer para mantener las sesiones de DTLS y un búfer de reensamblado de paquetes que se usa para descifrar los registros DTLS entrantes.</span><span class="sxs-lookup"><span data-stu-id="5589a-244">In addition to the DTLS Server control block, TLS ciphersuites, and cipher scratchspace/metadata buffer, DTLS Servers require a buffer to maintain DTLS sessions and a packet reassembly buffer used to decrypt incoming DTLS records.</span></span>

<span data-ttu-id="5589a-245">Además de los búferes de la sesión, los servidores DTLS requieren un *certificado digital* (que es un documento que se usa para identificar el servidor TLS en el cliente TLS de conexión) y los certificados de *clave privada* correspondientes (normalmente para el algoritmo de cifrado RSA).</span><span class="sxs-lookup"><span data-stu-id="5589a-245">In addition to the session buffers, DTLS Servers require a *Digital Certificate*, which is a document used to identify the TLS server to the connecting TLS client, and the certificates corresponding *Private Key*, usually for the RSA encryption algorithm.</span></span> <span data-ttu-id="5589a-246">La norma International Telecommunications Union X.509 especifica el formato de certificado que usa TLS/DTLS y hay numerosas utilidades para crear certificados digitales X.509.</span><span class="sxs-lookup"><span data-stu-id="5589a-246">The International Telecommunications Union X.509 standard specifies the certificate format used by TLS/DTLS and there are numerous utilities for creating X.509 digital certificates.</span></span>

<span data-ttu-id="5589a-247">En el caso del servicio DTLS de NetX Secure, el certificado X.509 debe estar codificado de forma binaria con el formato de reglas de codificación distinguida (DER) de ASN.1.</span><span class="sxs-lookup"><span data-stu-id="5589a-247">For NetX Secure DTLS, the X.509 certificate must be binary-encoded using the Distinguished Encoding Rules (DER) format of ASN.1.</span></span> <span data-ttu-id="5589a-248">DER es el formato binario estándar TLS por cable para los certificados.</span><span class="sxs-lookup"><span data-stu-id="5589a-248">DER is the standard TLS over-the-wire binary format for certificates.</span></span>

<span data-ttu-id="5589a-249">La clave privada asociada con el certificado proporcionado debe estar en formato PKCS#1 codificado mediante DER.</span><span class="sxs-lookup"><span data-stu-id="5589a-249">The private key associated with the provided certificate must be in DER-Encoded PKCS#1 format.</span></span> <span data-ttu-id="5589a-250">La clave privada solo se usa en el dispositivo y nunca se transmitirá a través de la conexión.</span><span class="sxs-lookup"><span data-stu-id="5589a-250">The private key is only used on the device and will never be transmitted over the wire.</span></span> <span data-ttu-id="5589a-251">¡Mantenga las claves privadas seguras, ya que proporcionan la seguridad de las comunicaciones TLS/DTLS!</span><span class="sxs-lookup"><span data-stu-id="5589a-251">Keep private keys safe as they provide the security for TLS/DTLS communications!</span></span>

<span data-ttu-id="5589a-252">Para inicializar el certificado de servidor DTLS, la aplicación debe proporcionar un puntero a un búfer que contenga el certificado X.509 codificado mediante DER y datos opcionales de clave privada RSA PKCS#1 codificados mediante DER con el servicio ***nx_secure_x509_certificate_intialize*** (que rellena la estructura de **NX_SECURE_X509_CERT** con los datos de certificado adecuados para su uso por parte de TLS).</span><span class="sxs-lookup"><span data-stu-id="5589a-252">To initialize the DTLS Server certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate and optional DER-encoded PKCS#1 RSA private key data using the ***nx_secure_x509_certificate_intialize*** service, which populates the **NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="5589a-253">Una vez inicializado el certificado de servidor, debe agregarse al bloque de control de TLS mediante el servicio ***nx_secure_dtls_server_local_certificate_add***.</span><span class="sxs-lookup"><span data-stu-id="5589a-253">Once the server certificate has been initialized, it must be added to the TLS control block using the ***nx_secure_dtls_server_local_certificate_add*** service.</span></span>

<span data-ttu-id="5589a-254">Una vez agregado el certificado del servidor al bloque de control del servidor DTLS, el servidor se puede usar para proteger las comunicaciones de DTLS (consulte el ejemplo anterior).</span><span class="sxs-lookup"><span data-stu-id="5589a-254">Once the server’s certificate has been added to the DTLS Server control block, the server can be used for secure DTLS communications (see example above).</span></span>

### <a name="initialization--dtls-client"></a><span data-ttu-id="5589a-255">Inicialización: Cliente DTLS</span><span class="sxs-lookup"><span data-stu-id="5589a-255">Initialization – DTLS Client</span></span>

<span data-ttu-id="5589a-256">El modo de cliente DTLS de NetX Secure es sencillo en comparación con el del servidor DTLS, ya que solo hay una conexión saliente al host remoto a través del socket UDP.</span><span class="sxs-lookup"><span data-stu-id="5589a-256">NetX Secure DTLS Client mode is simple in operation compared to the DTLS server since there is only a single outgoing connection to the remote host over the UDP socket.</span></span>

<span data-ttu-id="5589a-257">Para configurar un cliente DTLS, se necesita un *almacén de certificados de confianza*, que es una colección de certificados digitales con codificación X.509 de las entidades de certificación de confianza (CA).</span><span class="sxs-lookup"><span data-stu-id="5589a-257">To setup a DTLS Client, it requires a *Trusted Certificate Store*, which is a collection of X.509-encoded digital certificates from trusted Certificate Authorities (CA’s).</span></span> <span data-ttu-id="5589a-258">El protocolo DTLS da por supuesto que estos certificados son “de confianza” y sirven como base para autenticar los certificados proporcionados por las entidades de servidor DTLS en la aplicación cliente de DTLS de NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="5589a-258">These certificates are assumed by the DTLS protocol to be “trusted” and serve as the basis for authenticating certificates provided by DTLS server entities to the NetX Secure DTLS Client application.</span></span>

<span data-ttu-id="5589a-259">Un certificado de CA de confianza puede ser *autofirmado* o firmado por otra CA, en cuyo caso el certificado se denomina de *CA intermedia* (ICA).</span><span class="sxs-lookup"><span data-stu-id="5589a-259">A trusted CA certificate may either be *self-signed* or signed by another CA, in which case that certificate is called an *Intermediate CA* (ICA).</span></span> <span data-ttu-id="5589a-260">En una aplicación TLS/DTLS típica, el servidor proporciona los certificados ICA junto con su certificado de servidor, pero el único requisito para la autenticación correcta es que se pueda realizar un seguimiento de una cadena de emisores (certificados usados para firmar otros certificados) desde el certificado de servidor a un certificado de CA de confianza en el almacén de certificados de confianza.</span><span class="sxs-lookup"><span data-stu-id="5589a-260">In a typical TLS/DTLS application, the server provides the ICA certificates along with its server certificate, but the only requirement for successful authentication is that a chain of issuers (certificates used to sign other certificates) can be traced from the server certificate back to a trusted CA certificate in the Trusted Certificate Store.</span></span> <span data-ttu-id="5589a-261">Esta cadena se conoce como *cadena de confianza* o *cadena de certificados*.</span><span class="sxs-lookup"><span data-stu-id="5589a-261">This chain is known as a *chain of trust* or *certificate chain*.</span></span>

<span data-ttu-id="5589a-262">Para inicializar un certificado de CA o ICA de confianza, la aplicación debe proporcionar un puntero a un búfer que contenga el certificado X.509 codificado mediante DER con el servicio **nx_secure_x509_certificate_intialize** (que rellena la estructura de *NX_SECURE_X509_CERT*\* con los datos de certificado adecuados para su uso por parte de TLS).</span><span class="sxs-lookup"><span data-stu-id="5589a-262">To initialize a trusted CA or ICA certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate using the ***nx_secure_x509_certificate_intialize** _ service, which populates the _ *NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="5589a-263">El cliente DTLS también necesita espacio para asignar el certificado de servidor entrante (suponiendo que no se use un modo de clave precompartida) y un búfer para ensamblar paquetes en registros de DTLS para descifrarlos.</span><span class="sxs-lookup"><span data-stu-id="5589a-263">The DTLS Client also needs space for the incoming server certificate to be allocated (assuming a Pre-Shared Key mode is not being used) and a buffer for assembling packets into DTLS records to be decrypted.</span></span> <span data-ttu-id="5589a-264">Estos búferes se pasan como parámetros al servicio ***nx_secure_dtls_session_create*** (consulte la referencia de la API para obtener más información).</span><span class="sxs-lookup"><span data-stu-id="5589a-264">These buffers are passed in as parameters to the ***nx_secure_dtls_session_create*** service (see API reference for more information).</span></span>

<span data-ttu-id="5589a-265">Los certificados de confianza que se han inicializado se agregan a continuación al bloque de control de sesión de DTLS creado mediante el servicio ***nx_secure_dtls_session_trusted_certificate_add***.</span><span class="sxs-lookup"><span data-stu-id="5589a-265">Trusted certificates that have been initialized are then added to the created DTLS session control block using the ***nx_secure_dtls_session_trusted_certificate_add*** service.</span></span> <span data-ttu-id="5589a-266">Si no se agrega un certificado, se producirá un error en la sesión de cliente DTLS, ya que no habrá forma de que el protocolo DTLS autentique los hosts de servidor remotos.</span><span class="sxs-lookup"><span data-stu-id="5589a-266">Failure to add a certificate will cause the DTLS Client session to fail as there will be no way for the DTLS protocol to authenticate remote server hosts.</span></span>

<span data-ttu-id="5589a-267">Una vez creado el almacén de certificados de confianza, la sesión se puede usar para establecer una conexión de cliente TLS segura.</span><span class="sxs-lookup"><span data-stu-id="5589a-267">Once the Trusted Certificate Store has been created the session may be used to establish a secure TLS Client connection.</span></span>

### <a name="application-interface-calls"></a><span data-ttu-id="5589a-268">Llamadas a la interfaz de la aplicación</span><span class="sxs-lookup"><span data-stu-id="5589a-268">Application Interface Calls</span></span>

<span data-ttu-id="5589a-269">Las aplicaciones DTLS de NetX Secure normalmente realizarán llamadas de función desde subprocesos de la aplicación que se ejecutan en ThreadX RTOS.</span><span class="sxs-lookup"><span data-stu-id="5589a-269">NetX Secure DTLS applications will typically make function calls from within application threads running under the ThreadX RTOS.</span></span> <span data-ttu-id="5589a-270">Se puede llamar a cierta inicialización, especialmente para los protocolos de comunicaciones de red subyacentes (por ejemplo, UDP y IP), desde \***tx_application_define\*.**</span><span class="sxs-lookup"><span data-stu-id="5589a-270">Some initialization, particularly for the underlying network communications protocols (e.g. UDP and IP) may be called from \***tx_application_define\*.**</span></span> <span data-ttu-id="5589a-271">Consulte la guía de usuario de NetX/NetXDuo para obtener más información sobre cómo inicializar las comunicaciones de red.</span><span class="sxs-lookup"><span data-stu-id="5589a-271">See the NetX/NetXDuo User Guide for more information on initializing network communications.</span></span>

<span data-ttu-id="5589a-272">DTLS hace un uso intensivo de las rutinas de cifrado que son operaciones de uso intensivo del procesador.</span><span class="sxs-lookup"><span data-stu-id="5589a-272">DTLS makes heavy use of encryption routines which are processor-intensive operations.</span></span> <span data-ttu-id="5589a-273">Por lo general, estas operaciones se realizarán en el contexto del subproceso que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="5589a-273">Generally, these operations will be performed within the context of calling thread.</span></span>

### <a name="dtls-session-start"></a><span data-ttu-id="5589a-274">Inicio de sesión de DTLS</span><span class="sxs-lookup"><span data-stu-id="5589a-274">DTLS Session Start</span></span>

<span data-ttu-id="5589a-275">DTLS requiere un protocolo de red de capa de transporte subyacente para poder funcionar.</span><span class="sxs-lookup"><span data-stu-id="5589a-275">DTLS requires an underlying transport-layer network protocol in order to function.</span></span> <span data-ttu-id="5589a-276">El protocolo que se usa normalmente es TCP.</span><span class="sxs-lookup"><span data-stu-id="5589a-276">The protocol typically used is TCP.</span></span> <span data-ttu-id="5589a-277">Para establecer una sesión de TLS de NetX Secure, se debe crear **NX_UDP_SOCKET** y pasarlo al servicio **_nx_secure_dtls_client_session_start_** para los clientes DTLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-277">In order to establish a NetX Secure TLS session an **NX_UDP_SOCKET** must be created and passed into the **_nx_secure_dtls_client_session_start_** service for DTLS Clients.</span></span>

<span data-ttu-id="5589a-278">Los servidores DTLS funcionan de manera diferente.</span><span class="sxs-lookup"><span data-stu-id="5589a-278">DTLS Servers operate differently.</span></span> <span data-ttu-id="5589a-279">El socket UDP usado para las solicitudes entrantes de cliente DTLS se encuentra dentro del bloque de control NX_SECURE_DTLS_SERVER y se inicializa en la llamada a \***nx_secure_dtls_server_create** _, que toma el puerto UDP local como parámetro.</span><span class="sxs-lookup"><span data-stu-id="5589a-279">The UDP socket used for incoming DTLS Client requests is contained within the NX_SECURE_DTLS_SERVER control block and is initialized in the call to \***nx_secure_dtls_server_create** _, which takes the local UDP port as a parameter.</span></span> <span data-ttu-id="5589a-280">El servicio _*_nx_secure_dtls_server_start_*_ se utiliza para iniciar el servidor DTLS con el fin de controlar las solicitudes entrantes.</span><span class="sxs-lookup"><span data-stu-id="5589a-280">The service _*_nx_secure_dtls_server_start_*_ is then used to start the DTLS Server to handle incoming requests.</span></span> <span data-ttu-id="5589a-281">Todas las solicitudes entrantes se administran en rutinas de devolución de llamada proporcionadas a _nx_secure_dtls_server_create\*: una para las conexiones y otra para las notificaciones de recepción. Depende de la aplicación controlar el inicio de la sesión de DTLS cuando se recibe una notificación de conexión (se invoca la devolución de llamada de notificación de conexión a través de DTLS) mediante una llamada a \***nx_secure_dtls_server_session_start**_.</span><span class="sxs-lookup"><span data-stu-id="5589a-281">All incoming requests are handled in callback routines provided to _nx_secure_dtls_server_create\*: one for connections and one for receive notifications. It is up to the application to handle starting the DTLS session when a connection notification is received (the connect notify callback is invoked by DTLS) by calling \***nx_secure_dtls_server_session_start**_.</span></span> <span data-ttu-id="5589a-282">La aplicación también debe controlar los datos entrantes cuando se invoca la devolución de llamada de notificación de recepción (que sigue a un protocolo de enlace DTLS completado) mediante una llamada a _\*_nx_secure_dtls_session_receive_\*\*.</span><span class="sxs-lookup"><span data-stu-id="5589a-282">The application also must handle incoming data when the receive notify callback is invoked (which follows a completed DTLS handshake) by calling _\*_nx_secure_dtls_session_receive_\*\*.</span></span> <span data-ttu-id="5589a-283">Los detalles se proporcionan en el ejemplo anterior y en la referencia de la API para cada uno de los servicios mencionados anteriormente.</span><span class="sxs-lookup"><span data-stu-id="5589a-283">The details of this are provided in the example above and in the API reference for each of the above mentioned services.</span></span>

### <a name="dtls-packet-allocation"></a><span data-ttu-id="5589a-284">Asignación de paquetes DTLS</span><span class="sxs-lookup"><span data-stu-id="5589a-284">DTLS Packet Allocation</span></span>

<span data-ttu-id="5589a-285">El servicio DTLS de NetX Secure usa la misma estructura de paquetes que el protocolo TCP de NetX/NetXDuo (***NX_PACKET** _), salvo que, en lugar de llamar al servicio _*_nx_packet_allocate_*_, se debe llamar al servicio _ *_nx_secure_dtls_packet_allocate_** para que se pueda asignar correctamente el espacio para el encabezado DTLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-285">NetX Secure DTLS uses the same packet structure as NetX/NetXDuo TCP (***NX_PACKET** _) except that instead of calling the _*_nx_packet_allocate_*_ service, the _ *_nx_secure_dtls_packet_allocate_** service must be called so that space for the DTLS header may be allocated properly.</span></span>

### <a name="dtls-session-send"></a><span data-ttu-id="5589a-286">Envío de sesión de DTLS</span><span class="sxs-lookup"><span data-stu-id="5589a-286">DTLS Session Send</span></span>

<span data-ttu-id="5589a-287">Una vez iniciada la sesión TLS, la aplicación puede enviar datos mediante el servicio ***nx_secure_dtls_session_send***.</span><span class="sxs-lookup"><span data-stu-id="5589a-287">Once the TLS session has started, the application may send data using the ***nx_secure_dtls_session_send*** service.</span></span> <span data-ttu-id="5589a-288">El uso del servicio de envío es idéntico para el servicio ***nx_udp_socket_send** _, que toma una estructura de datos _ *_NX_PACKET_** con los datos que se envían, una dirección IP de destino y un puerto UDP de destino.</span><span class="sxs-lookup"><span data-stu-id="5589a-288">The send service is identical in use to the ***nx_udp_socket_send** _ service, taking an _ *_NX_PACKET_** data structure containing the data being sent, a target IP address, and a target UDP port.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5589a-289">Al enviar datos mediante nx_secure_dtls_session_send, es importante usar la misma dirección IP y el mismo puerto que se usaron para establecer la sesión de DTLS, a menos que haya un mecanismo para pasar la sesión a una nueva dirección y puerto UDP sobre la marcha (esto no es habitual).</span><span class="sxs-lookup"><span data-stu-id="5589a-289">When sending data using nx_secure_dtls_session_send, it is important to use the same IP address and port that were used to establish the DTLS session, unless there is a mechanism in place to move the session to a new address and UDP port on-the-fly (this is not common).</span></span>

<span data-ttu-id="5589a-290">Los datos enviados a través de DTLS se cifrarán mediante la pila DTLS de NX Secure y las rutinas de cifrado configuradas antes de enviarse.</span><span class="sxs-lookup"><span data-stu-id="5589a-290">Any data sent over DTLS will be encrypted by the NX Secure DTLS stack and the configured encryption routines before being sent.</span></span>

### <a name="dtls-session-receive"></a><span data-ttu-id="5589a-291">Recepción de sesión de DTLS</span><span class="sxs-lookup"><span data-stu-id="5589a-291">DTLS Session Receive</span></span>

<span data-ttu-id="5589a-292">Una vez iniciada la sesión de DTLS, la aplicación puede empezar a recibir datos mediante el servicio \***nx_secure_Dtls_session_receive** _.</span><span class="sxs-lookup"><span data-stu-id="5589a-292">Once the DTLS session has started, the application may begin receiving data using the \***nx_secure_Dtls_session_receive** _ service.</span></span> <span data-ttu-id="5589a-293">Al igual que el envío de la sesión de DTLS, este servicio se usa exactamente igual que _\*_nx_udp_socket_receive_\*\*, con la salvedad de que la pila DTLS descifra y comprueba los datos entrantes antes de que se devuelvan en la estructura de paquetes.</span><span class="sxs-lookup"><span data-stu-id="5589a-293">Like the DTLS Session send, this service is identical in use to _\*_nx_udp_socket_receive_\*\*, except that the incoming data is decrypted and verified by the DTLS stack before being returned in the packet structure.</span></span>

### <a name="tls-session-close"></a><span data-ttu-id="5589a-294">Cierre de sesión de TLS</span><span class="sxs-lookup"><span data-stu-id="5589a-294">TLS Session Close</span></span>

<span data-ttu-id="5589a-295">Una vez completada una sesión de DTLS, tanto el cliente como el servidor DTLS deben enviar una alerta CloseNotify al otro lado para cerrar la sesión.</span><span class="sxs-lookup"><span data-stu-id="5589a-295">Once a DTLS session is complete, both the DTLS client and server must send a CloseNotify alert to the other side to shut down the session.</span></span> <span data-ttu-id="5589a-296">Ambos lados deben recibir y procesar la alerta para asegurarse de que el cierre de sesión se ha realizado correctamente.</span><span class="sxs-lookup"><span data-stu-id="5589a-296">Both sides must receive and process the alert to ensure a successful session shutdown.</span></span>

<span data-ttu-id="5589a-297">Si el host remoto envía una alerta CloseNotify, todas las llamadas al servicio ***nx_secure_dtls_session_receive** _ procesarán la alerta, enviarán de nuevo la alerta correspondiente al host remoto y devolverán un valor de _*_NX_SECURE_TLS_SESSION_CLOSED_\*\*.</span><span class="sxs-lookup"><span data-stu-id="5589a-297">If the remote host sends a CloseNotify alert, any calls to the ***nx_secure_dtls_session_receive** _ service will process the alert, send the corresponding alert back to the remote host, and return a value of _*_NX_SECURE_TLS_SESSION_CLOSED_\*\*.</span></span> <span data-ttu-id="5589a-298">Una vez cerrada la sesión, se producirá un error en cualquier intento adicional de enviar o recibir datos con esa sesión de DTLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-298">Once the session is closed, any further attempts to send or receive data with that DTLS session will fail.</span></span>

<span data-ttu-id="5589a-299">Si la aplicación desea cerrar la sesión de TLS, se debe llamar al servicio \***nx_secure_dtls_session_end** _.</span><span class="sxs-lookup"><span data-stu-id="5589a-299">If the application wishes to close the TLS session, the \***nx_secure_dtls_session_end** _ service must be called.</span></span> <span data-ttu-id="5589a-300">El servicio enviará la alerta CloseNotify y procesará la respuesta CloseNotify.</span><span class="sxs-lookup"><span data-stu-id="5589a-300">The service will send the CloseNotify alert and process the response CloseNotify.</span></span> <span data-ttu-id="5589a-301">Si no se recibe la respuesta, se devolverá un valor de error de _ \*_NX_SECURE_TLS_SESSION_CLOSE_FAIL_\*\*, lo que indica que la sesión de DTLS no se apagó correctamente y puede indicar una posible infracción de seguridad.</span><span class="sxs-lookup"><span data-stu-id="5589a-301">If the response is not received, an error value of _ *_NX_SECURE_TLS_SESSION_CLOSE_FAIL_*\* will be returned, indicating that the DTLS session was not cleanly shutdown, a possible security breach.</span></span>

### <a name="tlsdtls-alerts"></a><span data-ttu-id="5589a-302">Alertas TLS/DTLS</span><span class="sxs-lookup"><span data-stu-id="5589a-302">TLS/DTLS Alerts</span></span>

<span data-ttu-id="5589a-303">TLS/DTLS está diseñado para proporcionar la máxima seguridad, por lo que cualquier comportamiento errante en el protocolo se considera una posible infracción de seguridad.</span><span class="sxs-lookup"><span data-stu-id="5589a-303">TLS/DTLS is designed to provide maximum security, so any errant behavior in the protocol is considered a potential security breach.</span></span> <span data-ttu-id="5589a-304">Por esta razón, los errores en el procesamiento de mensajes o el cifrado y descifrado se consideran errores irrecuperables que finalizan la sesión o el protocolo de enlace inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="5589a-304">For this reason, any errors in message processing or encryption/decryption are considered fatal errors that terminate the handshake or session immediately.</span></span>

<span data-ttu-id="5589a-305">Aunque el control de errores en una aplicación local es relativamente sencillo, el host remoto debe saber que se ha producido un error con el fin de controlar correctamente la situación y evitar posibles infracciones de seguridad.</span><span class="sxs-lookup"><span data-stu-id="5589a-305">While handling errors in a local application is relatively straightforward, the remote host needs to know that an error has occurred in order to properly handle the situation and prevent any further possible security breaches.</span></span> <span data-ttu-id="5589a-306">Por esta razón, TLS/DTLS enviará un mensaje de *alerta* al host remoto en caso de error.</span><span class="sxs-lookup"><span data-stu-id="5589a-306">For this reason, TLS/DTLS will send an *Alert* message to the remote host upon any error.</span></span>

<span data-ttu-id="5589a-307">Las alertas se tratan de la misma manera que cualquier otro mensaje de TLS/DTLS y se cifran durante la sesión para impedir que un atacante recopile información del tipo de alerta proporcionado.</span><span class="sxs-lookup"><span data-stu-id="5589a-307">Alerts are treated in the same manner as any other TLS/DTLS messages and are encrypted during the session to prevent an attacker from gathering information from the type of alert provided.</span></span> <span data-ttu-id="5589a-308">Durante el protocolo de enlace, el ámbito de las alertas enviadas está limitado para controlar la cantidad de información que podría obtener un atacante potencial.</span><span class="sxs-lookup"><span data-stu-id="5589a-308">During the handshake, the alerts sent are limited in scope to limit the amount of information that could be obtained by a potential attacker.</span></span>

<span data-ttu-id="5589a-309">La alerta CloseNotify, que se usa para cerrar la sesión de TLS/DTLS, es la única alerta no grave.</span><span class="sxs-lookup"><span data-stu-id="5589a-309">The CloseNotify alert, used to close the TLS/DTLS session, is the only non-fatal alert.</span></span> <span data-ttu-id="5589a-310">Aunque se considera una alerta y se envía como un mensaje de alerta, CloseNotify es diferente de otras alertas, ya que no indica que se ha producido un error.</span><span class="sxs-lookup"><span data-stu-id="5589a-310">While it is considered an alert and sent as an alert message, a CloseNotify is unlike other alerts in that it does not indicate an error has occurred.</span></span>

### <a name="tlsdtls-session-renegotiation-and-resumption"></a><span data-ttu-id="5589a-311">Renegociación y reanudación de la sesión de TLS/DTLS</span><span class="sxs-lookup"><span data-stu-id="5589a-311">TLS/DTLS Session Renegotiation and Resumption</span></span>

<span data-ttu-id="5589a-312">TLS admite la noción de “renegociación”, que es simplemente una renegociación de los parámetros de sesión de TLS en el contexto de una sesión de TLS existente.</span><span class="sxs-lookup"><span data-stu-id="5589a-312">TLS supports the notion of “renegotiation” which is simply a renegotiation of the TLS session parameters within the context of an existing TLS session.</span></span>

<span data-ttu-id="5589a-313">A pesar de tener ciertas similitudes, la *reanudación* de la sesión TLS no se debe confundir con la *renegociación* de la sesión.</span><span class="sxs-lookup"><span data-stu-id="5589a-313">TLS session *resumption* should not be confused with session *renegotiation*, despite some similarities.</span></span> <span data-ttu-id="5589a-314">En los casos en que la *renegociación* de la sesión implica iniciar un nuevo protocolo de enlace dentro de una sesión de TLS existente, la *reanudación* de la sesión es una característica puramente opcional que implica el reinicio de una sesión de TLS cerrada sin necesidad de realizar un protocolo de enlace TLS completo.</span><span class="sxs-lookup"><span data-stu-id="5589a-314">Where session *renegotiation* involves starting a new handshake within an existing TLS session, session *resumption* is a purely optional feature that involves restarting a closed TLS session without performing a complete TLS handshake.</span></span>

<span data-ttu-id="5589a-315">El servicio DTLS de NX Secure controla las solicitudes de renegociación entrantes de hosts remotos.</span><span class="sxs-lookup"><span data-stu-id="5589a-315">NX Secure DTLS handles incoming renegotiation requests from remote hosts.</span></span> <span data-ttu-id="5589a-316">**No** admite la reanudación de la sesión.</span><span class="sxs-lookup"><span data-stu-id="5589a-316">It does **not** support session resumption.</span></span> <span data-ttu-id="5589a-317">Encontrará una explicación más completa de estas características en el capítulo 3 de la guía de usuario del servicio TLS de NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="5589a-317">A more complete discussion of these features can be found in Chapter 3 of the NetX Secure TLS User Guide.</span></span>

### <a name="protocol-layering"></a><span data-ttu-id="5589a-318">Capas de protocolo</span><span class="sxs-lookup"><span data-stu-id="5589a-318">Protocol Layering</span></span>

<span data-ttu-id="5589a-319">El protocolo TLS (y, por lo tanto, también DTLS) encaja en la pila de red entre la capa de transporte (por ejemplo, TCP o UDP) y la capa de aplicación.</span><span class="sxs-lookup"><span data-stu-id="5589a-319">The TLS protocol (and therefore DTLS as well) fits into the networking stack between the transport layer (e.g. TCP or UDP) and the application layer.</span></span> <span data-ttu-id="5589a-320">TLS se considera a veces un protocolo de capa de transporte (de ahí su nombre: seguridad de la *capa de transporte*), pero dado que actúa como una aplicación con respecto a los protocolos de red subyacentes, a veces se agrupa en la capa de aplicación.</span><span class="sxs-lookup"><span data-stu-id="5589a-320">TLS is sometimes considered a transport-layer protocol (hence *Transport Layer* Security) but because it acts as an application with regard to the underlying network protocols it is sometimes grouped into the application layer.</span></span>

<span data-ttu-id="5589a-321">TLS requiere un protocolo de capa de transporte que admita la entrega en orden y sin pérdidas, como TCP.</span><span class="sxs-lookup"><span data-stu-id="5589a-321">TLS requires a transport layer protocol that supports in-order and lossless delivery, such as TCP.</span></span> <span data-ttu-id="5589a-322">Debido a este requisito, no se puede ejecutar TLS sobre UDP, ya que UDP no garantiza la entrega de datagramas.</span><span class="sxs-lookup"><span data-stu-id="5589a-322">Due to this requirement, TLS cannot run on top of UDP since UDP does not guarantee delivery of datagrams.</span></span> <span data-ttu-id="5589a-323">*DTLS* es una versión modificada de TLS que se utiliza para las aplicaciones que necesitan la seguridad de TLS a través de un protocolo de datagramas como UDP.</span><span class="sxs-lookup"><span data-stu-id="5589a-323">*DTLS* is a modified version of TLS, is used for applications that need the security of TLS over a datagram protocol like UDP.</span></span>

![Diagrama de las capas de un protocolo TLS.](media/image6.png)

<span data-ttu-id="5589a-325">**Figura 4: Capas de protocolo TCP/IP, UDP y TLS/DTLS**</span><span class="sxs-lookup"><span data-stu-id="5589a-325">**Figure 4- TCP/IP, UDP and TLS/DTLS protocol layers**</span></span>

## <a name="network-communications-security-and-encryption"></a><span data-ttu-id="5589a-326">Seguridad y cifrado de las comunicaciones de red</span><span class="sxs-lookup"><span data-stu-id="5589a-326">Network Communications Security and Encryption</span></span>

<span data-ttu-id="5589a-327">La protección de las comunicaciones a través de redes públicas e Internet es un tema muy importante y es protagonista de una gran cantidad de libros, artículos y soluciones.</span><span class="sxs-lookup"><span data-stu-id="5589a-327">Securing communications over public networks and the Internet is a critically important topic and the subject of vast numbers of books, articles, and solutions.</span></span> <span data-ttu-id="5589a-328">El tema es el increíblemente complejo, pero se puede reducir a una idea sencilla: enviar información a través de una red para que solo el destinatario previsto pueda acceder a la información o cambiarla.</span><span class="sxs-lookup"><span data-stu-id="5589a-328">The topic is mind-bogglingly complex, but can be reduced to a simple idea: sending information over a network so that only the intended target can access or change that information.</span></span> <span data-ttu-id="5589a-329">Esto se divide en tres conceptos importantes: confidencialidad, integridad y autenticación.</span><span class="sxs-lookup"><span data-stu-id="5589a-329">This breaks down into three important concepts: secrecy, integrity, and authentication.</span></span> <span data-ttu-id="5589a-330">El protocolo TLS/DTLS proporciona soluciones para los tres.</span><span class="sxs-lookup"><span data-stu-id="5589a-330">The TLS/DTLS protocol provides solutions for all three.</span></span>

<span data-ttu-id="5589a-331">El cifrado se usa de maneras diferentes para proporcionar confidencialidad, integridad y autenticación dentro de los protocolos TLS y DTLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-331">Encryption is used in different ways to provide secrecy, integrity, and authentication within the TLS and DTLS protocols.</span></span> <span data-ttu-id="5589a-332">El cifrado debe proporcionarse a TLS o DTLS tras la creación de una sesión o una instancia del servidor, ya que TLS ofrece un marco flexible para usar el cifrado y no el propio cifrado.</span><span class="sxs-lookup"><span data-stu-id="5589a-332">The encryption must be supplied to TLS or DTLS upon creation of a session or server instance as TLS provides a flexible framework for using encryption and not the encryption itself.</span></span> <span data-ttu-id="5589a-333">El servicio DTLS de NetX Secure proporciona las rutinas de cifrado necesarias para la mayoría de las aplicaciones, por lo que no tiene que preocuparse de encontrar el cifrado adecuado.</span><span class="sxs-lookup"><span data-stu-id="5589a-333">NetX Secure DTLS provides the necessary encryption routines for most applications so you do not have to be concerned about finding appropriate encryption.</span></span>

<span data-ttu-id="5589a-334">Puede encontrar una descripción más detallada de estos temas en el capítulo 3 de la guía de usuario del servicio TLS de NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="5589a-334">A more detailed description of these topics can be found in Chapter 3 of the NetX Secure TLS User Guide.</span></span>

## <a name="tls-and-dtls-extensions"></a><span data-ttu-id="5589a-335">Extensiones de TLS y DTLS</span><span class="sxs-lookup"><span data-stu-id="5589a-335">TLS and DTLS Extensions</span></span>

<span data-ttu-id="5589a-336">TLS (y, por tanto, DTLS) incluyen una serie de extensiones que ofrecen funcionalidad adicional para ciertas aplicaciones.</span><span class="sxs-lookup"><span data-stu-id="5589a-336">TLS (and therefore DTLS) provides a number of extensions that provide additional functionality for certain applications.</span></span> <span data-ttu-id="5589a-337">Normalmente, estas extensiones se envían como parte de los mensajes ClientHello o ServerHello, lo que indica a un host remoto el deseo de usar una extensión o proporciona detalles adicionales para su uso en el establecimiento de la sesión de TLS segura.</span><span class="sxs-lookup"><span data-stu-id="5589a-337">These extensions are typically sent as part of the ClientHello or ServerHello messages, indicating to a remote host the desire to use an extension or providing additional details for use in establishing the secure TLS session.</span></span>

<span data-ttu-id="5589a-338">El servicio DTLS de NetX Secure admite todas las extensiones del servicio TLS de NetX Secure. Encontrará una descripción completa de las extensiones en el capítulo 3 de la guía de usuario del servicio TLS de NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="5589a-338">NetX Secure DTLS supports all of the extensions found in NetX Secure TLS, and a complete description of those can be found in the NetX Secure TLS User Guide, Chapter 3.</span></span>

## <a name="authentication-methods"></a><span data-ttu-id="5589a-339">Métodos de autenticación</span><span class="sxs-lookup"><span data-stu-id="5589a-339">Authentication Methods</span></span>

<span data-ttu-id="5589a-340">TLS y DTLS proporcionan el marco para establecer una conexión segura entre dos dispositivos a través de una red no segura, pero parte del problema es conocer la identidad del dispositivo en el otro extremo de la conexión.</span><span class="sxs-lookup"><span data-stu-id="5589a-340">TLS and DTLS provide the framework for establishing a secure connection between two devices over an insecure network, but part of the problem is knowing the identity of the device on the other end of that connection.</span></span> <span data-ttu-id="5589a-341">Sin un mecanismo para autenticar la identidad de los hosts remotos, un atacante podría hacerse pasar por un dispositivo de confianza sin el más mínimo esfuerzo.</span><span class="sxs-lookup"><span data-stu-id="5589a-341">Without a mechanism for authenticating the identity of remote hosts, it becomes a trivial operation for an attacker to pose as a trusted device.</span></span>

<span data-ttu-id="5589a-342">Inicialmente, puede parecer que el uso de direcciones IP, direcciones MAC de hardware o DNS, proporcionarán un nivel relativamente alto de confianza para identificar hosts en una red, pero dada la naturaleza de la tecnología TCP/IP, la facilidad con la que se pueden suplantar las direcciones y dañarse las entradas DNS (por ejemplo, a través de la infección de la caché DNS), queda claro que TLS necesita una capa adicional de protección.</span><span class="sxs-lookup"><span data-stu-id="5589a-342">Initially, it may seem that using IP addresses, hardware MAC addresses, or DNS would provide a relatively high level of confidence for identifying hosts on a network, but given the nature of TCP/IP technology and the ease with which addresses can be spoofed and DNS entries corrupted (e.g. through DNS cache poisoning), it becomes clear that TLS needs an additional layer of protection against fraudulent identities.</span></span>

<span data-ttu-id="5589a-343">Hay varios mecanismos que pueden proporcionar esta capa adicional de autenticación para TLS, pero el *certificado digital* es el más común.</span><span class="sxs-lookup"><span data-stu-id="5589a-343">There are various mechanisms that can provide this extra layer of authentication for TLS, but the most common is the *digital certificate.*</span></span> <span data-ttu-id="5589a-344">Otros mecanismos incluyen las claves precompartidas (PSK) y los esquemas de contraseña.</span><span class="sxs-lookup"><span data-stu-id="5589a-344">Other mechanisms include Pre-Shared Keys (PSK) and password schemes.</span></span>

### <a name="digital-cerificates"></a><span data-ttu-id="5589a-345">Certificados digitales</span><span class="sxs-lookup"><span data-stu-id="5589a-345">Digital Cerificates</span></span>

<span data-ttu-id="5589a-346">Los certificados digitales son el método más común para autenticar un host remoto en TLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-346">Digital certificates are the most common method for authenticating a remote host in TLS.</span></span> <span data-ttu-id="5589a-347">Esencialmente, un certificado digital es un documento con un formato específico que proporciona información de identidad para un dispositivo en una red de equipos.</span><span class="sxs-lookup"><span data-stu-id="5589a-347">Essentially, a digital certificate is a document with specific formatting that provides identity information for a device on a computer network.</span></span>

<span data-ttu-id="5589a-348">TLS normalmente usa un formato denominado X.509, un estándar desarrollado por la International Telecommunication Union, aunque se pueden usar otros formatos de certificados si los hosts de TLS acuerdan el formato usado.</span><span class="sxs-lookup"><span data-stu-id="5589a-348">TLS normally uses a format called X.509, a standard developed by the International Telecommunication Union, though other formats of certificates may be used if the TLS hosts can agree on the format being used.</span></span> <span data-ttu-id="5589a-349">X.509 define un formato específico para los certificados y diversas codificaciones que se pueden utilizar para generar un documento digital.</span><span class="sxs-lookup"><span data-stu-id="5589a-349">X.509 defines a specific format for certificates and various encodings that can be used to produce a digital document.</span></span> <span data-ttu-id="5589a-350">La mayoría de los certificados X.509 que se usan con TLS se codifican mediante una variante de ASN.1, otro estándar de telecomunicaciones.</span><span class="sxs-lookup"><span data-stu-id="5589a-350">Most X.509 certificates used with TLS are encoded using a variant of ASN.1, another telecommunications standard.</span></span> <span data-ttu-id="5589a-351">En ASN.1 hay varias codificaciones digitales, pero la codificación más común de los certificados TLS es el estándar de reglas de codificación distinguida (DER).</span><span class="sxs-lookup"><span data-stu-id="5589a-351">Within ASN.1 there are various digital encodings, but the most common encoding for TLS certificates is the Distinguished Encoding Rules (DER) standard.</span></span> <span data-ttu-id="5589a-352">DER es un subconjunto simplificado de las reglas de codificación básicas (BER) de ASN.1 que están diseñadas para ser inequívocas, lo que facilita el análisis.</span><span class="sxs-lookup"><span data-stu-id="5589a-352">DER is a simplified subset of the ASN.1 Basic Encoding Rules (BER) that is designed to be unambiguous, making parsing easier.</span></span> <span data-ttu-id="5589a-353">A través de la conexión, los certificados TLS normalmente están codificados en DER binario y este es el formato que NetX Secure espera para los certificados X.509.</span><span class="sxs-lookup"><span data-stu-id="5589a-353">Over the wire, TLS certificates are usually encoded in binary DER, and this is the format that NetX Secure expects for X.509 certificates.</span></span>

<span data-ttu-id="5589a-354">Aunque los certificados binarios con formato DER se usan en el protocolo TLS real, se pueden generar y almacenar en varias codificaciones diferentes, con extensiones de archivo como. pem, .crt y .p12.</span><span class="sxs-lookup"><span data-stu-id="5589a-354">Though DER-formatted binary certificates are used in the actual TLS protocol, they may be generated and stored in a number of different encodings, with file extensions such as .pem, .crt, and .p12.</span></span> <span data-ttu-id="5589a-355">Las distintas variantes las usan diferentes aplicaciones de distintos fabricantes, pero generalmente todas se pueden convertir en DER mediante herramientas ampliamente disponibles.</span><span class="sxs-lookup"><span data-stu-id="5589a-355">The different variants are used by different applications from different manufacturers, but generally all can be converted into DER using widely available tools.</span></span>

<span data-ttu-id="5589a-356">La más común de las codificaciones alternativas de certificados es PEM.</span><span class="sxs-lookup"><span data-stu-id="5589a-356">The most common of the alternative certificate encodings is PEM.</span></span> <span data-ttu-id="5589a-357">El formato PEM (Privacy-Enhanced Mail, correo con privacidad mejorada) es una versión codificada en base 64 de la codificación DER que se usa a menudo porque la codificación da como resultado texto imprimible que se puede enviar fácilmente mediante correo electrónico o protocolos basados en Web.</span><span class="sxs-lookup"><span data-stu-id="5589a-357">The PEM format (from Privacy-Enhanced Mail) is a base-64 encoded version of the DER encoding that is often used because the encoding results in printable text that can be easily sent using email or web-based protocols.</span></span>

<span data-ttu-id="5589a-358">La generación de un certificado para la aplicación de NetX Secure suele estar fuera del ámbito de este manual, pero la herramienta de línea de comandos de OpenSSL ([www.openssl.org](http://www.openssl.org)) está ampliamente disponible y puede realizar la conversión entre la mayoría de los formatos.</span><span class="sxs-lookup"><span data-stu-id="5589a-358">Generating a certificate for your NetX Secure application is generally outside the scope of this manual, but the OpenSSL command-line tool ([www.openssl.org](http://www.openssl.org)) is widely available and can convert between most formats.</span></span>

<span data-ttu-id="5589a-359">En función de la aplicación, puede generar sus propios certificados, proporcionar certificados por un fabricante o una organización gubernamental, o adquirir certificados de una entidad de certificación comercial.</span><span class="sxs-lookup"><span data-stu-id="5589a-359">Depending on your application, you may generate your own certificates, be provided certificates by a manufacturer or government organization, or purchase certificates from a commercial certificate authority.</span></span>

<span data-ttu-id="5589a-360">Para usar un certificado digital en la aplicación de NetX Secure, primero debe convertir el certificado a un formato binario DER y, opcionalmente, convertir la clave privada asociada (el “exponente privado” en RSA, por ejemplo) en formato binario, normalmente una clave RSA con formato PKCS#1 y con codificación DER.</span><span class="sxs-lookup"><span data-stu-id="5589a-360">To use a digital certificate in your NetX Secure application, you must first convert your certificate into a binary DER format and, optionally, convert the associated private key (the “private exponent” for RSA, for example) into a binary format, typically a PKCS#1-formatted, DER-encoded RSA key.</span></span> <span data-ttu-id="5589a-361">Una vez finalizada la conversión, depende de usted cargar el certificado y la clave privada en el dispositivo.</span><span class="sxs-lookup"><span data-stu-id="5589a-361">Once the conversion is complete, it is up to you to load the certificate and private key onto the device.</span></span> <span data-ttu-id="5589a-362">Entre las opciones posibles se incluyen el uso de un sistema de archivos basado en Flash o la generación de una matriz C a partir de los datos (mediante una herramienta como “XXD” desde Linux) y la compilación del certificado y la clave en la aplicación como datos constantes.</span><span class="sxs-lookup"><span data-stu-id="5589a-362">Possible options include using a flash-based file system or generating a C array from the data (using a tool such as “xxd” from Linux) and compiling the certificate and key into your application as constant data.</span></span>

<span data-ttu-id="5589a-363">Una vez que el certificado se carga en el dispositivo, se puede usar la API de DTLS para asociar el certificado a una sesión o un servidor DTLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-363">Once your certificate is loaded onto the device, the DTLS API can be used to associate your certificate with a DTLS session or server.</span></span>

<span data-ttu-id="5589a-364">Para obtener más información y ejemplos sobre cómo usar los certificados X.509 con el servicio DTLS de NetX Secure, consulte la sección “Importación de certificados X.509 en NetX Secure” en la guía de usuario del servicio TLS de NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="5589a-364">For details and examples on how to use X.509 certificates with NetX Secure DTLS, see the section “Importing X.509 certificates into NetX Secure” in the NetX Secure TLS User Guide.</span></span>

<span data-ttu-id="5589a-365">Consulte los siguientes servicios DTLS en la referencia de la API para obtener más información:</span><span class="sxs-lookup"><span data-stu-id="5589a-365">Refer to the following DTLS services in the API reference for more information:</span></span>

- <span data-ttu-id="5589a-366">nx_secure_x509_certificate_initialize,</span><span class="sxs-lookup"><span data-stu-id="5589a-366">nx_secure_x509_certificate_initialize,</span></span>
- <span data-ttu-id="5589a-367">nx_secure_dtls_session_local_certificate_add,</span><span class="sxs-lookup"><span data-stu-id="5589a-367">nx_secure_dtls_session_local_certificate_add,</span></span>
- <span data-ttu-id="5589a-368">nx_secure_dtls_server_local_certificate_add,</span><span class="sxs-lookup"><span data-stu-id="5589a-368">nx_secure_dtls_server_local_certificate_add,</span></span>
- <span data-ttu-id="5589a-369">nx_secure_dtls_session_local_certificate_remove,</span><span class="sxs-lookup"><span data-stu-id="5589a-369">nx_secure_dtls_session_local_certificate_remove,</span></span>
- <span data-ttu-id="5589a-370">nx_secure_dtls_server_local_certificate_remove,</span><span class="sxs-lookup"><span data-stu-id="5589a-370">nx_secure_dtls_server_local_certificate_remove,</span></span>
- <span data-ttu-id="5589a-371">nx_secure_dtls_session_trusted_certificate_add,</span><span class="sxs-lookup"><span data-stu-id="5589a-371">nx_secure_dtls_session_trusted_certificate_add,</span></span>
- <span data-ttu-id="5589a-372">nx_secure_dtls_server_trusted_certificate_add,</span><span class="sxs-lookup"><span data-stu-id="5589a-372">nx_secure_dtls_server_trusted_certificate_add,</span></span>
- <span data-ttu-id="5589a-373">nx_secure_dtls_session_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="5589a-373">nx_secure_dtls_session_trusted_certificate_remove</span></span>
- <span data-ttu-id="5589a-374">nx_secure_dtls_server_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="5589a-374">nx_secure_dtls_server_trusted_certificate_remove</span></span>

### <a name="tls-client-certificate-specifics"></a><span data-ttu-id="5589a-375">Detalles de certificados de cliente TLS</span><span class="sxs-lookup"><span data-stu-id="5589a-375">TLS Client Certificate Specifics</span></span>

<span data-ttu-id="5589a-376">Las implementaciones de cliente DTLS generalmente no requieren la carga de un certificado local en el dispositivo.</span><span class="sxs-lookup"><span data-stu-id="5589a-376">DTLS Client implementations generally do not require a local certificate to be loaded onto the device.</span></span> <span data-ttu-id="5589a-377">Un certificado local es un certificado que identifica el dispositivo local.</span><span class="sxs-lookup"><span data-stu-id="5589a-377">A local certificate is a certificate that identifies the local device.</span></span> <span data-ttu-id="5589a-378">En concreto, un certificado local proporciona información de identidad para el dispositivo en el que se carga la aplicación TLS/DTLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-378">Specifically, a local certificate provides identity information for the device upon which the TLS/DTLS application is loaded.</span></span> <span data-ttu-id="5589a-379">Hay una excepción: cuando está habilitada la autenticación de certificados de cliente, pero este supuesto es menos frecuente.</span><span class="sxs-lookup"><span data-stu-id="5589a-379">The exception to this is when Client Certificate Authentication is enabled, but this is less common.</span></span>

<span data-ttu-id="5589a-380">Un cliente DTLS requiere que se cargue al menos un certificado de confianza (es posible que se carguen más, si es necesario) y espacio para que se asigne un certificado remoto.</span><span class="sxs-lookup"><span data-stu-id="5589a-380">A DTLS Client requires at least one trusted certificate to be loaded (more may be loaded if required), and space for a remote certificate to be allocated.</span></span> <span data-ttu-id="5589a-381">Un certificado de confianza es un certificado que proporciona una base de confianza y autenticación del dispositivo remoto, ya sea directamente o a través de una infraestructura de clave pública (PKI).</span><span class="sxs-lookup"><span data-stu-id="5589a-381">A trusted certificate is a certificate that provides a basis for trust and authentication of the remote device, either directly or through a Public Key Infrastructure (PKI).</span></span> <span data-ttu-id="5589a-382">La raíz de la cadena de confianza se denomina normalmente entidad de certificación o certificado de CA.</span><span class="sxs-lookup"><span data-stu-id="5589a-382">The root of the chain of trust is usually called a Certification Authority or CA certificate.</span></span> <span data-ttu-id="5589a-383">Un certificado remoto hace referencia al certificado enviado por el host remoto durante el protocolo de enlace TLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-383">A remote certificate refers to the certificate sent by the remote host during the TLS handshake.</span></span> <span data-ttu-id="5589a-384">Proporciona identidad para ese host remoto y se autentica mediante su comparación con un certificado de confianza en el dispositivo local.</span><span class="sxs-lookup"><span data-stu-id="5589a-384">It provides identity for that remote host and is authenticated by comparing it to a trusted certificate on the local device.</span></span>

<span data-ttu-id="5589a-385">Para obtener más información sobre cómo agregar certificados de confianza y asignar espacio para los certificados remotos, consulte la referencia de la API de TLS para los siguientes servicios: nx_secure_dtls_session_create, nx_secure_dtls_session_trusted_certificate_add.</span><span class="sxs-lookup"><span data-stu-id="5589a-385">For more information on adding trusted certificates and allocating space for remote certificates, see the TLS API reference for the following services: nx_secure_dtls_session_create, nx_secure_dtls_session_trusted_certificate_add.</span></span>

### <a name="tlsdtls-server-certificate-specifics"></a><span data-ttu-id="5589a-386">Detalles de certificados de servidor TLS/DTLS</span><span class="sxs-lookup"><span data-stu-id="5589a-386">TLS/DTLS Server Certificate Specifics</span></span>

<span data-ttu-id="5589a-387">Por lo general, las implementaciones de servidor DTLS no requieren la carga de certificados de “confianza” en el dispositivo o los certificados remotos que se van a asignar.</span><span class="sxs-lookup"><span data-stu-id="5589a-387">DTLS Server implementations generally do not require “trusted” certificates to be loaded onto the device or remote certificates to be allocated.</span></span> <span data-ttu-id="5589a-388">Hay una excepción: cuando está habilitada la autenticación de certificados de cliente.</span><span class="sxs-lookup"><span data-stu-id="5589a-388">The exception to this being when Client Certificate Authentication is enabled.</span></span>

<span data-ttu-id="5589a-389">Un servidor TLS requiere la carga de un certificado “local” (o “identidad”) para que el servidor pueda proporcionarlo al cliente remoto durante el protocolo de enlace TLS para autenticar el servidor en el cliente.</span><span class="sxs-lookup"><span data-stu-id="5589a-389">A TLS Server requires a “local” (or “identity”) certificate to be loaded so the server can provide it to the remote client during the TLS handshake to authenticate the server to the client.</span></span>

<span data-ttu-id="5589a-390">Para obtener más información sobre la carga de certificados locales para su uso con aplicaciones de servidor TLS de NetX, consulte la referencia de la API para los siguientes servicios: nx_secure_dtls_server_local_certificate_add, nx_secure_dtls_server_local_certificate_remove.</span><span class="sxs-lookup"><span data-stu-id="5589a-390">For more information about loading local certificates for use with NetX TLS server applications, see the API reference for the following services: nx_secure_dtls_server_local_certificate_add, nx_secure_dtls_server_local_certificate_remove.</span></span>


### <a name="pre-shared-keys-psk"></a><span data-ttu-id="5589a-391">Claves precompartidas (PSK)</span><span class="sxs-lookup"><span data-stu-id="5589a-391">Pre-Shared Keys (PSK)</span></span>

<span data-ttu-id="5589a-392">Un mecanismo alternativo para proporcionar autenticación de identificación en TLS es la noción de claves precompartidas (PSK).</span><span class="sxs-lookup"><span data-stu-id="5589a-392">An alternative mechanism for providing identification authentication in TLS is the notion of Pre-Shared Keys (PSK).</span></span> <span data-ttu-id="5589a-393">Usar un conjunto de cifrado PSK elimina la necesidad de realizar las operaciones de cifrado de clave pública de uso intensivo del procesador, una ventaja para los dispositivos integrados con restricción de recursos.</span><span class="sxs-lookup"><span data-stu-id="5589a-393">Using a PSK ciphersuite removes the need to do the processor-intensive public-key encryption operations, a boon for resource-constrained embedded devices.</span></span> <span data-ttu-id="5589a-394">La PSK reemplaza el certificado en el protocolo de enlace TLS/DTLS y se usa en lugar del secreto premaestro cifrado para la generación de claves de sesión TLS/DTLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-394">The PSK replaces the certificate in the TLS/DTLS handshake and is used in place of the encrypted Pre-Master Secret for TLS/DTLS session key generation.</span></span>

<span data-ttu-id="5589a-395">Las conjuntos de PSK están limitados en el sentido de que un secreto compartido debe estar presente en ambos dispositivos antes de que se pueda establecer una sesión de TLS/DTLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-395">The PSK ciphersuites are limited in the sense that that a shared secret must be present on both devices before a TLS/DTLS session can be established.</span></span> <span data-ttu-id="5589a-396">Esto significa que los dispositivos se deben haber cargado con ese secreto mediante el uso de algunos medios seguros distintos, no solo mediante una conexión TLS con PSK. La PSK se puede actualizar a través de una conexión de TLS con PSK, pero el dispositivo debe comenzar con una PSK que se carga a través de otro mecanismo.</span><span class="sxs-lookup"><span data-stu-id="5589a-396">This means that the devices must have been loaded with that secret using some secure means other than a TLS PSK connection - PSKs may be updated over a TLS PSK connection, but the device must necessarily start with a PSK that is loaded through some other mechanism.</span></span> <span data-ttu-id="5589a-397">Por ejemplo, se podría cargar un dispositivo de sensor y su dispositivo de puerta de enlace con PSK en la fábrica antes del envío, o bien se podría usar una conexión TLS estándar (con un certificado) para cargar la PSK.</span><span class="sxs-lookup"><span data-stu-id="5589a-397">For example, a sensor device and its gateway device could be loaded with PSKs in the factory before shipping, or a standard TLS connection (with a certificate) could be used to load the PSK.</span></span>

<span data-ttu-id="5589a-398">Los conjuntos de cifrado PSK se presentan en un par de formatos, que se describe en la RFC 4279.</span><span class="sxs-lookup"><span data-stu-id="5589a-398">PSK ciphersuites come in a couple of forms, described in RFC 4279.</span></span> <span data-ttu-id="5589a-399">El primero usa las claves RSA o Diffie-Hellman que se usan de la misma manera que las claves públicas transmitidas en el certificado en los protocolos de enlace TLS estándar.</span><span class="sxs-lookup"><span data-stu-id="5589a-399">The first uses RSA or Diffie-Hellman keys which are used in the same manner as the public keys transmitted in the certificate in standard TLS handshakes.</span></span> <span data-ttu-id="5589a-400">El segundo, que se usa más en un entorno con restricción de recursos, utiliza una PSK que se utiliza para generar directamente las claves de sesión (para su uso con AES, por ejemplo), evitando así las costosas operaciones de Diffie-Hellman o RSA.</span><span class="sxs-lookup"><span data-stu-id="5589a-400">The second form, which is of more use in a resource-constrained environment, uses a PSK that is used to directly generate the session keys (for use by AES, for example), avoiding the use of the expensive RSA or Diffie-Hellman operations.</span></span>

<span data-ttu-id="5589a-401">NetX Secure admite el segundo formato de conjuntos de cifrado PSK, lo que permite que las aplicaciones quiten todo el código de criptografía de clave pública y el uso de memoria.</span><span class="sxs-lookup"><span data-stu-id="5589a-401">NetX Secure supports the second form of PSK ciphersuites, enabling applications to remove all public-key cryptography code and memory usage.</span></span> <span data-ttu-id="5589a-402">La PSK no es una clave AES, pero se puede considerar como una contraseña de la que se generan las claves reales.</span><span class="sxs-lookup"><span data-stu-id="5589a-402">The PSK itself is not an AES key, but can be considered as being more like a password from which the actual keys are generated.</span></span> <span data-ttu-id="5589a-403">Existen algunas restricciones en lo que puede ser el valor de PSK, aunque los valores más largos proporcionarán más seguridad (igual que con las contraseñas).</span><span class="sxs-lookup"><span data-stu-id="5589a-403">There are few restrictions on what the PSK value can be, though longer values will provide more security (same as with passwords).</span></span>

<span data-ttu-id="5589a-404">Para usar PSK con la aplicación de NetX Secure, primero debe definir la macro global **NX_SECURE_ENABLE_PSK_CIPHERSUITES**.</span><span class="sxs-lookup"><span data-stu-id="5589a-404">To use PSK with your NetX Secure application, you must first define the global macro **NX_SECURE_ENABLE_PSK_CIPHERSUITES**.</span></span> <span data-ttu-id="5589a-405">Normalmente esto se realiza a través de la configuración del compilador, pero la definición también se puede colocar en el archivo de encabezado nx_secure_tls.h.</span><span class="sxs-lookup"><span data-stu-id="5589a-405">This is usually done through your compiler settings, but the definition can also be placed in the nx_secure_tls.h header file.</span></span> <span data-ttu-id="5589a-406">Con la macro definida, la compatibilidad del conjunto de cifrado PSK se compilará en la aplicación DTLS de NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="5589a-406">With the macro defined, PSK ciphersuite support will be compiled into your NetX Secure DTLS application.</span></span>

<span data-ttu-id="5589a-407">Con la compatibilidad con PSK habilitada, puede usar la API de DTLS para configurar PSK para la aplicación.</span><span class="sxs-lookup"><span data-stu-id="5589a-407">With PSK support enabled, you can then use the DTLS API to set up PSKs for your application.</span></span> <span data-ttu-id="5589a-408">Cada PSK requerirá un valor de PSK (la “clave” secreta real que debe mantener a salvo), un valor de “identidad” que se usa para identificar la PSK específica y una “sugerencia de identidad” que se usa en un servidor TLS para elegir un valor de PSK determinado.</span><span class="sxs-lookup"><span data-stu-id="5589a-408">Each PSK will require a PSK value (the actual secret “key” – keep this value safe), an “identity” value used to identify the specific PSK, and an “identity hint” that is used by a TLS server to choose a particular PSK value.</span></span>

<span data-ttu-id="5589a-409">La PSK puede ser cualquier valor binario, ya que nunca se envía a través de una conexión de red.</span><span class="sxs-lookup"><span data-stu-id="5589a-409">The PSK itself can be any binary value as it is never sent over a network connection.</span></span> <span data-ttu-id="5589a-410">La PSK puede tener cualquier valor de hasta 64 bytes de longitud.</span><span class="sxs-lookup"><span data-stu-id="5589a-410">The PSK can be any value up to 64 bytes in length.</span></span>

<span data-ttu-id="5589a-411">La identidad y la sugerencia deben ser cadenas de caracteres imprimibles con formato UTF-8.</span><span class="sxs-lookup"><span data-stu-id="5589a-411">The identity and hint must be printable character strings formatted using UTF-8.</span></span> <span data-ttu-id="5589a-412">Los valores de identidad y sugerencia pueden tener una longitud de hasta 128 bytes.</span><span class="sxs-lookup"><span data-stu-id="5589a-412">The identity and hint values may be any length up to 128 bytes.</span></span>

<span data-ttu-id="5589a-413">La identidad y la PSK forman un par único que se carga en todos los dispositivos de la red que necesitan comunicarse entre sí.</span><span class="sxs-lookup"><span data-stu-id="5589a-413">The identity and PSK form a unique pair that is loaded onto every device in the network that need to communicate with one another.</span></span>

<span data-ttu-id="5589a-414">La “sugerencia” se usa principalmente para definir perfiles de aplicación específicos para agrupar PSK por función o servicio.</span><span class="sxs-lookup"><span data-stu-id="5589a-414">The “hint” is primarily used for defining specific application profiles to group PSKs by function or service.</span></span> <span data-ttu-id="5589a-415">Estos valores se deben acordar de antemano y dependen de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="5589a-415">These values must be agreed upon in advance and are application dependent.</span></span> <span data-ttu-id="5589a-416">Por ejemplo, la aplicación de servidor de línea de comandos de OpenSSL (con PSK habilitado) utiliza la cadena predeterminada “Client_identity” que debe proporcionar un cliente TLS para continuar con el protocolo de enlace TLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-416">As an example, the OpenSSL command-line server application (with PSK enabled) uses the default string “Client_identity”, which must be provided by a TLS client in order to continue with the TLS handshake.</span></span>

<span data-ttu-id="5589a-417">Para obtener más información sobre las PSK, consulte la referencia de la API de NetX Secure para los siguientes servicios: nx_secure_dtls_psk_add, nx_secure_dtls_server_psk_add.</span><span class="sxs-lookup"><span data-stu-id="5589a-417">For more information on PSKs, see the NetX Secure API reference for the following services: nx_secure_dtls_psk_add, nx_secure_dtls_server_psk_add.</span></span>

## <a name="importing-x509-certificates-into-netx-secure"></a><span data-ttu-id="5589a-418">Importación de certificados X.509 en NetX Secure</span><span class="sxs-lookup"><span data-stu-id="5589a-418">Importing X.509 certificates into NetX Secure</span></span>

<span data-ttu-id="5589a-419">Los certificados digitales son necesarios para la mayoría de las conexiones TLS en Internet.</span><span class="sxs-lookup"><span data-stu-id="5589a-419">Digital certificates are required for most TLS connections on the Internet.</span></span> <span data-ttu-id="5589a-420">Los certificados proporcionan un método para autenticar hosts desconocidos previamente a través de Internet mediante el uso de intermediarios de confianza, normalmente denominados *entidades de certificación* o CA.</span><span class="sxs-lookup"><span data-stu-id="5589a-420">Certificates provide a method for authenticating previously unknown hosts over the Internet through the use of trusted intermediaries, usually called *Certificate Authorities* or CAs.</span></span> <span data-ttu-id="5589a-421">Para conectar el dispositivo NetX Seguro con un servicio en la nube comercial (por ejemplo, Amazon Web Services), deberá importar los certificados en la aplicación si los carga en el dispositivo.</span><span class="sxs-lookup"><span data-stu-id="5589a-421">To connect your NetX Secure device with a commercial cloud service (such as Amazon Web Services), you will need to import certificates into your application by loading them onto your device.</span></span>

<span data-ttu-id="5589a-422">Además de los certificados, también necesitará una *clave privada* que esté asociada con el certificado.</span><span class="sxs-lookup"><span data-stu-id="5589a-422">Along with certificates, you will also sometimes need a *private key* that is associated with your certificate.</span></span> <span data-ttu-id="5589a-423">En algunas aplicaciones (como el cliente TLS cuando no se utiliza la autenticación de certificados de cliente), bastará con el certificado, pero si el certificado se usa para identificar el dispositivo, necesitará una clave privada.</span><span class="sxs-lookup"><span data-stu-id="5589a-423">In some applications (such as TLS Client when Client Certificate Authentication is not being used) the certificate alone will be sufficient, but if your certificate is being used to identify your device you will need a private key.</span></span> <span data-ttu-id="5589a-424">Las claves privadas normalmente se generan al crear el certificado y se almacenan en un archivo independiente (que a menudo cifrado con una contraseña).</span><span class="sxs-lookup"><span data-stu-id="5589a-424">Private keys are typically generated when you create your certificate and are stored in a separate file, often encrypted with a password.</span></span>

<span data-ttu-id="5589a-425">Para obtener una descripción detallada de la importación de certificados a aplicaciones de NetX Secure, consulte el capítulo 3 de la guía de usuario del servicio TLS de NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="5589a-425">For a detailed description of importing certificates into NetX Secure applications, please refer to Chapter 3 in the NetX Secure TLS User Guide.</span></span>

## <a name="client-certificate-authentication-in-netx-secure-tls"></a><span data-ttu-id="5589a-426">Autenticación de certificados de cliente en el servicio TLS de NetX Secure</span><span class="sxs-lookup"><span data-stu-id="5589a-426">Client Certificate Authentication in NetX Secure TLS</span></span>

<span data-ttu-id="5589a-427">Al usar la autenticación de certificados X.509, el protocolo TLS/DTLS requiere que la instancia del servidor DTLS proporcione un certificado para la identificación. Sin embargo, de forma predeterminada, la instancia de cliente DTLS no tiene que proporcionar un certificado para la autenticación y puede usar otra forma de autenticación (por ejemplo, una combinación de nombre de usuario/contraseña).</span><span class="sxs-lookup"><span data-stu-id="5589a-427">When using X.509 certificate authentication, the TLS/DTLS protocol requires that the DTLS Server instance provide a certificate for identification, but by default the DTLS Client instance does not need to provide a certificate for authentication, using another form of authentication instead (e.g. a username/password combination).</span></span> <span data-ttu-id="5589a-428">Esto coincide con el uso más común de TLS para sitios Web en Internet.</span><span class="sxs-lookup"><span data-stu-id="5589a-428">This matches the most common use of TLS on the Internet for Web sites.</span></span> <span data-ttu-id="5589a-429">Por ejemplo, un sitio de venta directa en línea debe demostrar a un cliente potencial que use un explorador Web que el servidor es legítimo, pero el usuario empleará un inicio de sesión y una contraseña para tener acceso a una cuenta específica.</span><span class="sxs-lookup"><span data-stu-id="5589a-429">For example, an online retail site must prove to a potential customer using a web browser that the server is legitimate, but the user will use a login/password to access a specific account.</span></span>

<span data-ttu-id="5589a-430">Sin embargo, el caso predeterminado no siempre es el aconsejable, por lo que TLS/DTLS permite a la instancia del servidor DTLS solicitar un certificado del cliente remoto.</span><span class="sxs-lookup"><span data-stu-id="5589a-430">However, the default case is not always desirable, so TLS/DTLS optionally allows for the DTLS Server instance to request a certificate from the remote Client.</span></span> <span data-ttu-id="5589a-431">Cuando esta característica está habilitada, el servidor DTLS enviará un mensaje CertificateRequest al cliente DTLS durante el protocolo de enlace.</span><span class="sxs-lookup"><span data-stu-id="5589a-431">When this feature is enabled, the DTLS Server will send a CertificateRequest message to the DTLS Client during the handshake.</span></span> <span data-ttu-id="5589a-432">El cliente debe responder con un certificado propio y un mensaje CertificateVerify que contenga un token criptográfico que demuestre que el cliente posee la clave privada correspondiente asociada a ese certificado.</span><span class="sxs-lookup"><span data-stu-id="5589a-432">The Client must respond with a certificate of its own and a CertificateVerify message which contains a cryptographic token proving that the Client owns the matching private key associated with that certificate.</span></span> <span data-ttu-id="5589a-433">Si se produce un error en la comprobación o el certificado no está conectado a un certificado de confianza en el servidor, se produce un error en el protocolo de enlace TLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-433">If the verification fails or the certificate is not connected to a trusted certificate on the Server, the TLS handshake fails.</span></span>

<span data-ttu-id="5589a-434">Hay dos casos independientes para la autenticación de certificados de cliente en TLS: en las secciones siguientes se tratan ambos casos.</span><span class="sxs-lookup"><span data-stu-id="5589a-434">There are two separate cases for Client Certificate Authentication in TLS – the following sections cover both cases.</span></span>

### <a name="client-certificate-authentication-for-dtls-clients"></a><span data-ttu-id="5589a-435">Autenticación de certificados de cliente para clientes DTLS</span><span class="sxs-lookup"><span data-stu-id="5589a-435">Client Certificate Authentication for DTLS Clients</span></span>

<span data-ttu-id="5589a-436">Un cliente DTLS puede intentar una conexión a un servidor que solicite un certificado para la autenticación del cliente.</span><span class="sxs-lookup"><span data-stu-id="5589a-436">A DTLS Client may attempt a connection to a server that requests a certificate for client authentication.</span></span> <span data-ttu-id="5589a-437">En este caso, el cliente debe proporcionar un certificado al servidor y comprobar que posee la clave privada correspondiente; si no, el servidor finalizará el protocolo de enlace DTLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-437">In this case the Client must provide a certificate to the server and verify that it owns the matching private key or the Server will terminate the DTLS handshake.</span></span>

<span data-ttu-id="5589a-438">En el servicio DTLS de NetX Secure, no hay ninguna configuración especial para admitir esta característica, pero la aplicación tendrá que proporcionar un certificado de identificación local para la instancia de cliente TLS mediante el servicio *nx_secure_tls_session_local_certificate_add*.</span><span class="sxs-lookup"><span data-stu-id="5589a-438">In NetX Secure DTLS, there is no special configuration to support this feature but the application will have to provide a local identification certificate for the TLS Client instance using the *nx_secure_tls_session_local_certificate_add* service.</span></span> <span data-ttu-id="5589a-439">Si la aplicación no proporciona ningún certificado pero el servidor remoto usa la autenticación de certificado de cliente y solicita un certificado, se producirá un error en el protocolo de enlace DTLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-439">If no certificate is provided by the application but the remote server is using Client Certificate Authentication and requests a certificate, the DTLS handshake will fail.</span></span> <span data-ttu-id="5589a-440">El servidor remoto debe reconocer el certificado proporcionado a la sesión DTLS con *nx_secure_dtls_session_local_certificate_add* para poder completar el protocolo de enlace DTLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-440">The certificate provided to the DTLS Session with *nx_secure_dtls_session_local_certificate_add* must be recognized by the remote server in order to complete the DTLS handshake.</span></span>

### <a name="client-certificate-authentication-for-tls-servers"></a><span data-ttu-id="5589a-441">Autenticación de certificados de cliente para servidores DTLS</span><span class="sxs-lookup"><span data-stu-id="5589a-441">Client Certificate Authentication for TLS Servers</span></span>

<span data-ttu-id="5589a-442">El caso del servidor DTLS para la autenticación de certificados de cliente es ligeramente más complejo que el caso del cliente DTLS, ya que la característica es opcional.</span><span class="sxs-lookup"><span data-stu-id="5589a-442">The DTLS Server case for Client Certificate Authentication is slightly more complex than the DTLS Client case due to the feature being optional.</span></span> <span data-ttu-id="5589a-443">En este caso, el servidor TLS necesita solicitar específicamente un certificado de cliente TLS remoto y, seguidamente, procesar el mensaje CertificateVerify para comprobar que el cliente remoto es el propietario de la clave privada correspondiente. A continuación, el servidor debe comprobar que se puede realizar un seguimiento del certificado proporcionado por el cliente hasta un certificado del almacén local de certificados de confianza.</span><span class="sxs-lookup"><span data-stu-id="5589a-443">In this case, the TLS Server needs to specifically request a certificate from the remote TLS Client, then process the CertificateVerify message to verify that the remote Client owns the matching private key, and then the Server must check that the certificate provided by the Client can be traced to a certificate in the local trusted certificate store.</span></span>

<span data-ttu-id="5589a-444">En las instancias del servidor TLS seguras, la autenticación de certificados de cliente se controla mediante los servicios *nx_secure_dtls_server_x509_client_verify_configure* y *nx_secure_dtls_server_x509_client_verify_disable*.</span><span class="sxs-lookup"><span data-stu-id="5589a-444">In NetX Secure TLS Server instances, Client Certificate Authentication is controlled by the *nx_secure_dtls_server_x509_client_verify_configure* and *nx_secure_dtls_server_x509_client_verify_disable* services.</span></span>

<span data-ttu-id="5589a-445">Para habilitar la autenticación de certificados de cliente, una aplicación debe llamar a *nx_secure_dtls_server_x509_client_verify_configure* con la instancia de sesión de servidor DTLS antes de llamar a *nx_secure_dtls_server_start*.</span><span class="sxs-lookup"><span data-stu-id="5589a-445">To enable Client Certificate Authentication, an application must call *nx_secure_dtls_server_x509_client_verify_configure* with the DTLS Server session instance before calling *nx_secure_dtls_server_start*.</span></span> <span data-ttu-id="5589a-446">La comprobación requiere que se asigne espacio para los certificados de cliente entrantes que se proporciona como parámetro para *nx_secure_dtls_server_x509_client_verify_configure.*</span><span class="sxs-lookup"><span data-stu-id="5589a-446">The verification requires space to be allocated for incoming client certificates which is provided as a parameter to *nx_secure_dtls_server_x509_client_verify_configure.*</span></span> <span data-ttu-id="5589a-447">Tenga en cuenta que el búfer debe ser lo suficientemente grande para contener la cadena de certificados de tamaño máximo proporcionada por un cliente *veces el número de sesiones del servidor de DTLS*.</span><span class="sxs-lookup"><span data-stu-id="5589a-447">Note that the buffer must be large enough to hold the maximum-size certificate chain provided by a client *times the number of DTLS server sessions*.</span></span> <span data-ttu-id="5589a-448">Cada sesión de servidor requiere espacio que se asignará desde el búfer proporcionado único.</span><span class="sxs-lookup"><span data-stu-id="5589a-448">Each server session requires space which will be allocated from the single provided buffer.</span></span> <span data-ttu-id="5589a-449">Asegúrese de que el búfer es suficientemente grande o se producirá un error si la cadena de certificados de cliente proporcionada es demasiado grande.</span><span class="sxs-lookup"><span data-stu-id="5589a-449">Make sure the buffer is large enough or an error will occur if the provided Client certificate chain is too large.</span></span>

<span data-ttu-id="5589a-450">Cuando se habilita la autenticación de certificados de cliente, el servidor DTLS solicitará un certificado de cliente DTLS remoto durante el protocolo de enlace DTLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-450">When Client Certificate Authentication is enabled, the DTLS Server will request a certificate from the remote DTLS Client during the DTLS handshake.</span></span> <span data-ttu-id="5589a-451">En el servidor DTLS de NetX Secure, el certificado de cliente se compara con el almacén de certificados de confianza creados con *nx_secure_dtls_server_trusted_certificate_add* siguiendo la cadena de emisor X.509.</span><span class="sxs-lookup"><span data-stu-id="5589a-451">In NetX Secure DTLS Server, the Client certificate is checked against the store of trusted certificates created with *nx_secure_dtls_server_trusted_certificate_add* by following the X.509 issuer chain.</span></span> <span data-ttu-id="5589a-452">El cliente remoto debe proporcionar una cadena que conecte su certificado de identidad con un certificado en el almacén de confianza; de lo contrario, se producirá un error en el protocolo de enlace DTLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-452">The remote Client must provide a chain that connects its identity certificate to a certificate in the trusted store or the DTLS handshake will fail.</span></span> <span data-ttu-id="5589a-453">Además, si se produce un error en el procesamiento del mensaje CertificateVerify, también se producirá un error en el protocolo de enlace DTLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-453">Additionally, if the CertificateVerify message processing fails, the DTLS handshake will also fail.</span></span>

<span data-ttu-id="5589a-454">Los métodos de firma que se usan para el método CertificateVerify son fijos para la versión de TLS 1.0 y la versión TLS 1.1; se especifican mediante el servidor TLS en la versión TLS 1.2, en el que se basa el servicio DTLS de NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="5589a-454">The signature methods used for the CertificateVerify method are fixed for TLS version 1.0 and TLS version 1.1, and are specified by the TLS Server in TLS version 1.2, upon which NetX Secure DTLS is based.</span></span> <span data-ttu-id="5589a-455">En el caso de DTLS 1.2, los métodos de firma admitidos generalmente siguen los métodos pertinentes suministrados en la tabla de métodos criptográficos, pero normalmente RSA con SHA-256 (consulte la sección “Criptografía el servicio TLS de NetX Secure” para obtener más información sobre cómo inicializar TLS con métodos criptográficos).</span><span class="sxs-lookup"><span data-stu-id="5589a-455">For DTLS 1.2, the signature methods supported generally follow the relevant methods supplied in the cryptographic method table, but typically RSA with SHA-256 (see the section “Cryptography in NetX Secure TLS” for more information on initializing TLS with cryptographic methods).</span></span>

## <a name="cryptography-in-netx-secure-tls"></a><span data-ttu-id="5589a-456">Criptografía en el servicio TLS de NetX Secure</span><span class="sxs-lookup"><span data-stu-id="5589a-456">Cryptography in NetX Secure TLS</span></span>

<span data-ttu-id="5589a-457">TLS define un protocolo en el que se puede usar la criptografía para proteger las comunicaciones de red.</span><span class="sxs-lookup"><span data-stu-id="5589a-457">TLS defines a protocol in which cryptography can be used to secure network communications.</span></span> <span data-ttu-id="5589a-458">Como tal, permite que los usuarios de TLS puedan usar el cifrado real de forma bastante amplia.</span><span class="sxs-lookup"><span data-stu-id="5589a-458">As such, it leaves the actual cryptography to be used fairly wide open for TLS users.</span></span> <span data-ttu-id="5589a-459">La especificación solo requiere la implementación de un único conjunto de cifrado. En el caso de TLS 1.2, el conjunto es TLS_RSA_WITH_AES_128_CBC_SHA, que indica el uso de RSA para las operaciones de clave pública, AES en modo CBC con claves de 128 bits para el cifrado de sesión y SHA-1 para los hash de autenticación de mensajes.</span><span class="sxs-lookup"><span data-stu-id="5589a-459">The specification only requires a single ciphersuite to be implemented – in the case of TLS 1.2, that ciphersuite is TLS_RSA_WITH_AES_128_CBC_SHA, indicating the use of RSA for public-key operations, AES in CBC mode with 128-bit keys for session encryption, and SHA-1 for message authentication hashes.</span></span>

<span data-ttu-id="5589a-460">Al ser compatible con TLS 1.2, NetX Secure habilita el conjunto de cifrado obligatorio TLS_RSA_WITH_AES_128_CBC_SHA de forma predeterminada, pero dado el número de implementaciones posibles para cada uno de los métodos criptográficos debido a las capacidades de hardware y otras consideraciones, NetX Secure proporciona una API criptográfica genérica que permite a los usuarios especificar qué métodos criptográficos usar con TLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-460">Being TLS 1.2-compliant, NetX Secure enables the mandatory TLS_RSA_WITH_AES_128_CBC_SHA ciphersuite by default, but given the number of possible implementations for each of the cryptographic methods due to hardware capabilities and other considerations, NetX Secure provides a generic cryptographic API that allows a user to specify which cryptographic methods to use with TLS.</span></span>

> [!NOTE]
> <span data-ttu-id="5589a-461">El mecanismo genérico de la API criptográfica también permite a los usuarios implementar sus propios conjuntos, pero esto solo se recomienda a los usuarios avanzados que están familiarizados con las extensiones y conjuntos de cifrado de TLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-461">The generic cryptographic API mechanism also allows users to implement their own ciphersuites, but this is recommended for advanced users who are familiar with the TLS ciphersuites and extensions.</span></span> <span data-ttu-id="5589a-462">Póngase en contacto con su representante de Logic Express si está interesado en usar sus propios conjuntos de cifrado.</span><span class="sxs-lookup"><span data-stu-id="5589a-462">Please contact your Express Logic representative if you are interested in supporting your own ciphersuites.</span></span>

<span data-ttu-id="5589a-463">Consulte el capítulo 3 de la guía de usuario del servicio TLS de NetX Secure para ver una explicación detallada sobre cómo configurar los métodos criptográficos para DTLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-463">Please see the NetX Secure TLS User Guide, Chapter 3 for a detailed discussion about how to configure cryptographic methods for DTLS.</span></span> <span data-ttu-id="5589a-464">El mismo proceso se aplica tanto a TLS como a DTLS.</span><span class="sxs-lookup"><span data-stu-id="5589a-464">The same process applies to both TLS and DTLS.</span></span>
