---
title: 'Capítulo 3: Descripción funcional de Azure RTOS NetX Secure'
description: Este capítulo contiene una descripción funcional del servicio TLS de NetX Secure.
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: c28ad0255f99986a4ddfe5faefad81e70840e5e0
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 03/22/2021
ms.locfileid: "104814510"
---
# <a name="chapter-3---functional-description-of-azure-rtos-netx-secure"></a><span data-ttu-id="a894b-103">Capítulo 3: Descripción funcional de Azure RTOS NetX Secure</span><span class="sxs-lookup"><span data-stu-id="a894b-103">Chapter 3 - Functional description of Azure RTOS NetX Secure</span></span>

## <a name="execution-overview"></a><span data-ttu-id="a894b-104">Información general sobre la ejecución</span><span class="sxs-lookup"><span data-stu-id="a894b-104">Execution Overview</span></span>

<span data-ttu-id="a894b-105">Este capítulo contiene una descripción funcional del servicio TLS de Azure RTOS NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="a894b-105">This chapter contains a functional description of Azure RTOS NetX Secure TLS.</span></span> <span data-ttu-id="a894b-106">Hay dos tipos principales de ejecución de programa en una aplicación TLS de NetX Secure: inicialización y llamadas a la interfaz de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="a894b-106">There are two primary types of program execution in a NetX Secure TLS application: initialization and application interface calls.</span></span> 

<span data-ttu-id="a894b-107">*NetX Secure presupone la existencia de ThreadX y NetX/NetXDuo. En ThreadX, se requiere la ejecución de subprocesos, la suspensión, temporizadores periódicos y las instalaciones de exclusión mutua. En NetX/NetXDuo, se necesitan los controladores y los dispositivos de red TCP/IP.*</span><span class="sxs-lookup"><span data-stu-id="a894b-107">*NetX Secure assumes the existence of ThreadX and NetX/NetXDuo. From ThreadX, it requires thread execution, suspension, periodic timers, and mutual exclusion facilities. From NetX/NetXDuo it requires the TCP/IP networking facilities and drivers.*</span></span>

## <a name="transport-layer-security-tls-and-secure-sockets-layer-ssl"></a><span data-ttu-id="a894b-108">Seguridad de la capa de transporte (TLS) y Capa de sockets seguros (SSL)</span><span class="sxs-lookup"><span data-stu-id="a894b-108">Transport Layer Security (TLS) and Secure Sockets Layer (SSL)</span></span>

<span data-ttu-id="a894b-109">El componente de protocolo de red seguro de NetX Secure es una implementación del protocolo de seguridad de la capa de transporte (TLS), tal como se describe en la RFC 2246 (versión 1.0), 4346 (versión 1.1), 5246 (versión 1.2) y 8446 (versión 1.3).</span><span class="sxs-lookup"><span data-stu-id="a894b-109">The secure network protocol component of NetX secure is an implementation of the Transport Layer Security (TLS) protocol as described in RFCs 2246 (version 1.0), 4346 (version 1.1), 5246 (version 1.2) and 8446 (version 1.3).</span></span> <span data-ttu-id="a894b-110">También se incluyen rutinas de soporte técnico para X.509 básico (RFC 5280).</span><span class="sxs-lookup"><span data-stu-id="a894b-110">Also included are support routines for basic X.509 (RFC 5280).</span></span>

<span data-ttu-id="a894b-111">El servicio TLS de NetX Secure es compatible con las versiones TLS 1.2 y 1.3.</span><span class="sxs-lookup"><span data-stu-id="a894b-111">NetX Secure TLS supports TLS versions 1.2 and 1.3.</span></span> <span data-ttu-id="a894b-112">Se proporcionan implementaciones para TLS 1.0 y TLS 1.1 en desuso, pero se deben inicializar explícitamente y no se recomienda su uso en nuevos productos.</span><span class="sxs-lookup"><span data-stu-id="a894b-112">Implementations are provided for the now-deprecated TLS 1.0 and TLS 1.1, but they must be explicitly initialized and are not recommended for use in new products.</span></span>

<span data-ttu-id="a894b-113">*Capa de sockets seguros* (SSL) era el nombre original de TLS antes de que se convirtiera en un estándar en la RFC 2246 y “SSL” se utiliza a menudo como nombre genérico para los protocolos TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-113">*Secure Sockets Layer* (SSL) was the original name of TLS before it became a standard in RFC 2246 and "SSL" is often used as a generic name for the TLS protocols.</span></span> <span data-ttu-id="a894b-114">La última versión de SSL era 3.0 y TLS 1.0 a veces se denomina SSL 3.1.</span><span class="sxs-lookup"><span data-stu-id="a894b-114">The last version of SSL was 3.0, and TLS 1.0 is sometimes referred to as SSL version 3.1.</span></span> <span data-ttu-id="a894b-115">Todas las versiones del protocolo “SSL” oficial se consideran obsoletas y no seguras; actualmente NetX Secure no ofrece una implementación de SSL.</span><span class="sxs-lookup"><span data-stu-id="a894b-115">All versions of the official "SSL" protocol are considered obsolete and insecure and currently NetX Secure does not provide an SSL implementation.</span></span>

<span data-ttu-id="a894b-116">TLS especifica un protocolo para generar *claves de sesión* que se crean durante *el protocolo de enlace* de TLS entre un cliente y un servidor de TLS, y dichas claves se utilizan para cifrar los datos enviados por la aplicación durante la *sesión* de TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-116">TLS specifies a protocol to generate *session keys* which are created during the TLS *handshake* between a TLS client and server and those keys are used to encrypt data sent by the application during the TLS *session.*</span></span>

<span data-ttu-id="a894b-117">Los datos de TLS se dividen en *registros* que, conceptualmente, son equivalentes a un paquete TCP.</span><span class="sxs-lookup"><span data-stu-id="a894b-117">TLS data is divided into *records* which are equivalent in concept to a TCP packet.</span></span> <span data-ttu-id="a894b-118">Cada registro TLS tiene un encabezado y los registros cifrados TLS también tienen un pie de página (hash de suma de comprobación).</span><span class="sxs-lookup"><span data-stu-id="a894b-118">Every TLS record has a header, and TLS encrypted records also have a footer (checksum hash).</span></span> <span data-ttu-id="a894b-119">Los registros de protocolo de enlace TLS tienen un encabezado adicional encapsulado en el registro TLS más grande.</span><span class="sxs-lookup"><span data-stu-id="a894b-119">TLS handshake records have an additional header encapsulated within the larger TLS record.</span></span> <span data-ttu-id="a894b-120">El registro TLS está encapsulado por el protocolo de red de la capa de transporte de la misma manera que un paquete TCP está encapsulado por un paquete IP.</span><span class="sxs-lookup"><span data-stu-id="a894b-120">The TLS record is encapsulated by the  transport layer network protocol in the same manner that a TCP packet is encapsulated by an IP packet.</span></span>

### <a name="tls-13"></a><span data-ttu-id="a894b-121">TLS 1.3</span><span class="sxs-lookup"><span data-stu-id="a894b-121">TLS 1.3</span></span>

<span data-ttu-id="a894b-122">En agosto de 2018 finalizó la especificación TLS 1.3.</span><span class="sxs-lookup"><span data-stu-id="a894b-122">In August 2018, the TLS 1.3 specification was finalized.</span></span> <span data-ttu-id="a894b-123">La nueva versión del protocolo es una actualización bastante significativa que cambia algunos aspectos fundamentales de la seguridad y el rendimiento subyacentes de TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-123">The new version of the protocol is a fairly significant update that changes some fundamental aspects of the underlying security and performance of TLS.</span></span> <span data-ttu-id="a894b-124">Sin embargo, estos cambios son en gran medida invisibles para el usuario típico de TLS, ya que se aplican principalmente a la máquina de estados del protocolo de enlace TLS y a la generación de claves de sesión.</span><span class="sxs-lookup"><span data-stu-id="a894b-124">However, these changes are largely invisible to the typical TLS user since they apply primarily to the TLS handshake state machine and session key generation.</span></span> <span data-ttu-id="a894b-125">También se agregaron varias características y extensiones opcionales.</span><span class="sxs-lookup"><span data-stu-id="a894b-125">A number of optional features and extensions were added as well.</span></span> <span data-ttu-id="a894b-126">A continuación puede ver un resumen de los cambios y cómo afectan a la funcionalidad de TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-126">The following is a summary of the changes and how they impact TLS functionality.</span></span>

- <span data-ttu-id="a894b-127">La máquina de estados del protocolo de enlace se optimizó eliminando un intercambio completo de mensajes por parte del servidor.</span><span class="sxs-lookup"><span data-stu-id="a894b-127">The handshake state machine was optimized by removing an entire exchange of messages by the server.</span></span>
- <span data-ttu-id="a894b-128">La generación de claves se actualizó para usar una rutina normalizada denominada HKDF (función de derivación de claves basada en HMAC) y vincula las claves de sesión a todos los mensajes de protocolo de enlace (en lugar de algunos parámetros de selección).</span><span class="sxs-lookup"><span data-stu-id="a894b-128">Key generation was updated to use a standardized routine called HKDF (HMAC-based Key Derivation Function) and ties the session keys to all of the handshake messages (instead of a few select parameters).</span></span>
- <span data-ttu-id="a894b-129">Todos los conjuntos de cifrado de TLS 1.2 y anteriores están en desuso y son incompatibles con TLS 1.3.</span><span class="sxs-lookup"><span data-stu-id="a894b-129">All TLS 1.2 and earlier ciphersuites are deprecated and are incompatible with TLS 1.3.</span></span> <span data-ttu-id="a894b-130">Del mismo modo, ningún conjunto de cifrado de TLS 1.3 se puede usar con versiones anteriores.</span><span class="sxs-lookup"><span data-stu-id="a894b-130">Similarly, all TLS 1.3 ciphersuites are unusable with previous versions.</span></span>
- <span data-ttu-id="a894b-131">Todos los conjuntos de cifrado de TLS 1.3 proporcionan confidencialidad directa total (PFS) mediante claves efímeras<sup>6</sup>.</span><span class="sxs-lookup"><span data-stu-id="a894b-131">All TLS 1.3 ciphersuites provide Perfect Forward Secrecy (PFS) using ephemeral keys<sup>6</sup></span></span> 
- <span data-ttu-id="a894b-132">TLS 1.3 quita el “código de autenticación de mensajes” (MAC) de cada registro en favor del uso de cifrados de AEAD<sup>7</sup>.</span><span class="sxs-lookup"><span data-stu-id="a894b-132">TLS 1.3 removes the "message authentication code" (MAC) in each record in favor of using AEAD<sup>7</sup> ciphers</span></span>
- <span data-ttu-id="a894b-133">Se han agregado algunas características opcionales adicionales, incluido 0-RTT (tiempo de ida y vuelta cero), lo que permite que los datos de la aplicación se envíen durante el protocolo de enlace.</span><span class="sxs-lookup"><span data-stu-id="a894b-133">Some additional optional features were added, including 0-RTT (Zero Round Trip Time) which allows for application data to be sent during the handshake.</span></span> <span data-ttu-id="a894b-134">0: RTT es puramente opcional y no se admite actualmente en Azure RTOS TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-134">0-RTT is purely optional and is not currently supported in Azure RTOS TLS.</span></span>

<span data-ttu-id="a894b-135">TLS 1.3 no afecta significativamente a las aplicaciones del usuario.</span><span class="sxs-lookup"><span data-stu-id="a894b-135">TLS 1.3 does not significantly affect user applications.</span></span> <span data-ttu-id="a894b-136">La API se mantiene exactamente igual entre las distintas versiones y los conjuntos de cifrado se marcan para que se pueda usar una sola tabla de conjuntos de cifrado.</span><span class="sxs-lookup"><span data-stu-id="a894b-136">The API remains exactly the same between versions, and ciphersuites are marked so a single ciphersuite table may be used.</span></span>

<span data-ttu-id="a894b-137">Para usar TLS 1.3, la macro NX_SECURE_TLS_ENABLE_TLS_1_3 debe estar definida globalmente.</span><span class="sxs-lookup"><span data-stu-id="a894b-137">In order to use TLS 1.3, the macro NX_SECURE_TLS_ENABLE_TLS_1_3 must be globally defined.</span></span> <span data-ttu-id="a894b-138">TLS 1.3 está deshabilitado de forma predeterminada en Azure RTOS TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-138">TLS 1.3 is disabled by default in Azure RTOS TLS.</span></span>

6. <span data-ttu-id="a894b-139">Las claves “efímeras” son pares de claves asimétricas que se generan durante el protocolo de enlace TLS y que se usan para el intercambio de secretos solo para esa sesión.</span><span class="sxs-lookup"><span data-stu-id="a894b-139">“Ephemeral” keys are asymmetric key pairs that are generated during the TLS handshake and used for the secrets exchange for only that session.</span></span> <span data-ttu-id="a894b-140">Estos pares de claves se descartan después de su uso. Esto impide que un atacante pueda acceder a los datos cifrados en una sesión TLS registrada, incluso si una clave privada de certificado se ve comprometida en cualquier momento en el futuro (de ahí el nombre “confidencialidad directa total”).</span><span class="sxs-lookup"><span data-stu-id="a894b-140">They key pair is discarded after use – this prevents an attacker from being able to access encrypted data in a recorded TLS session even if a certificate private key is compromised at any time in the future – hence “Perfect Forward Secrecy”.</span></span>

7. <span data-ttu-id="a894b-141">Cifrado autenticado con datos asociados: modo de cifrado como AES que combina el cifrado y la comprobación de la integridad en una sola operación, lo que elimina la necesidad de un hash independiente de los datos para la comprobación de la integridad.</span><span class="sxs-lookup"><span data-stu-id="a894b-141">Authenticated Encryption with Associated Data – a mode for ciphers like AES that combines encryption and integrity checking in a single operation, eliminating the need for a separate hash of the data for integrity checking.</span></span>

### <a name="tls-record-header"></a><span data-ttu-id="a894b-142">Encabezado de registro TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-142">TLS Record header</span></span>

<span data-ttu-id="a894b-143">Un registros TLS válido debe tener un encabezado TLS, como se muestra en Error!</span><span class="sxs-lookup"><span data-stu-id="a894b-143">Any valid TLS record must have a TLS header, as shown in Error!</span></span> <span data-ttu-id="a894b-144">Reference source not found.</span><span class="sxs-lookup"><span data-stu-id="a894b-144">Reference source not found.</span></span>

![Diagrama de un encabezado de registro TLS.](media/image2.png)

<span data-ttu-id="a894b-146">Figura 1: Encabezado de registro TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-146">Figure 1 - TLS record header</span></span>

<span data-ttu-id="a894b-147">Los campos del encabezado de registro TLS se definen de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="a894b-147">The fields of the TLS record header are defined as follows:</span></span>

| <span data-ttu-id="a894b-148">Campo de encabezado TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-148">TLS Header Field</span></span> | <span data-ttu-id="a894b-149">Propósito</span><span class="sxs-lookup"><span data-stu-id="a894b-149">Purpose</span></span>     |
| ---------------- | ------------- |
| <span data-ttu-id="a894b-150">**Tipo de mensaje de 8 bits**</span><span class="sxs-lookup"><span data-stu-id="a894b-150">**8-bit Message Type**</span></span> | <span data-ttu-id="a894b-151">Este campo contiene el tipo de registro TLS que se está enviando.</span><span class="sxs-lookup"><span data-stu-id="a894b-151">This field contains the type of TLS record being sent.</span></span> <span data-ttu-id="a894b-152">Los tipos válidos son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="a894b-152">Valid types are as follows:</span></span><br /><span data-ttu-id="a894b-153">- ChangeCipherSpec<sup>8</sup>: 0x14</span><span class="sxs-lookup"><span data-stu-id="a894b-153">- ChangeCipherSpec<sup>8</sup>: 0x14</span></span><br /><span data-ttu-id="a894b-154">- Alert: 0x15</span><span class="sxs-lookup"><span data-stu-id="a894b-154">- Alert: 0x15</span></span><br /><span data-ttu-id="a894b-155">- Handshake: 0x16</span><span class="sxs-lookup"><span data-stu-id="a894b-155">- Handshake: 0x16</span></span><br /><span data-ttu-id="a894b-156">- ApplicationData: 0x17</span><span class="sxs-lookup"><span data-stu-id="a894b-156">- Application Data: 0x17</span></span> |
| <span data-ttu-id="a894b-157">**Versión del protocolo de 16 bits**</span><span class="sxs-lookup"><span data-stu-id="a894b-157">**16-bit Protocol Version**</span></span> | <span data-ttu-id="a894b-158">Este campo contiene la versión del protocolo TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-158">This field contains the TLS protocol version.</span></span> <span data-ttu-id="a894b-159">Los valores válidos son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="a894b-159">Valid values are as follows:</span></span><br /><span data-ttu-id="a894b-160">- SSL 3.0: 0x0300</span><span class="sxs-lookup"><span data-stu-id="a894b-160">- SSL 3.0: 0x0300</span></span><br /><span data-ttu-id="a894b-161">- TLS 1.0: 0x0301</span><span class="sxs-lookup"><span data-stu-id="a894b-161">- TLS 1.0: 0x0301</span></span><br /><span data-ttu-id="a894b-162">- TLS 1.1: 0x0302</span><span class="sxs-lookup"><span data-stu-id="a894b-162">- TLS 1.1: 0x0302</span></span><br /><span data-ttu-id="a894b-163">- TLS 1.2: 0x0303</span><span class="sxs-lookup"><span data-stu-id="a894b-163">- TLS 1.2: 0x0303</span></span><br /><span data-ttu-id="a894b-164">- **TLS 1.3 <sup>9</sup>** : **0x0303**</span><span class="sxs-lookup"><span data-stu-id="a894b-164">- **TLS 1.3 <sup>9</sup>**: **0x0303**</span></span> |
| <span data-ttu-id="a894b-165">**Longitud de 16 bits**</span><span class="sxs-lookup"><span data-stu-id="a894b-165">**16-bit Length**</span></span> | <span data-ttu-id="a894b-166">Este campo contiene la longitud de los datos encapsulados en el registro TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-166">This field contains the length of the data encapsulated in the TLS record.</span></span> |

8. <span data-ttu-id="a894b-167">En TLS 1.3 ya no se utiliza el mensaje ChangeCipherSpec, aunque se puede enviar por motivos de compatibilidad (en cuyo caso se omite el mensaje).</span><span class="sxs-lookup"><span data-stu-id="a894b-167">In TLS 1.3 the ChangeCipherSpec message is no longer used, though it still may be sent for compatibility reasons in which case the message is ignored.</span></span>

9. <span data-ttu-id="a894b-168">Técnicamente, TLS 1.3 tendría un valor de 0x0304 si este esquema continuase, pero el protocolo se cambió para tener la versión de protocolo real en una extensión, por lo que todos los registros de TLS 1.3 usan 0x0303 en los campos de versión de protocolo para ser compatibles con versiones anteriores.</span><span class="sxs-lookup"><span data-stu-id="a894b-168">TLS 1.3 would technically have a value of 0x0304 if this scheme was continued, but the protocol was changed to have the actual protocol version in an extension, so all TLS 1.3 records use 0x0303 in protocol version fields for backward-compatibility.</span></span>

### <a name="tls-handshake-record-header"></a><span data-ttu-id="a894b-169">Encabezado de registro de protocolo de enlace TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-169">TLS Handshake Record header</span></span>

<span data-ttu-id="a894b-170">Cualquier registro de protocolo de enlace TLS válido debe tener un encabezado de protocolo de enlace TLS, como se muestra en la figura 2.</span><span class="sxs-lookup"><span data-stu-id="a894b-170">Any valid TLS handshake record must have a TLS Handshake header, as shown in Figure 2.</span></span>

![Diagrama de un encabezado de registro de protocolo de enlace TLS.](media/image3.png)

<span data-ttu-id="a894b-172">Figura 2: Encabezado de registro de protocolo de enlace TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-172">Figure 2 - TLS Handshake record header</span></span>

<span data-ttu-id="a894b-173">Los campos del encabezado de registro de protocolo de enlace TLS se definen de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="a894b-173">The fields of the TLS Handshake record header are defined as follows:</span></span>

| <span data-ttu-id="a894b-174">Campo de encabezado TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-174">TLS Header Field</span></span> | <span data-ttu-id="a894b-175">Propósito</span><span class="sxs-lookup"><span data-stu-id="a894b-175">Purpose</span></span> |
| ---------------- |----------------------- |
| <span data-ttu-id="a894b-176">**Tipo de mensaje de 8 bits**</span><span class="sxs-lookup"><span data-stu-id="a894b-176">**8-bit Message Type**</span></span> | <span data-ttu-id="a894b-177">Este campo contiene el tipo de registro TLS que se está enviando.</span><span class="sxs-lookup"><span data-stu-id="a894b-177">This field contains the type of TLS record being sent.</span></span> <span data-ttu-id="a894b-178">Los tipos válidos son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="a894b-178">Valid types are as follows:</span></span><br /><span data-ttu-id="a894b-179">- ChangeCipherSpec<sup>10</sup>: 0x14</span><span class="sxs-lookup"><span data-stu-id="a894b-179">- ChangeCipherSpec<sup>10</sup>: 0x14</span></span><br /><span data-ttu-id="a894b-180">- Alert: 0x15</span><span class="sxs-lookup"><span data-stu-id="a894b-180">- Alert: 0x15</span></span><br /><span data-ttu-id="a894b-181">- Handshake: 0x16</span><span class="sxs-lookup"><span data-stu-id="a894b-181">- Handshake: 0x16</span></span><br /><span data-ttu-id="a894b-182">- ApplicationData: 0x17</span><span class="sxs-lookup"><span data-stu-id="a894b-182">- Application Data: 0x17</span></span> |
| <span data-ttu-id="a894b-183">**Versión del protocolo de 16 bits**</span><span class="sxs-lookup"><span data-stu-id="a894b-183">**16-bit Protocol Version**</span></span> | <span data-ttu-id="a894b-184">Este campo contiene la versión del protocolo TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-184">This field contains the TLS protocol version.</span></span> <span data-ttu-id="a894b-185">Los valores válidos son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="a894b-185">Valid values are as follows:</span></span><br /><span data-ttu-id="a894b-186">- SSL 3.0: 0x0300</span><span class="sxs-lookup"><span data-stu-id="a894b-186">- SSL 3.0: 0x0300</span></span><br /><span data-ttu-id="a894b-187">- TLS 1.0: 0x0301</span><span class="sxs-lookup"><span data-stu-id="a894b-187">- TLS 1.0: 0x0301</span></span><br /><span data-ttu-id="a894b-188">- TLS 1.1: 0x0302</span><span class="sxs-lookup"><span data-stu-id="a894b-188">- TLS 1.1: 0x0302</span></span><br /><span data-ttu-id="a894b-189">- TLS 1.2: 0x0303</span><span class="sxs-lookup"><span data-stu-id="a894b-189">- TLS 1.2: 0x0303</span></span><br /><span data-ttu-id="a894b-190">- **TLS 1.3 <sup>11</sup>** : **0x0303**</span><span class="sxs-lookup"><span data-stu-id="a894b-190">- **TLS 1.3 <sup>11</sup>**: **0x0303**</span></span> |
| <span data-ttu-id="a894b-191">**Longitud de 16 bits**</span><span class="sxs-lookup"><span data-stu-id="a894b-191">**16-bit Length**</span></span>    | <span data-ttu-id="a894b-192">Este campo contiene la longitud de los datos encapsulados en el registro TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-192">This field contains the length of the data encapsulated in the TLS record.</span></span> |
| <span data-ttu-id="a894b-193">**Tipo de protocolo de enlace de 8 bits**</span><span class="sxs-lookup"><span data-stu-id="a894b-193">**8-bit Handshake Type**</span></span> | <span data-ttu-id="a894b-194">Este campo contiene el tipo de mensaje del protocolo de enlace.</span><span class="sxs-lookup"><span data-stu-id="a894b-194">This field contains the handshake message type.</span></span> <span data-ttu-id="a894b-195">Los valores válidos son los siguientes (\*los mensajes en **negrita** se han agregado en TLS 1.3):</span><span class="sxs-lookup"><span data-stu-id="a894b-195">Valid values are as follows (\*messages in **bold** were added in TLS 1.3):</span></span><br /><span data-ttu-id="a894b-196">- HelloRequest: 0x00</span><span class="sxs-lookup"><span data-stu-id="a894b-196">- HelloRequest: 0x00</span></span><br /><span data-ttu-id="a894b-197">- ClientHello: 0x01</span><span class="sxs-lookup"><span data-stu-id="a894b-197">- ClientHello: 0x01</span></span><br /><span data-ttu-id="a894b-198">- ServerHello: 0x02</span><span class="sxs-lookup"><span data-stu-id="a894b-198">- ServerHello: 0x02</span></span><br /><span data-ttu-id="a894b-199">- **HelloVerifyRequest**: **0x03**</span><span class="sxs-lookup"><span data-stu-id="a894b-199">- **HelloVerifyRequest**: **0x03**</span></span><br /><span data-ttu-id="a894b-200">- **NewSessionTicket**: **0x04**</span><span class="sxs-lookup"><span data-stu-id="a894b-200">- **NewSessionTicket**: **0x04**</span></span><br /><span data-ttu-id="a894b-201">- **EndOfEarlyData**: **0x05**</span><span class="sxs-lookup"><span data-stu-id="a894b-201">- **EndOfEarlyData**: **0x05**</span></span><br /><span data-ttu-id="a894b-202">- **EncryptedExtensions**: **0x08**</span><span class="sxs-lookup"><span data-stu-id="a894b-202">- **EncryptedExtensions**: **0x08**</span></span><br /><span data-ttu-id="a894b-203">- Certificate: 0x0B</span><span class="sxs-lookup"><span data-stu-id="a894b-203">- Certificate: 0x0B</span></span><br /><span data-ttu-id="a894b-204">- ServerKeyExchange: 0x0C</span><span class="sxs-lookup"><span data-stu-id="a894b-204">- ServerKeyExchange: 0x0C</span></span><br /><span data-ttu-id="a894b-205">- CertificateRequest: 0x0D</span><span class="sxs-lookup"><span data-stu-id="a894b-205">- CertificateRequest: 0x0D</span></span><br /><span data-ttu-id="a894b-206">- ServerHelloDone: 0x0E</span><span class="sxs-lookup"><span data-stu-id="a894b-206">- ServerHelloDone: 0x0E</span></span><br /><span data-ttu-id="a894b-207">- CertificateVerify: 0x0F</span><span class="sxs-lookup"><span data-stu-id="a894b-207">- CertificateVerify: 0x0F</span></span><br /><span data-ttu-id="a894b-208">- ClientKeyExchange: 0x10</span><span class="sxs-lookup"><span data-stu-id="a894b-208">- ClientKeyExchange: 0x10</span></span><br /><span data-ttu-id="a894b-209">- Finished: 0x14</span><span class="sxs-lookup"><span data-stu-id="a894b-209">- Finished: 0x14</span></span><br /><span data-ttu-id="a894b-210">- **KeyUpdate**: **0x18**</span><span class="sxs-lookup"><span data-stu-id="a894b-210">- **KeyUpdate**: **0x18**</span></span><br /><span data-ttu-id="a894b-211">- **MessageHash**: **0xFE**</span><span class="sxs-lookup"><span data-stu-id="a894b-211">- **MessageHash**: **0xFE**</span></span> |
| <span data-ttu-id="a894b-212">**Longitud de 24 bits**</span><span class="sxs-lookup"><span data-stu-id="a894b-212">**24-bit Length**</span></span>    | <span data-ttu-id="a894b-213">Este campo contiene la longitud de los datos del mensaje del protocolo de enlace.</span><span class="sxs-lookup"><span data-stu-id="a894b-213">This field contains the length of the handshake message data.</span></span> |

10. <span data-ttu-id="a894b-214">En TLS 1.3 ya no se utiliza el mensaje ChangeCipherSpec, aunque se puede enviar por motivos de compatibilidad (en cuyo caso se omite el mensaje).</span><span class="sxs-lookup"><span data-stu-id="a894b-214">In TLS 1.3 the ChangeCipherSpec message is no longer used, though it still may be sent for compatibility reasons in which case the message is ignored.</span></span>

11. <span data-ttu-id="a894b-215">Técnicamente, TLS 1.3 tendría un valor de 0x0304 si este esquema continuase, pero el protocolo se cambió para tener la versión de protocolo real en una extensión, por lo que todos los registros de TLS 1.3 usan 0x0303 en los campos de versión de protocolo para ser compatibles con versiones anteriores.</span><span class="sxs-lookup"><span data-stu-id="a894b-215">TLS 1.3 would technically have a value of 0x0304 if this scheme was continued, but the protocol was changed to have the actual protocol version in an extension, so all TLS 1.3 records use 0x0303 in protocol version fields for backward-compatibility.</span></span>

### <a name="the-tls-handshake-and-tls-session"></a><span data-ttu-id="a894b-216">El protocolo de enlace TLS y la sesión TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-216">The TLS Handshake and TLS Session</span></span>

<span data-ttu-id="a894b-217">En la figura 3 se muestra un protocolo de enlace TLS típico (versiones 1.0-1.2).</span><span class="sxs-lookup"><span data-stu-id="a894b-217">A typical TLS handshake (versions 1.0-1.2) is shown in Figure 3.</span></span> <span data-ttu-id="a894b-218">Un protocolo de enlace TLS comienza cuando el cliente envía un mensaje *ClientHello* a un servidor TLS e indica su deseo de iniciar una sesión de TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-218">A TLS handshake begins when the TLS Client sends a *ClientHello* message to a TLS server, indicating its desire to start a TLS session.</span></span> <span data-ttu-id="a894b-219">El mensaje contiene información sobre el cifrado que el cliente desea utilizar para la sesión, junto con la información utilizada para generar las claves de sesión más adelante en el protocolo de enlace.</span><span class="sxs-lookup"><span data-stu-id="a894b-219">The message contains information about the encryption the client would like to use for the session, along with information used to generate the session keys later in the handshake.</span></span> <span data-ttu-id="a894b-220">Hasta que no se generen las claves de sesión, no se cifrarán todos los mensajes del protocolo de enlace TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-220">Until the session keys are generated, all messages in the TLS handshake are not encrypted.</span></span> <span data-ttu-id="a894b-221">TLS 1.3 cambia el protocolo de enlace: los detalles se muestran en la sección siguiente.</span><span class="sxs-lookup"><span data-stu-id="a894b-221">TLS 1.3 changes the handshake somewhat – details are presented in the next section.</span></span>

<span data-ttu-id="a894b-222">El servidor TLS responde a ClientHello con un mensaje ServerHello, lo que indica una selección de las opciones de cifrado proporcionadas por el cliente.</span><span class="sxs-lookup"><span data-stu-id="a894b-222">The TLS Server responds to the ClientHello with a ServerHello message, indicating a selection from the encryption options provided by the client.</span></span> <span data-ttu-id="a894b-223">ServerHello va seguido de un mensaje de certificado en el que el servidor proporciona un certificado digital para autenticar su identidad en el cliente.</span><span class="sxs-lookup"><span data-stu-id="a894b-223">The ServerHello is followed by a Certificate message, in which the server provides a digital certificate to authenticate its identity to the client.</span></span> <span data-ttu-id="a894b-224">Por último, el servidor envía un mensaje ServerHelloDone para indicar que no tiene más mensajes para enviar.</span><span class="sxs-lookup"><span data-stu-id="a894b-224">Finally, the server sends a ServerHelloDone message to indicate it has no more messages to send.</span></span> <span data-ttu-id="a894b-225">Opcionalmente, el servidor puede enviar otros mensajes después de ServerHello y, en algunos casos, puede no enviar un mensaje de certificado, de ahí que el mensaje ServerHelloDone sea necesario.</span><span class="sxs-lookup"><span data-stu-id="a894b-225">The server may optionally send other messages following the ServerHello and in some cases it may not send a Certificate message, hence the need for the ServerHelloDone message.</span></span>

<span data-ttu-id="a894b-226">Una vez que el cliente ha recibido todos los mensajes del servidor, tiene suficiente información para generar las claves de sesión.</span><span class="sxs-lookup"><span data-stu-id="a894b-226">Once the client has received all the server's messages, it has enough information to generate the session keys.</span></span> <span data-ttu-id="a894b-227">TLS lo hace mediante la creación de un bit compartido de datos aleatorios denominado *secreto premaestro*, que tiene un tamaño fijo y se utiliza como un valor de inicialización para generar todas las claves necesarias una vez habilitado el cifrado.</span><span class="sxs-lookup"><span data-stu-id="a894b-227">TLS does this by creating a shared bit of random data called the *Pre-Master Secret*, which is a fixed-size and is used as a seed to generate all the keys needed once encryption is enabled.</span></span> <span data-ttu-id="a894b-228">El secreto premaestro se cifra mediante el algoritmo de clave pública (por ejemplo, RSA) especificado en los mensajes Hello (consulte más abajo para obtener información sobre los algoritmos de clave pública) y la clave pública proporcionada por el servidor en su certificado.</span><span class="sxs-lookup"><span data-stu-id="a894b-228">The Pre-Master Secret is encrypted using the public key algorithm (e.g. RSA) specified in the Hello messages (see below for information on public key algorithms) and the public key provided by the server in its certificate.</span></span> <span data-ttu-id="a894b-229">Una característica opcional de TLS denominada claves precompartidas (PSK) admite conjuntos de cifrado que no usan un certificado, sino un valor de secreto compartido entre los hosts (normalmente a través de transferencia física u otro método protegido).</span><span class="sxs-lookup"><span data-stu-id="a894b-229">An optional TLS feature called Pre-Shared Keys (PSK) enables ciphersuites that do not use a certificate but instead use a secret value shared between the hosts (usually through physical transfer or other secured method).</span></span> <span data-ttu-id="a894b-230">El secreto compartido se usa para generar el secreto premaestro en lugar de usar un mensaje cifrado para enviarlo.</span><span class="sxs-lookup"><span data-stu-id="a894b-230">The shared secret is used to generate the Pre-Master Secret instead of using an encrypted message to send the Pre-Master Secret.</span></span> <span data-ttu-id="a894b-231">Consulte a continuación la sección sobre claves precompartidas.</span><span class="sxs-lookup"><span data-stu-id="a894b-231">See the section on Pre-Shared Keys below.</span></span>

<span data-ttu-id="a894b-232">El secreto premaestro cifrado se envía al servidor en el mensaje ClientKeyExchange.</span><span class="sxs-lookup"><span data-stu-id="a894b-232">The encrypted Pre-Master Secret is sent to the server in the ClientKeyExchange message.</span></span> <span data-ttu-id="a894b-233">El servidor, al recibir el mensaje ClientKeyExchange, descifra el secreto premaestro mediante su clave privada y continúa generando las claves de sesión en paralelo con el cliente TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-233">The server, upon receiving the ClientKeyExchange message, decrypts the Pre-Master Secret using its private key and proceeds to generate the session keys in parallel with the TLS client.</span></span>

<span data-ttu-id="a894b-234">Una vez generadas las claves de sesión, todos los mensajes posteriores se pueden cifrar mediante el algoritmo de clave privada (por ejemplo, AES) seleccionado en los mensajes Hello.</span><span class="sxs-lookup"><span data-stu-id="a894b-234">Once the session keys are generated, all further messages can be encrypted using the private-key algorithm (e.g. AES) selected in the Hello messages.</span></span> <span data-ttu-id="a894b-235">El cliente y el servidor envían un mensaje no cifrado final denominado ChangeCipherSpec para indicar que se cifrarán todos los mensajes posteriores.</span><span class="sxs-lookup"><span data-stu-id="a894b-235">One final un-encrypted message called ChangeCipherSpec is sent by both the client and server to indicate that all further messages will be encrypted.</span></span>

<span data-ttu-id="a894b-236">El primer mensaje cifrado enviado por el cliente y el servidor también es el mensaje de protocolo de enlace TLS final, denominado Finished.</span><span class="sxs-lookup"><span data-stu-id="a894b-236">The first encrypted message sent by both the client and server is also the final TLS handshake message, called Finished.</span></span> <span data-ttu-id="a894b-237">Este mensaje contiene un hash de todos los mensajes de protocolo de enlace recibidos y enviados.</span><span class="sxs-lookup"><span data-stu-id="a894b-237">This message contains a hash of all the handshake messages received and sent.</span></span> <span data-ttu-id="a894b-238">Este hash se utiliza para comprobar que ninguno de los mensajes del protocolo de enlace se ha manipulado o dañado (lo que indica una posible infracción de seguridad).</span><span class="sxs-lookup"><span data-stu-id="a894b-238">This hash is used to verify that none of the messages in the handshake have been tampered with or corrupted (indicating a possible breach of security).</span></span>

<span data-ttu-id="a894b-239">Una vez recibidos los mensajes Finished y comprobados los hashes del protocolo de enlace, se inicia la sesión de TLS y la aplicación comienza a enviar y recibir datos.</span><span class="sxs-lookup"><span data-stu-id="a894b-239">Once the Finished messages are received and the handshake hashes are verified, the TLS session begins, and the application begins sending and receiving data.</span></span> <span data-ttu-id="a894b-240">En primer lugar, se aplica un algoritmo hash a todos los datos enviados desde cualquier lado durante la sesión de TLS con el algoritmo hash elegido en los mensajes Hello (para proporcionar integridad del mensaje) y se cifran mediante el algoritmo de clave privada elegido con las claves de sesión generadas.</span><span class="sxs-lookup"><span data-stu-id="a894b-240">All data sent by either side during the TLS session is first hashed using the hash algorithm chosen in the Hello messages (to provide message integrity) and encrypted using the chosen private-key algorithm with the generated session keys.</span></span>

<span data-ttu-id="a894b-241">Por último, una sesión de TLS solo se puede finalizar correctamente si el cliente o el servidor decide hacerlo.</span><span class="sxs-lookup"><span data-stu-id="a894b-241">Finally, a TLS session can only be successfully ended if either the Client or Server chooses to do so.</span></span> <span data-ttu-id="a894b-242">Una sesión truncada se considera una infracción de seguridad (ya que un atacante puede estar intentando impedir que se reciban todos los datos que se envían), por lo que se envía una notificación especial cuando uno de los lados desea finalizar la sesión (denominada alerta CloseNotify).</span><span class="sxs-lookup"><span data-stu-id="a894b-242">A truncated session is considered a security breach (since an attacker may be attempting to prevent all the data being sent from being received) so a special notification is sent when either side wants to end the session, called a CloseNotify alert.</span></span> <span data-ttu-id="a894b-243">Tanto el cliente como el servidor deben enviar y procesar una alerta CloseNotify para que se cierre correctamente la sesión.</span><span class="sxs-lookup"><span data-stu-id="a894b-243">Both the client and server must send and process a CloseNotify alert for a successful session shutdown.</span></span>

![Diagrama de un protocolo de enlace TLS típico.](media/image4.png)

<span data-ttu-id="a894b-245">Figura 3: Protocolo de enlace TLS típico</span><span class="sxs-lookup"><span data-stu-id="a894b-245">Figure 3- Typical TLS handshake</span></span>

### <a name="tls-13-handshake"></a><span data-ttu-id="a894b-246">Protocolo de enlace TLS 1.3</span><span class="sxs-lookup"><span data-stu-id="a894b-246">TLS 1.3 Handshake</span></span>

<span data-ttu-id="a894b-247">TLS 1.3 es una revisión bastante importante del protocolo TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-247">TLS 1.3 is a fairly major overhaul of the TLS protocol.</span></span> <span data-ttu-id="a894b-248">La gran mayoría de los cambios se han realizado en el protocolo de enlace para aumentar la seguridad y el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a894b-248">The vast majority of the changes were made to the handshake to increase security and performance.</span></span> <span data-ttu-id="a894b-249">En la figura 4 se muestra un protocolo de enlace TLS 1.3 típico.</span><span class="sxs-lookup"><span data-stu-id="a894b-249">A typical TLS 1.3 handshake is shown in Figure 4.</span></span> <span data-ttu-id="a894b-250">La diferencia principal puede verse en el número de intercambios entre el servidor y el cliente.</span><span class="sxs-lookup"><span data-stu-id="a894b-250">The primary difference can be seen in the number of exchanges between the server and client.</span></span>

<span data-ttu-id="a894b-251">En TLS 1.2 y versiones anteriores, el servidor enviaba los mensajes en dos paquetes<sup>12</sup> de mensajes: en primer lugar, ServerHello y, después, un mensaje de ChangeCipherSpec antes de enviar el mensaje cifrado Finished que finaliza el protocolo de enlace.</span><span class="sxs-lookup"><span data-stu-id="a894b-251">In TLS 1.2 and earlier, the server would send two flights<sup>12</sup> of messages – first the ServerHello and then a ChangeCipherSpec message before sending the encrypted Finished message that ends the handshake.</span></span> <span data-ttu-id="a894b-252">En TLS 1.3, el servidor envía todo en el primer paquete: ServerHello, las extensiones, el certificado y el mensaje Finished.</span><span class="sxs-lookup"><span data-stu-id="a894b-252">In TLS 1.3, the server sends everything in the first flight – ServerHello, extensions, certificate, and Finished.</span></span> <span data-ttu-id="a894b-253">Se ha eliminado el mensaje ChangeCipherSpec y el servidor genera sus claves de sesión y comienza a cifrar los mensajes de protocolo de enlace inmediatamente después de ServerHello.</span><span class="sxs-lookup"><span data-stu-id="a894b-253">The ChangeCipherSpec message was eliminated and the server generates its session keys and starts encrypting handshake messages immediately following the ServerHello.</span></span>

<span data-ttu-id="a894b-254">La nueva disposición significa que una mayor parte del protocolo de enlace TLS está protegido por el cifrado, lo que limita la cantidad de datos de texto no cifrado a los que puede tener acceso un atacante.</span><span class="sxs-lookup"><span data-stu-id="a894b-254">The new arrangement means that more of the TLS handshake is protected by encryption, limiting the amount of plaintext data an attacker can access.</span></span> <span data-ttu-id="a894b-255">Además, la eliminación del segundo paquete del servidor (que era simplemente un ChangeCipherSpec seguido de Finished) significa que un cliente TLS ya no necesita esperar para iniciar la transmisión de datos de la aplicación: tan pronto como el cliente envía su propio mensaje Finished, la sesión se inicia.</span><span class="sxs-lookup"><span data-stu-id="a894b-255">Additionally, the removal of the second server flight (which was just a ChangeCipherSpec followed by a Finished) means that a TLS client no longer needs to wait to start transmitting application data – as soon as the client sends its own Finished message the session is started.</span></span>

12. <span data-ttu-id="a894b-256">En este contexto, un paquete es simplemente una colección de mensajes TLS que se envían simultáneamente en un grupo.</span><span class="sxs-lookup"><span data-stu-id="a894b-256">A flight is simply a collection of TLS messages sent simultaneously in a group.</span></span>

![Diagrama de un protocolo de enlace TLS 1.3.](media/image5.png)

<span data-ttu-id="a894b-258">Figura 4: Protocolo de enlace TLS 1.3</span><span class="sxs-lookup"><span data-stu-id="a894b-258">Figure 4 - TLS 1.3 Handshake</span></span>

> [!NOTE]
> <span data-ttu-id="a894b-259">*TLS 1.3 también introducía la noción de “datos tempranos” y 0-RTT (tiempo de ida y vuelta cero), lo que significa que algunos datos de la aplicación se pueden enviar en el primer paquete de mensajes. Esta característica opcional se agregó principalmente como una optimización de la capacidad de respuesta del explorador Web (por ejemplo, para enviar encabezados HTTP iniciales para empezar a representar una página). A partir de Azure RTOS 6.0, no se admite esta característica.*</span><span class="sxs-lookup"><span data-stu-id="a894b-259">*TLS 1.3 also introduced the notion of "Early data" and 0-RTT (Zero Round Trip Time), meaning that some application data can be sent in the first flight of messages. This optional feature was added primarily as an optimization for web browser responsiveness (e.g. to send early HTTP headers to start rendering a page). As of Azure RTOS 6.0 this feature is NOT supported.*</span></span>

### <a name="initialization"></a><span data-ttu-id="a894b-260">Inicialización</span><span class="sxs-lookup"><span data-stu-id="a894b-260">Initialization</span></span>

<span data-ttu-id="a894b-261">La pila TCP/IP de NetX o NetXDuo debe inicializarse antes de usar el servicio TLS de NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="a894b-261">The NetX or NetXDuo TCP/IP stack must be initialized prior to using NetX Secure TLS.</span></span> <span data-ttu-id="a894b-262">Consulte la guía de usuario de NetX o NetXDuo para obtener información sobre cómo inicializar correctamente la pila TCP/IP.</span><span class="sxs-lookup"><span data-stu-id="a894b-262">Refer to the NetX or NetXDuo User Guide for information on how to properly initialize the TCP/IP stack.</span></span>

<span data-ttu-id="a894b-263">Una vez inicializada la pila TCP/IP de NetX, se puede habilitar TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-263">Once the NetX TCP/IP stack has been initialized, TLS can be enabled.</span></span> <span data-ttu-id="a894b-264">Internamente, todo el tráfico de red y el procesamiento de TLS se controla mediante la pila de NetX/NetXDuo sin necesidad de la intervención del usuario.</span><span class="sxs-lookup"><span data-stu-id="a894b-264">Internally, all TLS network traffic and processing is handled by the NetX/NetXDuo stack without requiring user intervention.</span></span> <span data-ttu-id="a894b-265">Sin embargo, TLS tiene algunos requisitos específicos que se deben controlar de forma independiente de la pila de red subyacente.</span><span class="sxs-lookup"><span data-stu-id="a894b-265">However, TLS has some specific requirements that must be handled separately from the underlying network stack.</span></span> <span data-ttu-id="a894b-266">Estos parámetros se asignan al bloque de control de TLS llamado \***NX_SECURE_TLS_SESSION** _ mediante el servicio _ \*_nx_secure_tls_session_create_\*\*.</span><span class="sxs-lookup"><span data-stu-id="a894b-266">These parameters are assigned to the TLS control block called ***NX_SECURE_TLS_SESSION** _ using the _ *_nx_secure_tls_session_create_** service.</span></span>

<span data-ttu-id="a894b-267">TLS tiene dos modos, servidor y cliente, y ambos pueden esta habilitados en una aplicación (pero solo un modo por socket NetX). Cada uno tiene sus propios requisitos específicos y se detallan a continuación.</span><span class="sxs-lookup"><span data-stu-id="a894b-267">TLS has two modes, Server and Client, either of which may be enabled in an application (but only one mode per NetX socket), and each have their own specific requirements, detailed below.</span></span>

<span data-ttu-id="a894b-268">En los dos modos, el servicio TLS de NetX Secure requiere la creación y configuración de un socket TCP (\***NX_TCP_SOCKET** _) para las comunicaciones TCP con el host remoto.</span><span class="sxs-lookup"><span data-stu-id="a894b-268">In either mode, NetX Secure TLS requires a TCP socket (\***NX_TCP_SOCKET** _) to be created and set up for TCP communications with the remote host.</span></span> <span data-ttu-id="a894b-269">El socket TCP se asigna a una instancia de sesión TLS con el servicio _ \*_nx_secure_tls_session_start_\*\*, que se detalla a continuación.</span><span class="sxs-lookup"><span data-stu-id="a894b-269">The TCP socket is assigned to a TLS session instance with the _ *_nx_secure_tls_session_start_*\* service, detailed below.</span></span>

### <a name="initialization--tls-server"></a><span data-ttu-id="a894b-270">Inicialización – Servidor TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-270">Initialization – TLS Server</span></span>

<span data-ttu-id="a894b-271">Además de un socket TCP, el modo de servidor TLS de NetX Secure requiere un *certificado digital* (que es un documento que se usa para identificar el servidor TLS en el cliente TLS de conexión) y los certificados de *clave privada* correspondientes (normalmente para el algoritmo de cifrado RSA).</span><span class="sxs-lookup"><span data-stu-id="a894b-271">In addition to a TCP socket, NetX Secure TLS Server mode requires a *Digital Certificate*, which is a document used to identify the TLS server to the connecting TLS client, and the certificates corresponding *Private Key*, usually for the RSA encryption algorithm.</span></span> <span data-ttu-id="a894b-272">La norma International Telecommunications Union X.509 especifica el formato de certificado que usa TLS y hay numerosas utilidades para crear certificados digitales X.509.</span><span class="sxs-lookup"><span data-stu-id="a894b-272">The International Telecommunications Union X.509 standard specifies the certificate format used by TLS and there are numerous utilities for creating X.509 digital certificates.</span></span>

<span data-ttu-id="a894b-273">En el caso del servicio TLS de NetX Secure, el certificado X.509 debe estar codificado de forma binaria con el formato de reglas de codificación distinguida (DER) de ASN.1.</span><span class="sxs-lookup"><span data-stu-id="a894b-273">For NetX Secure TLS, the X.509 certificate must be binary-encoded using the Distinguished Encoding Rules (DER) format of ASN.1.</span></span> <span data-ttu-id="a894b-274">DER es el formato binario estándar TLS durante la conexión para los certificados.</span><span class="sxs-lookup"><span data-stu-id="a894b-274">DER is the standard TLS over-the-wire binary format for certificates.</span></span>

<span data-ttu-id="a894b-275">La clave privada asociada con el certificado proporcionado debe estar en formato PKCS#1 codificado mediante DER.</span><span class="sxs-lookup"><span data-stu-id="a894b-275">The private key associated with the provided certificate must be in DER-Encoded PKCS#1 format.</span></span> <span data-ttu-id="a894b-276">La clave privada solo se usa en el dispositivo y nunca se transmitirá a través de la conexión.</span><span class="sxs-lookup"><span data-stu-id="a894b-276">The private key is only used on the device and will never be transmitted over the wire.</span></span> <span data-ttu-id="a894b-277">¡Mantenga las claves privadas seguras, ya que proporcionan la seguridad de las comunicaciones TLS!</span><span class="sxs-lookup"><span data-stu-id="a894b-277">Keep private keys safe as they provide the security for TLS communications!</span></span>

<span data-ttu-id="a894b-278">Para inicializar el certificado de servidor TLS, la aplicación debe proporcionar un puntero a un búfer que contenga el certificado X.509 codificado mediante DER y datos opcionales de clave privada RSA PKCS#1 codificados mediante DER con el servicio ***nx_secure_x509_certificate_intialize** _ (que rellena la estructura _ *NX_SECURE_X509_CERT** con los datos de certificado adecuados para su uso por parte de TLS).</span><span class="sxs-lookup"><span data-stu-id="a894b-278">To initialize the TLS Server certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate and optional DER-encoded PKCS#1 RSA private key data using the ***nx_secure_x509_certificate_intialize** _ service, which populates the _ *NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="a894b-279">Una vez inicializado el certificado de servidor, debe agregarse al bloque de control de TLS mediante el servicio ***nx_secure_tls_local_certificate_add***.</span><span class="sxs-lookup"><span data-stu-id="a894b-279">Once the server certificate has been initialized, it must be added to the TLS control block using the ***nx_secure_tls_local_certificate_add*** service.</span></span>

<span data-ttu-id="a894b-280">Una vez que se ha agregado el certificado del servidor al bloque de control de TLS, se puede usar el socket para establecer una conexión segura del servidor TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-280">Once the server's certificate has been added to the TLS control block, the socket may be used to establish a secure TLS Server connection.</span></span>

### <a name="initialization--tls-client"></a><span data-ttu-id="a894b-281">Inicialización – Cliente TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-281">Initialization – TLS Client</span></span>

<span data-ttu-id="a894b-282">El modo de cliente TLS de NetX Secure necesita un *almacén de certificados de confianza*, que es una colección de certificados digitales con codificación X.509 de las entidades de certificación de confianza (CA).</span><span class="sxs-lookup"><span data-stu-id="a894b-282">NetX Secure TLS Client mode requires a *Trusted Certificate Store*, which is a collection of X.509-encoded digital certificates from trusted Certificate Authorities (CA's).</span></span> <span data-ttu-id="a894b-283">El protocolo TLS da por supuesto que estos certificados son “de confianza” y sirven como base para autenticar los certificados proporcionados por las entidades de servidor TLS en el cliente TLS de NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="a894b-283">These certificates are assumed by the TLS protocol to be "trusted" and serve as the basis for authenticating certificates provided by TLS server entities to NetX Secure TLS Client.</span></span>

<span data-ttu-id="a894b-284">Un certificado de CA de confianza puede ser *autofirmado* o firmado por otra CA, en cuyo caso el certificado se denomina de *CA intermedia* (ICA).</span><span class="sxs-lookup"><span data-stu-id="a894b-284">A trusted CA certificate may either be *self-signed* or signed by another CA, in which case that certificate is called an *Intermediate CA* (ICA).</span></span> <span data-ttu-id="a894b-285">En una aplicación TLS típica, el servidor proporciona los certificados ICA junto con su certificado de servidor, pero el único requisito para la autenticación correcta es que se pueda realizar un seguimiento de una cadena de emisores (certificados usados para firmar otros certificados) desde el certificado de servidor a un certificado de CA de confianza en el almacén de certificados de confianza.</span><span class="sxs-lookup"><span data-stu-id="a894b-285">In a typical TLS application, the server provides the ICA certificates along with its server certificate, but the only requirement for successful authentication is that a chain of issuers (certificates used to sign other certificates) can be traced from the server certificate back to a trusted CA certificate in the Trusted Certificate Store.</span></span> <span data-ttu-id="a894b-286">Esta cadena se conoce como *cadena de confianza* o *cadena de certificados*.</span><span class="sxs-lookup"><span data-stu-id="a894b-286">This chain is known as a  *chain of trust* or *certificate chain*.</span></span>

<span data-ttu-id="a894b-287">Para inicializar un certificado de CA o ICA de confianza, la aplicación debe proporcionar un puntero a un búfer que contenga el certificado X.509 codificado mediante DER con el servicio **nx_secure_x509_certificate_intialize** (que rellena la estructura *NX_SECURE_X509_CERT*\* con los datos de certificado adecuados para su uso por parte de TLS).</span><span class="sxs-lookup"><span data-stu-id="a894b-287">To initialize a trusted CA or ICA certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate using the ***nx_secure_x509_certificate_intialize** _ service, which populates the _ *NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="a894b-288">Los certificados de confianza que se han inicializado se agregan a continuación al bloque de control de TLS creado mediante el servicio ***nx_secure_tls_trusted_certificate_add***.</span><span class="sxs-lookup"><span data-stu-id="a894b-288">Trusted certificates that have been initialized are then added to the TLS control block using the ***nx_secure_tls_trusted_certificate_add*** service.</span></span> <span data-ttu-id="a894b-289">Si no se agrega un certificado, se producirá un error en la sesión de cliente TLS, ya que no habrá forma de que el protocolo TLS autentique los hosts de servidor TLS remotos.</span><span class="sxs-lookup"><span data-stu-id="a894b-289">Failure to add a certificate will cause the TLS Client session to fail as there will be no way for the TLS protocol to authenticate remote TLS server hosts.</span></span>

<span data-ttu-id="a894b-290">El cliente TLS también necesita espacio para asignar el certificado de servidor entrante (suponiendo que no se esté usando el modo de clave precompartida).</span><span class="sxs-lookup"><span data-stu-id="a894b-290">The TLS Client also needs space for the incoming server certificate to be allocated (assuming a Pre-Shared Key mode is not being used).</span></span> <span data-ttu-id="a894b-291">A partir de la versión 5.12 de TLS en NetX Secure, ya no es necesario que la aplicación asigne espacio para el certificado remoto.</span><span class="sxs-lookup"><span data-stu-id="a894b-291">As of NetX Secure TLS 5.12, it is no longer necessary for the application to allocate space for remote certificate.</span></span> <span data-ttu-id="a894b-292">Sin embargo, la opción heredada para asignar espacio para un certificado de servidor sigue estando disponible y los certificados asignados por el usuario se usarán antes de la optimización de búfer de certificado interno <sup>13</sup>; consulte el servicio ***nx_secure_tls_remote_certificate_allocate*** para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="a894b-292">However, the legacy option to allocate space for a server certificate is still available and user-allocated certificates will be used before the internal certificate buffer optimization <sup>13</sup> – see the ***nx_secure_tls_remote_certificate_allocate*** service for more information.</span></span>

<span data-ttu-id="a894b-293">Una vez creado el almacén de certificados de confianza y tras haber asignado espacio para el certificado de servidor, el socket se puede usar para establecer una conexión de cliente TLS segura.</span><span class="sxs-lookup"><span data-stu-id="a894b-293">Once the Trusted Certificate Store has been created and space for the server certificate has been allocated, the socket may be used to establish a secure TLS Client connection.</span></span>

13. <span data-ttu-id="a894b-294">La optimización usa el “búfer de paquetes” proporcionado por la aplicación de usuario a la sesión de TLS mediante *nx_secure_tls_session_packet_buffer_set* para asignar las estructuras de análisis de X.509 en lugar de usar las estructuras proporcionadas por el usuario que se usan en versiones anteriores del servicio TLS de NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="a894b-294">The optimization utilizes the “packet buffer” supplied by the user application to the tls session using *nx_secure_tls_session_packet_buffer_set* to allocate the X.509 parsing structures instead of using the user-supplied structures used in earlier versions of NetX Secure TLS.</span></span> <span data-ttu-id="a894b-295">No es probable que se detecte una cadena de certificados que supere el tamaño del búfer de paquetes, en cuyo caso se puede aumentar el tamaño del búfer de paquetes o usar *nx_secure_tls _remote_certificate_allocate* para asignar más espacio para la cadena de certificados.</span><span class="sxs-lookup"><span data-stu-id="a894b-295">There is an unlikely possibility of encountering a certificate chain exceeding the size of the packet buffer in which case either the packet buffer size may be increased or *nx_secure_tls _remote_certificate_allocate* may be used to allocate more space for the certificate chain.</span></span>

### <a name="application-interface-calls"></a><span data-ttu-id="a894b-296">Llamadas a la interfaz de la aplicación</span><span class="sxs-lookup"><span data-stu-id="a894b-296">Application Interface Calls</span></span>

<span data-ttu-id="a894b-297">Las aplicaciones TLS de NetX Secure normalmente realizarán llamadas de función desde subprocesos de la aplicación que se ejecutan en ThreadX RTOS.</span><span class="sxs-lookup"><span data-stu-id="a894b-297">NetX Secure TLS applications will typically make function calls from within application threads running under the ThreadX RTOS.</span></span> <span data-ttu-id="a894b-298">Se puede llamar a cierta inicialización, especialmente para los protocolos de comunicaciones de red subyacentes (por ejemplo, TCP e IP), desde \***tx_application_define\*.**</span><span class="sxs-lookup"><span data-stu-id="a894b-298">Some initialization, particularly for the underlying network communications protocols (e.g. TCP and IP) may be called from \***tx_application_define\*.**</span></span> <span data-ttu-id="a894b-299">Consulte la guía de usuario de NetX/NetXDuo para obtener más información sobre cómo inicializar las comunicaciones de red.</span><span class="sxs-lookup"><span data-stu-id="a894b-299">See the NetX/NetXDuo User Guide for more information on initializing network communications.</span></span>

<span data-ttu-id="a894b-300">TLS hace un uso intensivo de las rutinas de cifrado que son operaciones de uso intensivo del procesador.</span><span class="sxs-lookup"><span data-stu-id="a894b-300">TLS makes heavy use of encryption routines which are processor-intensive operations.</span></span> <span data-ttu-id="a894b-301">Por lo general, estas operaciones se realizarán en el contexto del subproceso que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="a894b-301">Generally, these operations will be performed within the context of calling thread.</span></span>

### <a name="tls-session-start"></a><span data-ttu-id="a894b-302">Inicio de sesión de TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-302">TLS Session Start</span></span>

<span data-ttu-id="a894b-303">TLS requiere un protocolo de red de capa de transporte subyacente para poder funcionar.</span><span class="sxs-lookup"><span data-stu-id="a894b-303">TLS requires an underlying transport-layer network protocol in order to function.</span></span> <span data-ttu-id="a894b-304">El protocolo que se usa normalmente es TCP.</span><span class="sxs-lookup"><span data-stu-id="a894b-304">The protocol typically used is TCP.</span></span> <span data-ttu-id="a894b-305">Para establecer una sesión TLS de NetX Secure, se debe establecer una conexión TCP mediante la API de TCP de NetX/NetXDuo.</span><span class="sxs-lookup"><span data-stu-id="a894b-305">In order to establish a NetX Secure TLS session, a TCP connection must be established using the NetX/NetXDuo TCP API.</span></span> <span data-ttu-id="a894b-306">Se debe crear un objeto **NX_TCP_SOCKET** y una conexión establecida con los servicios **_nx_tcp_server_socket_listen_ *_ y _* _nx_tcp_server_socket_accept_ *_ (para el servidor TLS) o con el servicio _* _nx_tcp_client_socket_connect_** (para el cliente TLS).</span><span class="sxs-lookup"><span data-stu-id="a894b-306">An **NX_TCP_SOCKET** must be created and a connection established using the **_nx_tcp_server_socket_listen_*_ and _*_nx_tcp_server_socket_accept_*_ services (for TLS Server) or the _*_nx_tcp_client_socket_connect_** service (for TLS Client).</span></span>

<span data-ttu-id="a894b-307">Una vez establecida una conexión TCP, el socket TCP se pasa al servicio ***nx_secure_tls_session_start***.</span><span class="sxs-lookup"><span data-stu-id="a894b-307">Once a TCP connection has been established, the TCP socket is then passed to the ***nx_secure_tls_session_start*** service.</span></span>

### <a name="tls-packet-allocation"></a><span data-ttu-id="a894b-308">Asignación de paquetes TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-308">TLS Packet Allocation</span></span>

<span data-ttu-id="a894b-309">El servicio TLS de NetX Secure usa la misma estructura de paquetes que el protocolo TCP de NetX/NetXDuo (***NX_PACKET** _), salvo que, en lugar de llamar al servicio _*_nx_packet_allocate_*_, se debe llamar al servicio _ *_nx_secure_tls_packet_allocate_** para que se pueda asignar correctamente el espacio para el encabezado TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-309">NetX Secure TLS uses the same packet structure as NetX/NetXDuo TCP (***NX_PACKET** _) except that instead of calling the _*_nx_packet_allocate_*_ service, the _ *_nx_secure_tls_packet_allocate_** service must be called so that space for the TLS header may be allocated properly.</span></span>

### <a name="tls-session-send"></a><span data-ttu-id="a894b-310">Envío de sesión de TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-310">TLS Session Send</span></span>

<span data-ttu-id="a894b-311">Una vez iniciada la sesión TLS, la aplicación puede enviar datos mediante el servicio \***nx_secure_tls_session_send**.</span><span class="sxs-lookup"><span data-stu-id="a894b-311">Once the TLS session has started, the application may send data using the \***nx_secure_tls_session_send** _ service.</span></span> <span data-ttu-id="a894b-312">El uso del servicio de envío es idéntico para el servicio _*_nx_tcp_socket_send_*_ y toma una estructura de datos _*_NX_PACKET_*_ con los datos que se envían. La diferencia es que los datos se cifrarán mediante la pila TLS de NX Secure antes de que se envíen y el paquete debe asignarse mediante _ *_nx_secure_tls_packet_allocate_* \*.</span><span class="sxs-lookup"><span data-stu-id="a894b-312">The send service is identical in use to the _*_nx_tcp_socket_send_*_ service, taking an _*_NX_PACKET_*_ data structure containing the data being sent, only that data will be encrypted by the NX Secure TLS stack before being sent, and the packet must be allocated using _\*_nx_secure_tls_packet_allocate_\*\*.</span></span>

### <a name="tls-session-receive"></a><span data-ttu-id="a894b-313">Recepción de sesión de TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-313">TLS Session Receive</span></span>

<span data-ttu-id="a894b-314">Una vez iniciada la sesión de TLS, la aplicación puede empezar a recibir datos mediante el servicio \***nx_secure_tls_session_receive** _.</span><span class="sxs-lookup"><span data-stu-id="a894b-314">Once the TLS session has started, the application may begin receiving data using the \***nx_secure_tls_session_receive** _ service.</span></span> <span data-ttu-id="a894b-315">Al igual que el envío de la sesión de TLS, este servicio se usa exactamente igual que _\*_nx_udp_socket_receive_\*\*, con la salvedad de que la pila TLS descifra y comprueba los datos entrantes antes de que se devuelvan en la estructura de paquetes.</span><span class="sxs-lookup"><span data-stu-id="a894b-315">Like the TLS Session send, this service is identical in use to _\*_nx_tcp_socket_receive_\*\*, except that the incoming data is decrypted and verified by the TLS stack before being returned in the packet structure.</span></span>

### <a name="tls-session-close"></a><span data-ttu-id="a894b-316">Cierre de sesión de TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-316">TLS Session Close</span></span>

<span data-ttu-id="a894b-317">Una vez completada una sesión de TLS, tanto el cliente como el servidor TLS deben enviar una alerta CloseNotify al otro lado para cerrar la sesión.</span><span class="sxs-lookup"><span data-stu-id="a894b-317">Once a TLS session is complete, both the TLS client and server must send a CloseNotify alert to the other side to shut down the session.</span></span> <span data-ttu-id="a894b-318">Ambos lados deben recibir y procesar la alerta para asegurarse de que el cierre de sesión se ha realizado correctamente.</span><span class="sxs-lookup"><span data-stu-id="a894b-318">Both sides must receive and process the alert to ensure a successful session shutdown.</span></span>

<span data-ttu-id="a894b-319">Si el host remoto envía una alerta CloseNotify, todas las llamadas al servicio ***nx_secure_tls_session_receive** _ procesarán la alerta, enviarán de nuevo la alerta correspondiente al host remoto y devolverán un valor de _*_NX_SECURE_TLS_SESSION_CLOSED_\*\*.</span><span class="sxs-lookup"><span data-stu-id="a894b-319">If the remote host sends a CloseNotify alert, any calls to the ***nx_secure_tls_session_receive** _ service will process the alert, send the corresponding alert back to the remote host, and return a value of _*_NX_SECURE_TLS_SESSION_CLOSED_\*\*.</span></span> <span data-ttu-id="a894b-320">Una vez cerrada la sesión, se producirá un error en cualquier intento adicional de enviar o recibir datos con esa sesión de TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-320">Once the session is closed, any further attempts to send or receive data with that TLS session will fail.</span></span>

<span data-ttu-id="a894b-321">Si la aplicación desea cerrar la sesión de TLS, se debe llamar al servicio \***nx_secure_tls_session_end** _.</span><span class="sxs-lookup"><span data-stu-id="a894b-321">If the application wishes to close the TLS session, the \***nx_secure_tls_session_end** _ service must be called.</span></span> <span data-ttu-id="a894b-322">El servicio enviará la alerta CloseNotify y procesará la respuesta CloseNotify.</span><span class="sxs-lookup"><span data-stu-id="a894b-322">The service will send the CloseNotify alert and process the response CloseNotify.</span></span> <span data-ttu-id="a894b-323">Si no se recibe la respuesta, se devolverá un valor de error de _ \*_NX_SECURE_TLS_SESSION_CLOSE_FAIL_\*\*, lo que indica que la sesión de TLS no se apagó correctamente y puede indicar una posible infracción de seguridad.</span><span class="sxs-lookup"><span data-stu-id="a894b-323">If the response is not received, an error value of _ *_NX_SECURE_TLS_SESSION_CLOSE_FAIL_*\* will be returned, indicating that the TLS session was not cleanly shutdown, a possible security breach.</span></span>

### <a name="tls-alerts"></a><span data-ttu-id="a894b-324">Alertas TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-324">TLS Alerts</span></span>

<span data-ttu-id="a894b-325">TLS está diseñado para proporcionar la máxima seguridad, por lo que cualquier comportamiento errante en el protocolo se considera una posible infracción de seguridad.</span><span class="sxs-lookup"><span data-stu-id="a894b-325">TLS is designed to provide maximum security, so any errant behavior in the protocol is considered a potential security breach.</span></span> <span data-ttu-id="a894b-326">Por esta razón, los errores en el procesamiento de mensajes o el cifrado y descifrado se consideran errores irrecuperables que finalizan la sesión o el protocolo de enlace inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="a894b-326">For this reason, any errors in message processing or encryption/decryption are considered fatal errors that terminate the handshake or session immediately.</span></span>

<span data-ttu-id="a894b-327">Aunque el control de errores en una aplicación local es relativamente sencillo, el host remoto debe saber que se ha producido un error con el fin de controlar correctamente la situación y evitar posibles infracciones de seguridad.</span><span class="sxs-lookup"><span data-stu-id="a894b-327">While handling errors in a local application is relatively straightforward, the remote host needs to know that an error has occurred in order to properly handle the situation and prevent any further possible security breaches.</span></span> <span data-ttu-id="a894b-328">Por esta razón, DTLS enviará un mensaje de *alerta* al host remoto en caso de error.</span><span class="sxs-lookup"><span data-stu-id="a894b-328">For this reason, TLS will send an *Alert* message to the remote host upon any error.</span></span>

<span data-ttu-id="a894b-329">Las alertas se tratan de la misma manera que cualquier otro mensaje de TLS y se cifran durante la sesión para impedir que un atacante recopile información del tipo de alerta proporcionado.</span><span class="sxs-lookup"><span data-stu-id="a894b-329">Alerts are treated in the same manner as any other TLS messages and are encrypted during the session to prevent an attacker from gathering information from the type of alert provided.</span></span> <span data-ttu-id="a894b-330">Durante el protocolo de enlace, el ámbito de las alertas enviadas está limitado para controlar la cantidad de información que podría obtener un atacante potencial.</span><span class="sxs-lookup"><span data-stu-id="a894b-330">During the handshake, the alerts sent are limited in scope to limit the amount of information that could be obtained by a potential attacker.</span></span>

<span data-ttu-id="a894b-331">La alerta CloseNotify, que se usa para cerrar la sesión de TLS, es la única alerta no grave.</span><span class="sxs-lookup"><span data-stu-id="a894b-331">The CloseNotify alert, used to close the TLS session, is the only non-fatal alert.</span></span> <span data-ttu-id="a894b-332">Aunque se considera una alerta y se envía como un mensaje de alerta, CloseNotify es diferente de otras alertas, ya que no indica que se ha producido un error.</span><span class="sxs-lookup"><span data-stu-id="a894b-332">While it is considered an alert and sent as an alert message, a CloseNotify is unlike other alerts in that it does not indicate an error has occurred.</span></span>

<span data-ttu-id="a894b-333">El valor y el “nivel” de la alerta (los niveles son “advertencia” y “irrecuperable”; la mayoría de las alertas de TLS de nivel “irrecuperable”) se definen en las RFC de TLS e indican el tipo de error que se ha producido.</span><span class="sxs-lookup"><span data-stu-id="a894b-333">The alert value and "level" (levels are "warning" and "fatal" – most TLS alerts are "fatal") are defined in the TLS RFCs and indicate the type of error that occurred.</span></span> <span data-ttu-id="a894b-334">La mayoría de las alertas de TLS distintas de CloseNotify se pueden considerar como la indicación de un posible problema de seguridad y dará como resultado la anulación de la sesión o del protocolo de enlace TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-334">Most TLS Alerts other than CloseNotify can be considered an indication of a potential security issue and will result in the TLS session or handshake being aborted.</span></span> <span data-ttu-id="a894b-335">Si alguna llamada a la API de TLS devuelve **NX_SECURE_TLS_ALERT_RECEIVED** (0x114), se puede usar el servicio **_nx_secure_tls_session_alert_value_get_** de la API (nuevo en la versión 5.12 de TLS en NetX Secure) para recuperar el valor de alerta de TLS y el nivel de la aplicación que se va a usar para cualquier decisión relativa a las respuestas a los problemas de seguridad.</span><span class="sxs-lookup"><span data-stu-id="a894b-335">If any TLS API call returns **NX_SECURE_TLS_ALERT_RECEIVED** (0x114), the API service **_nx_secure_tls_session_alert_value_get_** (new in NetX Secure TLS version 5.12) may be used to retrieve the TLS alert value and level for the application to use for any decisions regarding responses to security issues.</span></span> <span data-ttu-id="a894b-336">En la mayoría de los casos, cualquier alerta recibida desde el host remoto que no sea CloseNotify debe considerarse un error irrecuperable, aunque hay algunas excepciones (consulte las RFC de TLS para obtener más información).</span><span class="sxs-lookup"><span data-stu-id="a894b-336">In most cases, any alert received from the remote host other than CloseNotify should be considered a fatal error, though there are some excptions – see the TLS RFCs for more information.</span></span>

### <a name="tls-session-renegotiation"></a><span data-ttu-id="a894b-337">Renegociación de sesión TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-337">TLS Session Renegotiation</span></span>

<span data-ttu-id="a894b-338">TLS admite la noción de “renegociación”, que es simplemente una renegociación de los parámetros de sesión de TLS en el contexto de una sesión de TLS existente.</span><span class="sxs-lookup"><span data-stu-id="a894b-338">TLS supports the notion of "renegotiation" which is simply a renegotiation of the TLS session parameters within the context of an existing TLS session.</span></span> <span data-ttu-id="a894b-339">Esto significa que, en la práctica, los nuevos mensajes de protocolo de enlace se cifran y se autentican mediante la sesión existente.</span><span class="sxs-lookup"><span data-stu-id="a894b-339">What this means in practice is that the new handshake messages are encrypted and authenticated using the existing session.</span></span> <span data-ttu-id="a894b-340">La renegociación se usa cuando un host de TLS desea generar nuevos parámetros de sesión (por ejemplo, generar nuevas claves de sesión de TLS) sin tener que completar la sesión existente.</span><span class="sxs-lookup"><span data-stu-id="a894b-340">Renegotiation is used when a TLS host wants to generate new session parameters (e.g. generate new TLS session keys) without having to complete the existing session.</span></span> <span data-ttu-id="a894b-341">Por ejemplo, la renegociación puede ser deseable cuando las directivas de seguridad de una aplicación dictan que las claves de sesión solo se usan durante un tiempo limitado, pero una sesión de TLS permanece activa más allá de ese tiempo.</span><span class="sxs-lookup"><span data-stu-id="a894b-341">For example, renegotiation may be desirable when security policies for an application dictate that session keys are only used for a limited time but a TLS session remains active beyond that time.</span></span>

<span data-ttu-id="a894b-342">Un problema con la renegociación de la sesión es que hace que TLS sea vulnerable a un ataque específico de tipo “Man in the Middle”, en el que un atacante puede convencer a un servidor para que inicie una renegociación con nuevos parámetros, lo que permite al atacante secuestrar la sesión de TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-342">One issue with session renegotiation is that is makes TLS vulnerable to a specific Man-in-the-Middle attack where an attacker can convince a server to initiate a renegotiation with new parameters, thus allowing the attacker to hijack the TLS session.</span></span> <span data-ttu-id="a894b-343">Para mitigar este problema, se ha introducido la extensión de indicación de renegociación segura (consulte la sección **Error! Reference source not found.**</span><span class="sxs-lookup"><span data-stu-id="a894b-343">To mitigate this issue, the Secure Renegotiation Indication extension was introduced (see section **Error! Reference source not found.**</span></span> <span data-ttu-id="a894b-344">).</span><span class="sxs-lookup"><span data-stu-id="a894b-344">section).</span></span>

<span data-ttu-id="a894b-345">El servicio TLS de NetX Secure admite por completo la renegociación de la sesión y la extensión de indicación de renegociación segura.</span><span class="sxs-lookup"><span data-stu-id="a894b-345">NetX Secure TLS completely supports session renegotiation and the Secure Renegotiation Indication extension.</span></span>

<span data-ttu-id="a894b-346">Al recibir datos de un host remoto, las renegociaciones (y su extensión) se administran automáticamente sin la interacción de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="a894b-346">When receiving data from a remote host, renegotations (and the extension) are handled automatically without application interaction.</span></span> <span data-ttu-id="a894b-347">Si se desea recibir notificaciones sobre renegociaciones de sesión, se puede proporcionar una devolución de llamada de renegociación con el servicio *nx_secure_tls_session_renegotiate_callback_set*.</span><span class="sxs-lookup"><span data-stu-id="a894b-347">If notification about session renegotiations is desired, a renegotiation callback may be supplied with the *nx_secure_tls_session_renegotiate_callback_set* service.</span></span> <span data-ttu-id="a894b-348">La devolución de llamada se invocará siempre que el host remoto solicite una renegociación, lo que permite que la aplicación tome medidas si se desea.</span><span class="sxs-lookup"><span data-stu-id="a894b-348">The callback will be invoked whenever a renegotiation is requested by the remote host, allowing the application to take action if desired.</span></span>

<span data-ttu-id="a894b-349">Para iniciar una renegociación desde una sesión de TLS activa, basta con invocar el servicio *nx_secure_tls_session_renegotiate* en la sesión de TLS deseada.</span><span class="sxs-lookup"><span data-stu-id="a894b-349">To initiate a renegotiation from an active TLS session, simply invoke the *nx_secure_tls_session_renegotiate* service on the desired TLS session.</span></span>

### <a name="tls-session-resumption"></a><span data-ttu-id="a894b-350">Reanudación de la sesión TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-350">TLS Session Resumption</span></span>

<span data-ttu-id="a894b-351">A pesar de tener ciertas similitudes, la reanudación de la sesión TLS no se debe confundir con la renegociación de la sesión.</span><span class="sxs-lookup"><span data-stu-id="a894b-351">TLS session resumption should not be confused with session renegotiation, despite some similarities.</span></span> <span data-ttu-id="a894b-352">En los casos en que la *renegociación* de la sesión implica iniciar un nuevo protocolo de enlace dentro de una sesión de TLS existente, la *reanudación* de la sesión es una característica puramente opcional que implica el reinicio de una sesión de TLS cerrada sin necesidad de realizar un protocolo de enlace TLS completo.</span><span class="sxs-lookup"><span data-stu-id="a894b-352">Where session *renegotiation* involves starting a new handshake within an existing TLS session, session *resumption* is a purely optional feature that involves restarting a closed TLS session without performing a complete TLS handshake.</span></span> <span data-ttu-id="a894b-353">Para ello, una implementación de TLS puede almacenar en caché los parámetros y las claves de la sesión, asociarlos con un *identificador de sesión* (un identificador único proporcionado en el protocolo de enlace original).</span><span class="sxs-lookup"><span data-stu-id="a894b-353">To achieve this, a TLS implementation may cache the session parameters and keys, associating them with a *session ID,* a unique identifier supplied in the original handshake.</span></span> <span data-ttu-id="a894b-354">Al proporcionar un identificador de sesión a un servidor TLS, un cliente indica que existía una sesión de TLS anterior entre los hosts y finalizó en el pasado, y que el cliente todavía posee el estado para volver a establecer la sesión con un protocolo de enlace reducido.</span><span class="sxs-lookup"><span data-stu-id="a894b-354">By supplying a session ID to a TLS server, a client indicates that a previous TLS session between the hosts existed and completed some time in the past, and that the client still possesses the state to re-establish the session with a reduced handshake.</span></span> <span data-ttu-id="a894b-355">Puesto que las claves de sesión en teoría son secretas y solo las conocen los dos hosts que se comunican, el servidor puede iniciar una nueva sesión de TLS y omitir la mayor parte del protocolo de enlace normal.</span><span class="sxs-lookup"><span data-stu-id="a894b-355">Since the session keys are theoretically still secret and only known by the two communicating host, the server can start a new TLS session and bypass most of the normal handshake.</span></span>

<span data-ttu-id="a894b-356">La reanudación de la sesión puede ser útil para evitar las operaciones de clave pública potencialmente costosas utilizadas para compartir el secreto maestro de generación de claves y comprobar las firmas de certificado, pero también requiere que el estado de los parámetros de sesión, las claves y el conjunto de cifrado se conserven en la memoria para todas las sesiones posibles (al menos para una ventana de tiempo configurable).</span><span class="sxs-lookup"><span data-stu-id="a894b-356">Session resumption can be useful to avoid the potentially expensive public-key operations used to share the key generation master secret and verify certificate signatures, but it also requires that the session parameters, keys, and crypotgraphic state be maintained in memory for all possible sessions (at least for a configurable time window).</span></span>

<span data-ttu-id="a894b-357">La versión actual del servicio TLS de NetX Secure no admite la reanudación de la sesión: los servidores TLS simplemente omiten el identificador de sesión y los clientes TLS siempre proporcionan un identificador de sesión NULL que solicita al servidor que realice un protocolo de enlace completo.</span><span class="sxs-lookup"><span data-stu-id="a894b-357">The current version of NetX Secure TLS does not support session resumption – the session ID is simply ignored by TLS servers and TLS clients always supply a NULL session ID which prompts the server to perform a complete handshake.</span></span> <span data-ttu-id="a894b-358">La falta de reanudación de la sesión no debe provocar problemas de interoperabilidad, ya que es una característica completamente opcional y todas las implementaciones de TLS deben tener como valor predeterminado un protocolo de enlace completo si el identificador de sesión es NULL o no se reconoce.</span><span class="sxs-lookup"><span data-stu-id="a894b-358">The lack of session resumption should cause no inter-operability issues as it is a completely optional feature and all TLS implementations must default to a complete handshake should the session ID be NULL or unrecognized.</span></span>

### <a name="protocol-layering"></a><span data-ttu-id="a894b-359">Capas de protocolo</span><span class="sxs-lookup"><span data-stu-id="a894b-359">Protocol Layering</span></span>

<span data-ttu-id="a894b-360">El protocolo TLS encaja en la pila de red entre la capa de transporte (por ejemplo, TCP) y la capa de aplicación.</span><span class="sxs-lookup"><span data-stu-id="a894b-360">The TLS protocol fits into the networking stack between the transport layer (e.g. TCP) and the application layer.</span></span> <span data-ttu-id="a894b-361">TLS se considera a veces un protocolo de capa de transporte (de ahí su nombre: seguridad de la *capa de transporte*), pero dado que actúa como una aplicación con respecto a los protocolos de red subyacentes (como TCP), a veces se agrupa en la capa de aplicación.</span><span class="sxs-lookup"><span data-stu-id="a894b-361">TLS is sometimes considered a transport-layer protocol (hence *Transport Layer* Security) but because it acts as an application with regard to the underlying network protocols (such as TCP) it is sometimes grouped into the application layer.</span></span>

<span data-ttu-id="a894b-362">TLS requiere un protocolo de capa de transporte que admita la entrega en orden y sin pérdidas, como TCP.</span><span class="sxs-lookup"><span data-stu-id="a894b-362">TLS requires a transport layer protocol that supports in-order and lossless delivery, such as TCP.</span></span> <span data-ttu-id="a894b-363">Debido a este requisito, no se puede ejecutar TLS sobre UDP, ya que UDP no garantiza la entrega de datagramas.</span><span class="sxs-lookup"><span data-stu-id="a894b-363">Due to this requirement, TLS cannot run on top of UDP since UDP does not guarantee delivery of datagrams.</span></span> <span data-ttu-id="a894b-364">*DTLS* (versión modificada de TLS) es un protocolo independiente que se utiliza para las aplicaciones que necesitan la seguridad de TLS a través de un protocolo de datagramas como UDP.</span><span class="sxs-lookup"><span data-stu-id="a894b-364">A separate protocol called *DTLS,* which is a modified version of TLS, is used for applications that need the security of TLS over a datagram protocol like UDP.</span></span> <span data-ttu-id="a894b-365">NetX Secure es compatible con DTLS, pero la documentación de DTLS se proporciona en otro documento, no en este.</span><span class="sxs-lookup"><span data-stu-id="a894b-365">NetX Secure supports DTLS, but documentation for DTLS is separate from this document.</span></span>

![Diagrama de capas de protocolo TCP/IP y TLS.](media/image6.png)

<span data-ttu-id="a894b-367">Figura 5: Diagrama de capas de protocolo TCP/IP y TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-367">Figure 5- TCP/IP and TLS protocol layers</span></span>

## <a name="network-communications-security"></a><span data-ttu-id="a894b-368">Seguridad de las comunicaciones de red</span><span class="sxs-lookup"><span data-stu-id="a894b-368">Network Communications Security</span></span>

<span data-ttu-id="a894b-369">La protección de las comunicaciones a través de redes públicas e Internet es un tema muy importante y es protagonista de una gran cantidad de libros, artículos y soluciones.</span><span class="sxs-lookup"><span data-stu-id="a894b-369">Securing communications over public networks and the Internet is a critically important topic and the subject of vast numbers of books, articles, and solutions.</span></span> <span data-ttu-id="a894b-370">El tema es el increíblemente complejo, pero se puede reducir a una idea sencilla: enviar información a través de una red para que solo el destinatario previsto pueda acceder a la información o cambiarla.</span><span class="sxs-lookup"><span data-stu-id="a894b-370">The topic is mind-bogglingly complex, but can be reduced to a simple idea: sending information over a network so that only the intended target can access or change that information.</span></span> <span data-ttu-id="a894b-371">Esto se divide en tres conceptos importantes: confidencialidad, integridad y autenticación.</span><span class="sxs-lookup"><span data-stu-id="a894b-371">This breaks down into three important concepts: secrecy, integrity, and authentication.</span></span> <span data-ttu-id="a894b-372">El protocolo TLS proporciona soluciones para los tres.</span><span class="sxs-lookup"><span data-stu-id="a894b-372">The TLS protocol provides solutions for all three.</span></span>

### <a name="secrecy"></a><span data-ttu-id="a894b-373">Confidencialidad</span><span class="sxs-lookup"><span data-stu-id="a894b-373">Secrecy</span></span>

<span data-ttu-id="a894b-374">Cuando se envían datos a través de una red, a menudo es importante que una entidad malintencionada no pueda obtenerlos.</span><span class="sxs-lookup"><span data-stu-id="a894b-374">When sending data over a network, it is often important that the data cannot be obtained by a malicious entity.</span></span> <span data-ttu-id="a894b-375">Si los datos se envían a través de una conexión TCP/IP, cualquier usuario con acceso a la red podrá leer esos datos mediante herramientas de red fácilmente disponibles.</span><span class="sxs-lookup"><span data-stu-id="a894b-375">If data is sent over a TCP/IP connection, anyone with access to the network will be able to read that data using easily-available networking tools.</span></span> <span data-ttu-id="a894b-376">Para evitar que se obtengan datos, se debe codificar de forma que únicamente se puedan leer en el destino previsto; se debe garantizar la *confidencialidad.*</span><span class="sxs-lookup"><span data-stu-id="a894b-376">To prevent that data from being obtained, it must be encoded such that it cannot be read except by the intended target – this is *secrecy.*</span></span> <span data-ttu-id="a894b-377">En TLS, los algoritmos de cifrado, como RSA y AES, proporcionan confidencialidad.</span><span class="sxs-lookup"><span data-stu-id="a894b-377">In TLS, encryption algorithms such as RSA and AES provide secrecy.</span></span>

### <a name="integrity"></a><span data-ttu-id="a894b-378">Integridad</span><span class="sxs-lookup"><span data-stu-id="a894b-378">Integrity</span></span>

<span data-ttu-id="a894b-379">A veces, la confidencialidad no es suficiente para proteger los datos que viajan a través de una red.</span><span class="sxs-lookup"><span data-stu-id="a894b-379">Sometimes, secrecy is not enough to protect data travelling over a network.</span></span> <span data-ttu-id="a894b-380">En algunos casos, una entidad malintencionada puede llegar a modificar el contenido de un paquete TCP sin necesidad de saber lo que contiene el paquete.</span><span class="sxs-lookup"><span data-stu-id="a894b-380">In some cases, it may be possible for a malicious entity to alter the contents of a TCP packet without needing to know what that packet contains.</span></span> <span data-ttu-id="a894b-381">Es posible modificar los datos cifrados anulando el descifrado o cambiando los parámetros del mensaje para que el atacante pueda conseguir lo que le interesa.</span><span class="sxs-lookup"><span data-stu-id="a894b-381">Encrypted data can be altered, rendering the decryption invalid or changing the parameters of the message leading to whatever result the attacker may be interested in achieving.</span></span> <span data-ttu-id="a894b-382">En la red, no podemos evitar que un atacante cambie los datos en tránsito, pero podemos proporcionar un mecanismo para saber si los datos han cambiado o no.</span><span class="sxs-lookup"><span data-stu-id="a894b-382">On the network, we cannot prevent an attacker from changing data in transit, but we can provide a mechanism to know whether or not the data has been changed.</span></span> <span data-ttu-id="a894b-383">Si se cambian los datos en tránsito, lo sabremos y podremos rechazar los datos.</span><span class="sxs-lookup"><span data-stu-id="a894b-383">When data is changed in transit, it will be known and the data can be rejected.</span></span> <span data-ttu-id="a894b-384">Este concepto se denomina *integridad*.</span><span class="sxs-lookup"><span data-stu-id="a894b-384">This concept is *integrity*.</span></span> <span data-ttu-id="a894b-385">En TLS, la integridad se proporciona mediante una clase de rutinas criptográficas conocidas como *funciones hash*.</span><span class="sxs-lookup"><span data-stu-id="a894b-385">In TLS, integrity is provided by a class of cryptographic routines known as *hash functions*.</span></span> <span data-ttu-id="a894b-386">Algunos ejemplos de funciones hash son MD5 y SHA-1.</span><span class="sxs-lookup"><span data-stu-id="a894b-386">Some examples of hash functions are MD5 and SHA-1.</span></span>

### <a name="authentication"></a><span data-ttu-id="a894b-387">Authentication</span><span class="sxs-lookup"><span data-stu-id="a894b-387">Authentication</span></span>

<span data-ttu-id="a894b-388">El tercer concepto importante en la seguridad de las comunicaciones de red es la idea de que los datos solo deben comunicarse con el destino previsto.</span><span class="sxs-lookup"><span data-stu-id="a894b-388">The third important concept in network communications security is the idea that data should only be communicated to the intended target.</span></span> <span data-ttu-id="a894b-389">Un atacante puede intentar hacerse pasar por una entidad legítima para recibir los datos destinados a otro host.</span><span class="sxs-lookup"><span data-stu-id="a894b-389">An attacker may attempt to pose as a legitimate entity to receive data intended for another host.</span></span> <span data-ttu-id="a894b-390">Incluso si los datos se envían con mecanismos de confidencialidad e integridad implementados, es posible que el atacante siga pudiendo conseguir el resultado deseado (poner en riesgo las comunicaciones seguras) a través de este proceso.</span><span class="sxs-lookup"><span data-stu-id="a894b-390">Even if the data is being sent with secrecy and integrity mechanisms in place, the attacker may still be able to achieve the desired result (a compromise of secure communications) through this deception.</span></span> <span data-ttu-id="a894b-391">Para evitarlo, es necesario un mecanismo para demostrar la identidad de un host remoto antes de que se envíen datos confidenciales.</span><span class="sxs-lookup"><span data-stu-id="a894b-391">To prevent this, a mechanism is needed to prove the identity of a remote host before any sensitive data is sent.</span></span> <span data-ttu-id="a894b-392">El proceso de comprobación de la identidad de un host remoto recibe el nombre de *autenticación.*</span><span class="sxs-lookup"><span data-stu-id="a894b-392">The process of proving the identity of a remote host is *authentication.*</span></span> <span data-ttu-id="a894b-393">En TLS, la autenticación se proporciona mediante certificados digitales, funciones hash y un mecanismo denominado *firmas digitales* que utiliza una propiedad de cifrado de clave pública (se describe a continuación).</span><span class="sxs-lookup"><span data-stu-id="a894b-393">In TLS, authentication is provided using digital certificates, hash functions, and a mechanism called *digital signatures* which utilizes a property of public-key encryption (described below).</span></span> <span data-ttu-id="a894b-394">También se puede proporcionar una forma limitada pero útil de autenticación con una *clave precompartida* (PSK).</span><span class="sxs-lookup"><span data-stu-id="a894b-394">A limited but useful form of authentication can also be provided with a *pre-shared key* (PSK).</span></span>

## <a name="tls-encryption"></a><span data-ttu-id="a894b-395">Cifrado TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-395">TLS Encryption</span></span>

<span data-ttu-id="a894b-396">El protocolo TLS es un marco para proporcionar comunicaciones de red seguras a través de Internet con cifrado.</span><span class="sxs-lookup"><span data-stu-id="a894b-396">The TLS protocol is a framework for providing secure network communications over the Internet utilizing encryption.</span></span> <span data-ttu-id="a894b-397">Normalmente, el cifrado se define como el proceso de codificación de datos de tal forma que la obtención de los datos originales (o la información sobre esos datos) resulte excesivamente difícil sin una *clave*.</span><span class="sxs-lookup"><span data-stu-id="a894b-397">Encryption is generally defined as the process of encoding data in such a way that obtaining the original data (or information about that data) is exceedingly difficult without a *key*.</span></span> <span data-ttu-id="a894b-398">En, el cifrado de sistemas se basa en cálculos matemáticos complejos, como campos finitos, y se puede clasificar en dos tipos: *clave privada* (o *cifrado simétrico*) y *clave pública* (o *cifrado asimétrico*).</span><span class="sxs-lookup"><span data-stu-id="a894b-398">In computer systems encryption is based on complex mathematics such as finite fields and can be classified into two types: *private key* (or *symmetric encryption*) and *public key* (or *asymmetric encryption*).</span></span> <span data-ttu-id="a894b-399">Los ejemplos de cifrado de clave privada son AES (Estándar de cifrado avanzado) y RC4 (Cifrado de Rivest 4).</span><span class="sxs-lookup"><span data-stu-id="a894b-399">Examples of private key encryption are AES (Advanced Encryption Standard) and RC4 (Rivest Cipher 4).</span></span> <span data-ttu-id="a894b-400">Los cifrados RSA (Rivest, Shamir, Adleson) y Diffie-Hellman son ejemplos de cifrado de clave pública.</span><span class="sxs-lookup"><span data-stu-id="a894b-400">Examples of public-key encryption are the RSA (Rivest, Shamir, Adleson) and Diffie-Hellman ciphers.</span></span>

<span data-ttu-id="a894b-401">El protocolo TLS usa las rutinas de cifrado de clave privada y de clave pública para proporcionar un equilibrio entre rendimiento, seguridad y flexibilidad.</span><span class="sxs-lookup"><span data-stu-id="a894b-401">The TLS protocol makes use of both private key and public key encryption routines to provide a balance of performance, security, and flexibility.</span></span>

### <a name="private-key-encryption"></a><span data-ttu-id="a894b-402">Cifrado de clave privada</span><span class="sxs-lookup"><span data-stu-id="a894b-402">Private-Key Encryption</span></span>

<span data-ttu-id="a894b-403">El cifrado de clave privada se lleva usando miles de años.</span><span class="sxs-lookup"><span data-stu-id="a894b-403">Private-key encryption has been in use for thousands of years.</span></span> <span data-ttu-id="a894b-404">Los cifrados de sustitución básicos (donde una letra o una palabra se sustituye por otra letra o palabra no relacionada) son los ejemplos más antiguos conocidos de cifrado, pero con la llegada de la era de la información, el cifrado de claves privadas ha mejorado considerablemente.</span><span class="sxs-lookup"><span data-stu-id="a894b-404">Basic substitution ciphers (where a letter or word is replaced by another unrelated letter or word) are the earliest known examples of encryption, but with the advent of the information age private key encryption has significantly improved.</span></span>

<span data-ttu-id="a894b-405">Un cifrado de clave privada usa una “clave”, que es simplemente un valor (podría ser una palabra, una frase o un número en el caso general) que se usa para codificar de alguna manera ciertos datos de modo que solo una entidad que tenga acceso a esa clave pueda descodificarlos para obtener su significado.</span><span class="sxs-lookup"><span data-stu-id="a894b-405">A private key cipher uses a "key" which is simply a value (which could be a word, phrase, or number in the general case) that is used to somehow encode some data so that only an entity that had access to that key could decode the data in a meaningful way.</span></span> <span data-ttu-id="a894b-406">La clave se usa para el cifrado y descifrado de los datos, de ahí que también reciba el nombre de *cifrado simétrico*.</span><span class="sxs-lookup"><span data-stu-id="a894b-406">The key is used for both encryption and decryption of the data, hence the other name *symmetric encryption*.</span></span>

<span data-ttu-id="a894b-407">Los cifrados de clave privada suelen ser rápidos y fáciles de implementar, incluso si los cálculos matemáticos implicados son demasiado complejos.</span><span class="sxs-lookup"><span data-stu-id="a894b-407">Private key ciphers are generally fast and fairly simple to implement, even if the mathematics involved are exceedingly complex.</span></span> <span data-ttu-id="a894b-408">Por esta razón, TLS utiliza cifrados de clave privada para la mayor parte de las comunicaciones seguras.</span><span class="sxs-lookup"><span data-stu-id="a894b-408">For this reason, TLS uses private key ciphers for the bulk of secure communications.</span></span>

<span data-ttu-id="a894b-409">Sin embargo, el cifrado de clave privada tiene un problema cuando se intenta aplicar a las comunicaciones de red de equipos generales: la clave debe compartirse entre los equipos que intentan comunicarse.</span><span class="sxs-lookup"><span data-stu-id="a894b-409">However, private key encryption has a problem when we try to apply it to general computer network communications: the key must be shared between both machines trying to communicate.</span></span> <span data-ttu-id="a894b-410">En general, esto no resulta práctico y a menudo no es posible comunicar una clave privada de forma segura entre dos equipos en Internet, ya que se puede suponer que el tráfico de la red puede ser obtenido por cualquier número de entidades en los diversos saltos que toman los datos al ser enrutados a través de Internet.</span><span class="sxs-lookup"><span data-stu-id="a894b-410">In the general case, it is impractical and often impossible to communicate a private key securely between two machines on the Internet, as it can be assumed that the network traffic can be obtained by any number of entities in the various hops that data takes when being routed through the Internet.</span></span> <span data-ttu-id="a894b-411">Si una entidad malintencionada obtiene la clave, se pone en peligro todos los datos cifrados con esa clave.</span><span class="sxs-lookup"><span data-stu-id="a894b-411">If the key is obtained by a malicious entity, all data encrypted using that key is compromised.</span></span> <span data-ttu-id="a894b-412">Como la mayoría de los equipos en Internet solo tienen una conexión de red y no otro canal seguro para las comunicaciones, el envío de claves a través de la red equivale a enviar los datos sin cifrar: no proporciona seguridad.</span><span class="sxs-lookup"><span data-stu-id="a894b-412">As most machines on the Internet have only a network connection and not another secure channel for communications, sending keys over the network is tantamount to sending the data unencrypted – it provides no security.</span></span>

<span data-ttu-id="a894b-413">Por esta razón, el cifrado de clave privada no basta para implementar un protocolo de seguridad de comunicaciones de red de uso general.</span><span class="sxs-lookup"><span data-stu-id="a894b-413">For this reason, private key encryption is not sufficient to implement a general-purpose network communications security protocol.</span></span> <span data-ttu-id="a894b-414">Aquí es donde el cifrado de clave pública es de ayuda.</span><span class="sxs-lookup"><span data-stu-id="a894b-414">This is where Public Key encryption can help.</span></span>

<span data-ttu-id="a894b-415">El servicio TLS de NetX Secure es compatible con el cifrado de clave privada AES.</span><span class="sxs-lookup"><span data-stu-id="a894b-415">NetX Secure TLS supports AES private-key encryption.</span></span>

### <a name="public-key-encryption"></a><span data-ttu-id="a894b-416">Cifrado de clave pública</span><span class="sxs-lookup"><span data-stu-id="a894b-416">Public-Key Encryption</span></span>

<span data-ttu-id="a894b-417">A diferencia del cifrado de clave privada, el cifrado de clave pública es un concepto bastante nuevo que se desarrolló en los de 1970.</span><span class="sxs-lookup"><span data-stu-id="a894b-417">Unlike private key encryption, public key encryption is a fairly new concept, having been developed in the 1970's.</span></span> <span data-ttu-id="a894b-418">Mediante el uso de un concepto matemático conocido como “funciones de trampilla”, se descubrió que había una manera de compartir una clave a través de una red sin poner en peligro la seguridad de los datos cifrados.</span><span class="sxs-lookup"><span data-stu-id="a894b-418">Using a concept known as "trap-door functions" in mathematics, it was discovered that there was a way to share a key over a network without compromising the security of then encrypted data.</span></span>

<span data-ttu-id="a894b-419">El cifrado de clave pública funciona de la siguiente manera: la clave (en el sentido de cifrado de clave privada descrito anteriormente) se divide en dos partes, una *clave privada* y una *clave pública* (de aquí viene el nombre de cifrado de clave pública).</span><span class="sxs-lookup"><span data-stu-id="a894b-419">The way public key encryption works is that the key (in the private-key encryption sense described above) is split into two parts, a *private key* and a *public key*, from where public key encryption gets its name.</span></span> <span data-ttu-id="a894b-420">El concepto se basa en que una de estas claves (normalmente, la clave pública) se usa para el cifrado, mientras que la otra se usa para el descifrado.</span><span class="sxs-lookup"><span data-stu-id="a894b-420">The concept is that one of these keys (typically the public key) is used for encryption, while the other is used for decryption.</span></span> <span data-ttu-id="a894b-421">Esta asimetría de claves es el motivo por el que el cifrado de clave pública recibe el nombre de *cifrado asimétrico*.</span><span class="sxs-lookup"><span data-stu-id="a894b-421">This asymmetry of keys is the reason for the other name for public key encryption: *asymmetric encryption*.</span></span>

<span data-ttu-id="a894b-422">Los cálculos matemáticos detrás del cifrado de clave pública son bastante complejos, pero la idea es que la clave pública *solo* se puede usar para el cifrado y la obtención de esa clave no permite obtener datos cifrados.</span><span class="sxs-lookup"><span data-stu-id="a894b-422">The mathematics behind public key encryption are fairly complex, but the idea is that the public key can *only* be used for encryption, and obtaining that key does not allow encrypted data to be obtained.</span></span> <span data-ttu-id="a894b-423">La clave privada, a su vez, es la única manera de descifrar los datos cifrados con la clave pública.</span><span class="sxs-lookup"><span data-stu-id="a894b-423">The private key, in turn, is the only way to decrypt data encrypted using the public key.</span></span> <span data-ttu-id="a894b-424">Por lo tanto, al mantener el secreto de la clave privada, cualquier persona que quiera comunicarse de forma segura con el propietario de esa clave privada solo necesita cifrar sus datos con la clave pública correspondiente y sabrá que solo alguien en posesión de la clave privada podrá obtener los datos seguros.</span><span class="sxs-lookup"><span data-stu-id="a894b-424">Thus, by keeping the private key secret, anyone wishing to communicate securely with the owner of that private key need only encrypt their data with the corresponding public key with the knowledge that only someone in possession of that private key can obtain the secure data.</span></span>

<span data-ttu-id="a894b-425">El servicio TLS de NetX Secure admite el cifrado de clave pública RSA.</span><span class="sxs-lookup"><span data-stu-id="a894b-425">NetX Secure TLS supports RSA public-key encryption.</span></span>

> [!IMPORTANT] 
> <span data-ttu-id="a894b-426">*RSA es una operación que requiere un uso intensivo del procesador si se usa la implementación RSA de software. Los tamaños de clave más grandes aumentan por cuatro la potencia de procesamiento necesaria (4 veces más lento para un aumento del doble en el tamaño de la clave).*</span><span class="sxs-lookup"><span data-stu-id="a894b-426">*RSA is a very processor-intensive operation if the software RSA implementation is used. Larger key sizes increase the processing power required by a square factor – 4X slower for a 2X increase in key size.*</span></span>

### <a name="public-key-authentication"></a><span data-ttu-id="a894b-427">Autenticación de la clave pública</span><span class="sxs-lookup"><span data-stu-id="a894b-427">Public-Key Authentication</span></span>

<span data-ttu-id="a894b-428">Un efecto secundario interesante del concepto de cifrado de clave pública es que se puede usar para proporcionar autenticación y cifrado mediante la operación inversa: cifrado con la clave *privada* y descifrado mediante la clave *pública*.</span><span class="sxs-lookup"><span data-stu-id="a894b-428">An interesting side-effect of the public-key encryption concept is that it can be used to provide authentication as well as encryption by doing the operation in reverse: encrypting using the *private* key and decrypting using the *public* key.</span></span> <span data-ttu-id="a894b-429">El mecanismo real para hacerlo depende del algoritmo de clave pública que se use, pero el concepto es el mismo.</span><span class="sxs-lookup"><span data-stu-id="a894b-429">The actual mechanism for doing this depends on the public key algorithm being used, but the concept is the same.</span></span>

<span data-ttu-id="a894b-430">Para autenticar mediante la autenticación de clave pública, el propietario de una clave privada cifra parte de los datos (normalmente un hash criptográfico de los datos que se van a autenticar) con esa clave privada.</span><span class="sxs-lookup"><span data-stu-id="a894b-430">To authenticate using public key authentication, the owner of a private key encrypts some piece of data (typically a cryptographic hash of the data to be authenticated) using that private key.</span></span> <span data-ttu-id="a894b-431">A continuación, alguien que quiera verificar que los datos provienen del propietario de la clave privada usa la clave pública asociada para descifrar los datos: si el descifrado se realiza correctamente y se asume que el usuario confía en la validez de la clave pública, el usuario puede estar seguro de que los datos proceden del propietario de la clave privada.</span><span class="sxs-lookup"><span data-stu-id="a894b-431">Then, someone wishing to authenticate that the data came from the owner of the private key uses the associated public key to decrypt the data – if the decryption is successful, and assuming the user trusted the validity of that public key, then the user can be certain that the data came from the owner of the private key.</span></span>

<span data-ttu-id="a894b-432">En TLS se usa la autenticación de clave pública para comprobar la validez de un certificado digital proporcionado por un servidor TLS (y, opcionalmente, el cliente TLS) mediante claves públicas del almacén de certificados de confianza.</span><span class="sxs-lookup"><span data-stu-id="a894b-432">In TLS, public key authentication is used to verify the validity of a digital certificate provided by a TLS server (and optionally the TLS client) using public keys from the trusted certificate store.</span></span> <span data-ttu-id="a894b-433">El certificado se comprueba con una clave pública en el almacén y los datos del certificado se usan para comprobar la identidad del servidor.</span><span class="sxs-lookup"><span data-stu-id="a894b-433">The certificate is checked against a public key in the store and the data in the certificate is used to check the identity of the server.</span></span>

<span data-ttu-id="a894b-434">El servicio TLS de NetX Secure es compatible con la autenticación RSA.</span><span class="sxs-lookup"><span data-stu-id="a894b-434">NetX Secure TLS supports RSA authentication.</span></span>

### <a name="cryptographic-hashing"></a><span data-ttu-id="a894b-435">Hash criptográfico</span><span class="sxs-lookup"><span data-stu-id="a894b-435">Cryptographic Hashing</span></span>

<span data-ttu-id="a894b-436">El cifrado no es la única operación criptográfica que se usa en TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-436">Encryption is not the only cryptographic operation used in TLS.</span></span> <span data-ttu-id="a894b-437">Para proporcionar integridad del mensaje durante una sesión de TLS, se necesita una suma de comprobación para garantizar que el contenido del mensaje no se ha alterado.</span><span class="sxs-lookup"><span data-stu-id="a894b-437">In order to provide message integrity during a TLS session, a checksum is needed to ensure that the message contents have not been tampered with.</span></span> <span data-ttu-id="a894b-438">Sin embargo, una suma de comprobación simple (como se usa en TCP) no es suficiente para garantizar un nivel de integridad aceptable, ya que un atacante experto puede subvertirla fácilmente.</span><span class="sxs-lookup"><span data-stu-id="a894b-438">However, a simple checksum (as is used in TCP) is insufficient to guarantee an acceptable level of integrity as it can be easily subverted by a knowledgeable attacker.</span></span> <span data-ttu-id="a894b-439">El mecanismo que usa TLS para proporcionar la integridad del mensaje se conoce como *hash criptográfico*.</span><span class="sxs-lookup"><span data-stu-id="a894b-439">The mechanism used by TLS to provide message integrity is known as a *cryptographic hash*.</span></span>

<span data-ttu-id="a894b-440">El cifrado es una codificación 1:1, es decir, la totalidad de los datos originales se puede obtener a partir de los datos cifrados.</span><span class="sxs-lookup"><span data-stu-id="a894b-440">Encryption is a 1:1 encoding – that is, the entirety of the original data can be obtained from the encrypted data.</span></span> <span data-ttu-id="a894b-441">Sin embargo, un hash asigna una cantidad arbitraria de datos a un valor de tamaño fijo, como una suma de comprobación.</span><span class="sxs-lookup"><span data-stu-id="a894b-441">However, a hash maps an arbitrary amount of data into a fixed size value, just like a checksum.</span></span> <span data-ttu-id="a894b-442">A diferencia de una suma de comprobación simple, un hash se ha diseñado específicamente para reducir las *colisiones*, donde distintos datos de entrada producen el mismo resultado.</span><span class="sxs-lookup"><span data-stu-id="a894b-442">Unlike a simple checksum, a hash is specifically designed to reduce *collisions*, where different input data result in the same output.</span></span> <span data-ttu-id="a894b-443">En una suma de comprobación simple, si un bit se voltea de 1 a 0 y otro bit de 0 a 1, la suma de comprobación es la misma.</span><span class="sxs-lookup"><span data-stu-id="a894b-443">In a simple checksum, if a bit is flipped from 1 to 0 and another bit from 0 to 1, the checksum is the same.</span></span> <span data-ttu-id="a894b-444">Con un hash criptográfico, el resultado sería bastante distinto, y esto haría que para un atacante fuese más difícil cambiar los datos con hash y conseguir que la operación hash de los datos cambiados generase el mismo valor (y, por lo tanto, lograr comprobar la integridad de los datos de forma falsa).</span><span class="sxs-lookup"><span data-stu-id="a894b-444">With a cryptographic hash, the output would differ significantly, making it difficult for an attacker to change the hashed data and have the hash operation on the changed data still result in the same value (and thus falsely verifying the integrity of that data).</span></span>

<span data-ttu-id="a894b-445">TLS usa varios algoritmos hash distintos para proporcionar integridad a los mensajes, tanto a los de la aplicación como a los de control TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-445">TLS uses a number of different hash algorithms to provide integrity for messages, both application messages and TLS control messages.</span></span> <span data-ttu-id="a894b-446">Entre ellos se incluyen MD5, SHA-1 y SHA-256.</span><span class="sxs-lookup"><span data-stu-id="a894b-446">These include MD5, SHA-1 and SHA-256.</span></span>

<span data-ttu-id="a894b-447">El servicio TLS de NetX Secure admite hash MD5, SHA-1 y SHA-256.</span><span class="sxs-lookup"><span data-stu-id="a894b-447">NetX Secure TLS supports MD5, SHA-1, and SHA-256 hashing.</span></span>

## <a name="tls-extensions"></a><span data-ttu-id="a894b-448">Extensiones TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-448">TLS Extensions</span></span>

<span data-ttu-id="a894b-449">TLS incluye una serie de extensiones que ofrecen funcionalidad adicional para ciertas aplicaciones.</span><span class="sxs-lookup"><span data-stu-id="a894b-449">TLS provides a number of extensions that provide additional functionality for certain applications.</span></span> <span data-ttu-id="a894b-450">Normalmente, estas extensiones se envían como parte de los mensajes ClientHello o ServerHello, lo que indica a un host remoto el deseo de usar una extensión o proporciona detalles adicionales para su uso en el establecimiento de la sesión de TLS segura.</span><span class="sxs-lookup"><span data-stu-id="a894b-450">These extensions are typically sent as part of the ClientHello or ServerHello messages, indicating to a remote host the desire to use an extension or providing additional details for use in establishing the secure TLS session.</span></span>

<span data-ttu-id="a894b-451">En general, las extensiones proporcionan parámetros opcionales a TLS al principio del protocolo de enlace que guían las operaciones siguientes.</span><span class="sxs-lookup"><span data-stu-id="a894b-451">In general, extensions provide optional parameters to TLS at the beginning of the handshake that guide the proceeding operations.</span></span> <span data-ttu-id="a894b-452">Algunas extensiones requieren la toma de decisiones o la entrada de la aplicación, mientras que otras se administran automáticamente.</span><span class="sxs-lookup"><span data-stu-id="a894b-452">Some extensions require application input or decision making, while others are handled automatically.</span></span>

<span data-ttu-id="a894b-453">En la tabla siguiente se describen las extensiones TLS compatibles actualmente con el servicio TLS de NetX Secure:</span><span class="sxs-lookup"><span data-stu-id="a894b-453">The following table describes the TLS extensions currently supported by NetX Secure TLS:</span></span>

| <span data-ttu-id="a894b-454">**Extension Name**</span><span class="sxs-lookup"><span data-stu-id="a894b-454">**Extension Name**</span></span>              | <span data-ttu-id="a894b-455">**Descripción**</span><span class="sxs-lookup"><span data-stu-id="a894b-455">**Description**</span></span>              |
| ------------------------------- |----------------------------- |
| <span data-ttu-id="a894b-456">Indicación de renegociación segura</span><span class="sxs-lookup"><span data-stu-id="a894b-456">Secure Renegotiation Indication</span></span> | <span data-ttu-id="a894b-457">Esta extensión mitiga una vulnerabilidad de ataque de tipo “man in the middle” que podría producirse durante un protocolo de enlace de renegociación.</span><span class="sxs-lookup"><span data-stu-id="a894b-457">This extension mitigates a Man-in-the-Middle attack vulnerability that could occur during a renegotiation handshake.</span></span>|
| <span data-ttu-id="a894b-458">Indicación de nombre de servidor</span><span class="sxs-lookup"><span data-stu-id="a894b-458">Server Name Indication</span></span>          | <span data-ttu-id="a894b-459">Esta extensión permite que un cliente TLS proporcione un nombre DNS específico a un servidor TLS, lo que permite al servidor seleccionar las credenciales correctas (supone que el servidor tiene varios certificados de identidad y puntos de entrada de red).</span><span class="sxs-lookup"><span data-stu-id="a894b-459">This extension allows a TLS Client to supply a specific DNS name to a TLS Server, allowing the server to select the correct credentials (assumes the server has multiple identity certificates and network entrypoints).</span></span> |
| <span data-ttu-id="a894b-460">Algoritmos de firma</span><span class="sxs-lookup"><span data-stu-id="a894b-460">Signature Algorithms</span></span>            | <span data-ttu-id="a894b-461">Esta extensión permite a un cliente TLS proporcionar a un servidor TLS una lista de algoritmos de firma y hash aceptables.</span><span class="sxs-lookup"><span data-stu-id="a894b-461">This extension enables a TLS Client to provide a list of acceptable signature and hash algorithms to a TLS Server.</span></span> |

<span data-ttu-id="a894b-462">Información general de las extensiones TLS admitidas</span><span class="sxs-lookup"><span data-stu-id="a894b-462">Overview of supported TLS Extensions</span></span>

### <a name="secure-renegotiation-indication"></a><span data-ttu-id="a894b-463">Indicación de renegociación segura</span><span class="sxs-lookup"><span data-stu-id="a894b-463">Secure Renegotiation Indication</span></span>

<span data-ttu-id="a894b-464">TLS admite la noción de realizar un protocolo de enlace en una sesión de TLS existente y usa la sesión establecida para cifrar los mensajes de protocolo de enlace.</span><span class="sxs-lookup"><span data-stu-id="a894b-464">TLS supports the notion of performing a handshake within an existing TLS session, thereby using the established session to encrypt the handshake messages.</span></span> <span data-ttu-id="a894b-465">Este proceso permite que se vuelvan a establecer las claves de sesión criptográfica sin terminar la sesión de TLS (consulte la sección “Renegociación de sesión TLS”).</span><span class="sxs-lookup"><span data-stu-id="a894b-465">This process allows the cryptographic session keys to be re-established without ending the TLS session (see section "TLS Session Renegotiation").</span></span>

<span data-ttu-id="a894b-466">Lamentablemente, cuando TLS ya llevaba usando la renegociación durante algún tiempo, se descubrió que existía una vulnerabilidad en un ataque de tipo “man in the middle” que aprovechaba la característica de renegociación.</span><span class="sxs-lookup"><span data-stu-id="a894b-466">Unfortunately, after TLS had been using renegotiation for some time, it was discovered that there was a vulnerability to a Man-in-the-Middle attack that exploited the renegotiation feature.</span></span> <span data-ttu-id="a894b-467">Para cerrar la vulnerabilidad, se introdujo la extensión de indicación de renegociación segura.</span><span class="sxs-lookup"><span data-stu-id="a894b-467">To close the vulnerability, the Secure Renegotiation Indication extension was introduced.</span></span> <span data-ttu-id="a894b-468">Esencialmente, la extensión de renegociación segura usa el hash del mensaje Finished de la conexión establecida para comprobar que los hosts originales participan en el protocolo de enlace de renegociación; básicamente, el hash se usa como un token de comprobación bajo el supuesto de que un atacante no podría falsificar el hash (lo que requeriría acceso a las claves de sesión).</span><span class="sxs-lookup"><span data-stu-id="a894b-468">Essentially, the Secure Renegotiation extension uses the Finished message hash from the established connection to verify that the original hosts are participating in the renegotiation handshake – essentially the hash is used as a verification token under the assumption that an attacker would not be able to forge the hash (which would require access to the session keys).</span></span>

<span data-ttu-id="a894b-469">El servicio TLS de NetX Secure controla la renegociación automática y usa la extensión de renegociación segura de forma predeterminada.</span><span class="sxs-lookup"><span data-stu-id="a894b-469">NetX Secure TLS handles renegotiation automatically and uses the Secure Renegotiation Extension by default.</span></span> <span data-ttu-id="a894b-470">No se requiere ninguna interacción con la aplicación.</span><span class="sxs-lookup"><span data-stu-id="a894b-470">No application interaction is required.</span></span>

### <a name="server-name-indication"></a><span data-ttu-id="a894b-471">Indicación de nombre de servidor</span><span class="sxs-lookup"><span data-stu-id="a894b-471">Server Name Indication</span></span>

<span data-ttu-id="a894b-472">Durante el protocolo de enlace TLS, un cliente TLS espera que un servidor remoto proporcione un certificado de identidad para que el cliente pueda autenticar el servidor.</span><span class="sxs-lookup"><span data-stu-id="a894b-472">During the TLS handshake, a TLS Client expects a remote server to provide an identity certificate so the client can authenticate the server.</span></span> <span data-ttu-id="a894b-473">Sin embargo, puede haber algunos casos en los que un servidor ofrezca varios servicios diferentes con servidores “virtuales”, cada uno con identidades únicas.</span><span class="sxs-lookup"><span data-stu-id="a894b-473">However, there may be some cases where a server will provide multiple different services with different "virtual" servers each having unique identities.</span></span> <span data-ttu-id="a894b-474">En el caso de un solo servidor con varias identidades, un cliente TLS puede proporcionar un nombre DNS específico que el servidor usará para seleccionar las credenciales adecuadas; el mecanismo para proporcionar este nombre es la extensión de indicación de nombre de servidor (SNI).</span><span class="sxs-lookup"><span data-stu-id="a894b-474">In the case of a single server with multiple identities, a TLS client can supply a specific DNS name that the server will use to select the proper credentials – the mechanism for supplying this name is the Server Name Indication (SNI) extension.</span></span>

<span data-ttu-id="a894b-475">En las aplicaciones que usan la extensión SNI sí se requiere cierta interacción.</span><span class="sxs-lookup"><span data-stu-id="a894b-475">For an application using the SNI extension, some interaction is required.</span></span> <span data-ttu-id="a894b-476">En el caso de los clientes TLS, la aplicación debe proporcionar un nombre DNS que se enviará al servidor remoto.</span><span class="sxs-lookup"><span data-stu-id="a894b-476">For TLS Clients, the application must supply a DNS name to be sent to the remote server.</span></span> <span data-ttu-id="a894b-477">En el caso de los servidores TLS, la aplicación debe leer el nombre DNS de la extensión y seleccionar un certificado adecuado para devolverlo al cliente.</span><span class="sxs-lookup"><span data-stu-id="a894b-477">For TLS Servers, the application must read the DNS name from the extension and select an appropriate certificate to send back to the client.</span></span>

<span data-ttu-id="a894b-478">En las secciones siguientes se proporcionan más detalles sobre cómo usar la extensión SNI en el servicio TLS de NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="a894b-478">The following sections provide more detail on how to use the SNI extension in NetX Secure TLS.</span></span>

### <a name="sni-extension--tls-client"></a><span data-ttu-id="a894b-479">Extensión SNI – Cliente TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-479">SNI Extension – TLS Client</span></span>

<span data-ttu-id="a894b-480">Un cliente TLS de NetX Secure que quiera usar la extensión SNI debe suministrar un nombre DNS a TLS para que se proporcione durante el protocolo de enlace.</span><span class="sxs-lookup"><span data-stu-id="a894b-480">A NetX Secure TLS Client wishing to use the SNI extension must provide a DNS name to TLS to be supplied during the handshake.</span></span> <span data-ttu-id="a894b-481">Este nombre se debe inicializar y proporcionar antes de iniciar una sesión de TLS, ya que la extensión se envía en el mensaje ClientHello que inicia el proceso de protocolo de enlace.</span><span class="sxs-lookup"><span data-stu-id="a894b-481">This name must be initialized and supplied prior to starting a TLS session since the extension is sent in the ClientHello message which starts the handshake process.</span></span>

<span data-ttu-id="a894b-482">En el fragmento de código siguiente se muestra el uso de la extensión.</span><span class="sxs-lookup"><span data-stu-id="a894b-482">The following code snippet illustrates the use of the extension.</span></span> <span data-ttu-id="a894b-483">En primer lugar, se inicializa un objeto NX_SECURE_X509_DNS_NAME con el nombre de servidor deseado.</span><span class="sxs-lookup"><span data-stu-id="a894b-483">First, a NX_SECURE_X509_DNS_NAME object is initialized with the desired server name.</span></span> <span data-ttu-id="a894b-484">Después, antes de iniciar la sesión de TLS, se proporciona el nombre a TLS mediante la API de extensión SNI.</span><span class="sxs-lookup"><span data-stu-id="a894b-484">Then, prior to starting the TLS session, the name is provided to TLS using the SNI extension API.</span></span> <span data-ttu-id="a894b-485">Una vez establecido el nombre, no es necesario realizar ninguna otra acción.</span><span class="sxs-lookup"><span data-stu-id="a894b-485">Once the name is set, no further action is required.</span></span> <span data-ttu-id="a894b-486">Consulte la referencia de la API en el capítulo 4.</span><span class="sxs-lookup"><span data-stu-id="a894b-486">See the API reference in Chapter 4</span></span>  
  
<span data-ttu-id="a894b-487">Descripción de los servicios de NetX Secure para obtener más información sobre las funciones individuales.</span><span class="sxs-lookup"><span data-stu-id="a894b-487">Description of NetX Secure Services for more information on the individual functions.</span></span>

```C
/* The dns_name variable will contain our desired server name. */
UINT status;
NX_SECURE_X509_DNS_NAME dns_name;

/* Initialize the server DNS name. */
status = nx_secure_x509_dns_name_initialize(&dns_name, "www.example.com", 
                                            strlen("www.example.com"));


/* Initialize SNI extension in previously-initialized TLS Session. */
status = nx_secure_tls_session_sni_extension_set(&client_tls_session, &dns_name);

/* Now start the TLS session, starting with establishing the TCP connection – if 
   TLS is started before initializing the SNI extension, the extension will not be 
   sent in the ClientHello message! */
status = nx_tcp_client_socket_connect(&client_socket, IP_ADDRESS(1, 2, 3, 4), 443, 
                                      5 * NX_IP_PERIODIC_RATE);

status = nx_secure_tls_session_start(&client_tls_session, &client_socket, 
                                     NX_WAIT_FOREVER);
```
### <a name="sni-extension--tls-server"></a><span data-ttu-id="a894b-488">Extensión SNI – Servidor TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-488">SNI Extension – TLS Server</span></span>

<span data-ttu-id="a894b-489">En el lado del servidor TLS, la aplicación puede procesar la extensión SNI para seleccionar las credenciales correctas (por ejemplo, el certificado) que se proporcionarán al cliente remoto durante el protocolo de enlace.</span><span class="sxs-lookup"><span data-stu-id="a894b-489">On the TLS Server side, the SNI extension may be processed by the application in order to select proper credentials (e.g. certificate) to provide to the remote client during the handshake.</span></span> <span data-ttu-id="a894b-490">Para ello, la aplicación debe proporcionar una devolución de llamada de sesión que se invoca después de la recepción de un mensaje ClientHello.</span><span class="sxs-lookup"><span data-stu-id="a894b-490">To do this, the application must supply a session callback which is invoked following the receipt of a ClientHello message.</span></span>

<span data-ttu-id="a894b-491">El código de ejemplo de la API de nx_secure_tls_session_server_callback_set (consulte la página 122) muestra el análisis de una extensión SNI entrante mediante una devolución de llamada de servidor.</span><span class="sxs-lookup"><span data-stu-id="a894b-491">The example code for the nx_secure_tls_session_server_callback_set API  (see page 122) illustrates the parsing of an incoming SNI extension using a server callback.</span></span> <span data-ttu-id="a894b-492">Esencialmente, el servidor TLS recibe un mensaje ClientHello e invoca la devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="a894b-492">Essentially, the TLS Server receives a ClientHello and invokes the callback.</span></span> <span data-ttu-id="a894b-493">A continuación, la aplicación usa la API de *nx_secure_tls_session_sni_extension_parse* para analizar los datos de la extensión proporcionada a la devolución de llamada para buscar la extensión SNI y devolver el nombre DNS proporcionado (tenga en cuenta que la extensión solo admite un nombre DNS único).</span><span class="sxs-lookup"><span data-stu-id="a894b-493">Then the application uses the *nx_secure_tls_session_sni_extension_parse* API to parse the extension data provided to the callback to find the SNI extension and return the supplied DNS name (note that the extension only supports a single DNS name).</span></span> <span data-ttu-id="a894b-494">Una vez que se obtiene el nombre, la aplicación lo usa para buscar y enviar el certificado de identidad de servidor adecuado (y la cadena de emisores, si procede).</span><span class="sxs-lookup"><span data-stu-id="a894b-494">Once the name is obtained, the application uses it to find and send the appropriate server identity certificate (and issuer chain if applicable).</span></span>

### <a name="signature-algorithms-extension"></a><span data-ttu-id="a894b-495">Extensión de algoritmos de firma</span><span class="sxs-lookup"><span data-stu-id="a894b-495">Signature Algorithms Extension</span></span>

<span data-ttu-id="a894b-496">Esta extensión es específica de TLS 1.2 y permite a un cliente TLS proporcionar una lista de pares de algoritmo hash y firma aceptables que se pueden usar para generar y comprobar firmas digitales.</span><span class="sxs-lookup"><span data-stu-id="a894b-496">This extension is specific to TLS 1.2 and allows a TLS Client to provide a list of acceptable signature and hash algorithm pairs that are acceptable for use in generating and verifying digital signatures.</span></span> <span data-ttu-id="a894b-497">La lista se genera automáticamente mediante el servicio TLS de NetX Secure para clientes TLS que usan la tabla de cifrado proporcionada para *nx_secure_tls_session_create*.</span><span class="sxs-lookup"><span data-stu-id="a894b-497">The list is generated automatically by NetX Secure TLS for TLS Clients using the cipher table supplied to *nx_secure_tls_session_create*.</span></span> <span data-ttu-id="a894b-498">No se requiere ninguna interacción con la aplicación.</span><span class="sxs-lookup"><span data-stu-id="a894b-498">No application interaction is required.</span></span>

## <a name="authentication-methods"></a><span data-ttu-id="a894b-499">Métodos de autenticación</span><span class="sxs-lookup"><span data-stu-id="a894b-499">Authentication Methods</span></span>

<span data-ttu-id="a894b-500">TLS proporciona el marco para establecer una conexión segura entre dos dispositivos a través de una red no segura, pero parte del problema es conocer la identidad del dispositivo en el otro extremo de la conexión.</span><span class="sxs-lookup"><span data-stu-id="a894b-500">TLS provides the framework for establishing a secure connection between two devices over an insecure network, but part of the problem is knowing the identity of the device on the other end of that connection.</span></span> <span data-ttu-id="a894b-501">Sin un mecanismo para autenticar la identidad de los hosts remotos, un atacante podría hacerse pasar por un dispositivo de confianza sin el más mínimo esfuerzo.</span><span class="sxs-lookup"><span data-stu-id="a894b-501">Without a mechanism for authenticating the identity of remote hosts, it becomes a trivial operation for an attacker to pose as a trusted device.</span></span>

<span data-ttu-id="a894b-502">Inicialmente, puede parecer que el uso de direcciones IP, direcciones MAC de hardware o DNS, proporcionarán un nivel relativamente alto de confianza para identificar hosts en una red, pero dada la naturaleza de la tecnología TCP/IP, la facilidad con la que se pueden suplantar las direcciones y dañarse las entradas DNS (por ejemplo, a través de la infección de la caché DNS), queda claro que TLS necesita una capa adicional de protección.</span><span class="sxs-lookup"><span data-stu-id="a894b-502">Initially, it may seem that using IP addresses, hardware MAC addresses, or DNS would provide a relatively high level of confidence for identifying hosts on a network, but given the nature of TCP/IP technology and the ease with which addresses can be spoofed and DNS entries corrupted (e.g. through DNS cache poisoning), it becomes clear that TLS needs an additional layer of protection against fraudulent identities.</span></span>

<span data-ttu-id="a894b-503">Hay varios mecanismos que pueden proporcionar esta capa adicional de autenticación para TLS, pero el *certificado digital* es el más común.</span><span class="sxs-lookup"><span data-stu-id="a894b-503">There are various mechanisms that can provide this extra layer of authentication for TLS, but the most common is the *digital certificate.*</span></span> <span data-ttu-id="a894b-504">Otros mecanismos incluyen las claves precompartidas (PSK) y los esquemas de contraseña.</span><span class="sxs-lookup"><span data-stu-id="a894b-504">Other mechanisms include Pre-Shared Keys (PSK) and password schemes.</span></span>

### <a name="digital-cerificates"></a><span data-ttu-id="a894b-505">Certificados digitales</span><span class="sxs-lookup"><span data-stu-id="a894b-505">Digital Cerificates</span></span>

<span data-ttu-id="a894b-506">Los certificados digitales son el método más común para autenticar un host remoto en TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-506">Digital certificates are the most common method for authenticating a remote host in TLS.</span></span> <span data-ttu-id="a894b-507">Esencialmente, un certificado digital es un documento con un formato específico que proporciona información de identidad para un dispositivo en una red de equipos.</span><span class="sxs-lookup"><span data-stu-id="a894b-507">Essentially, a digital certificate is a document with specific formatting that provides identity information for a device on a computer network.</span></span>

<span data-ttu-id="a894b-508">TLS normalmente usa un formato denominado X.509, un estándar desarrollado por la International Telecommunication Union, aunque se pueden usar otros formatos de certificados si los hosts de TLS acuerdan el formato usado.</span><span class="sxs-lookup"><span data-stu-id="a894b-508">TLS normally uses a format called X.509, a standard developed by the International Telecommunication Union, though other formats of certificates may be used if the TLS hosts can agree on the format being used.</span></span> <span data-ttu-id="a894b-509">X.509 define un formato específico para los certificados y diversas codificaciones que se pueden utilizar para generar un documento digital.</span><span class="sxs-lookup"><span data-stu-id="a894b-509">X.509 defines a specific format for certificates and various encodings that can be used to produce a digital document.</span></span> <span data-ttu-id="a894b-510">La mayoría de los certificados X.509 que se usan con TLS se codifican mediante una variante de ASN.1, otro estándar de telecomunicaciones.</span><span class="sxs-lookup"><span data-stu-id="a894b-510">Most X.509 certificates used with TLS are encoded using a variant of ASN.1, another telecommunications standard.</span></span> <span data-ttu-id="a894b-511">En ASN.1 hay varias codificaciones digitales, pero la codificación más común de los certificados TLS es el estándar de reglas de codificación distinguida (DER).</span><span class="sxs-lookup"><span data-stu-id="a894b-511">Within ASN.1 there are various digital encodings, but the most common encoding for TLS certificates is the Distinguished Encoding Rules (DER) standard.</span></span> <span data-ttu-id="a894b-512">DER es un subconjunto simplificado de las reglas de codificación básicas (BER) de ASN.1 que están diseñadas para ser inequívocas, lo que facilita el análisis.</span><span class="sxs-lookup"><span data-stu-id="a894b-512">DER is a simplified subset of the ASN.1 Basic Encoding Rules (BER) that is designed to be unambiguous, making parsing easier.</span></span> <span data-ttu-id="a894b-513">A través de la conexión, los certificados TLS normalmente están codificados en DER binario y este es el formato que NetX Secure espera para los certificados X.509.</span><span class="sxs-lookup"><span data-stu-id="a894b-513">Over the wire, TLS certificates are usually encoded in binary DER, and this is the format that NetX Secure expects for X.509 certificates.</span></span>

<span data-ttu-id="a894b-514">Aunque los certificados binarios con formato DER se usan en el protocolo TLS real, se pueden generar y almacenar en varias codificaciones diferentes, con extensiones de archivo como. pem, .crt y .p12.</span><span class="sxs-lookup"><span data-stu-id="a894b-514">Though DER-formatted binary certificates are used in the actual TLS protocol, they may be generated and stored in a number of different encodings, with file extensions such as .pem, .crt, and .p12.</span></span> <span data-ttu-id="a894b-515">Las distintas variantes las usan diferentes aplicaciones de distintos fabricantes, pero generalmente todas se pueden convertir en DER mediante herramientas ampliamente disponibles.</span><span class="sxs-lookup"><span data-stu-id="a894b-515">The different variants are used by different applications from different manufacturers, but generally all can be converted into DER using widely available tools.</span></span>

<span data-ttu-id="a894b-516">La más común de las codificaciones alternativas de certificados es PEM.</span><span class="sxs-lookup"><span data-stu-id="a894b-516">The most common of the alternative certificate encodings is PEM.</span></span> <span data-ttu-id="a894b-517">El formato PEM (Privacy-Enhanced Mail, correo con privacidad mejorada) es una versión codificada en base 64 de la codificación DER que se usa a menudo porque la codificación da como resultado texto imprimible que se puede enviar fácilmente mediante correo electrónico o protocolos basados en Web.</span><span class="sxs-lookup"><span data-stu-id="a894b-517">The PEM format (from Privacy-Enhanced Mail) is a base-64 encoded version of the DER encoding that is often used because the encoding results in printable text that can be easily sent using email or web-based protocols.</span></span>

<span data-ttu-id="a894b-518">La generación de un certificado para la aplicación de NetX Secure suele estar fuera del ámbito de este manual, pero la herramienta de línea de comandos de OpenSSL ([www.openssl.org](http://www.openssl.org)) está ampliamente disponible y puede realizar la conversión entre la mayoría de los formatos.</span><span class="sxs-lookup"><span data-stu-id="a894b-518">Generating a certificate for your NetX Secure application is generally outside the scope of this manual, but the OpenSSL command-line tool ([www.openssl.org](http://www.openssl.org)) is widely available and can convert between most formats.</span></span>

<span data-ttu-id="a894b-519">En función de la aplicación, puede generar sus propios certificados, proporcionar certificados por un fabricante o una organización gubernamental, o adquirir certificados de una entidad de certificación comercial.</span><span class="sxs-lookup"><span data-stu-id="a894b-519">Depending on your application, you may generate your own certificates, be provided certificates by a  manufacturer or government organization, or purchase certificates from a commercial certificate authority.</span></span>

<span data-ttu-id="a894b-520">Para usar un certificado digital en la aplicación de NetX Secure, primero debe convertir el certificado a un formato binario DER y, opcionalmente, convertir la clave privada asociada (el “exponente privado” en RSA, por ejemplo) en formato binario, normalmente una clave RSA con formato PKCS#1 con codificación DER o una clave ECC con codificación DER.</span><span class="sxs-lookup"><span data-stu-id="a894b-520">To use a digital certificate in your NetX Secure application, you must first convert your certificate into a binary DER format and, optionally, convert the associated private key (the "private exponent" for RSA, for example) into a binary format, typically a PKCS#1-formatted, DER-encoded RSA key or a DER-encoded ECC key.</span></span> <span data-ttu-id="a894b-521">Una vez finalizada la conversión, depende de usted cargar el certificado y la clave privada en el dispositivo.</span><span class="sxs-lookup"><span data-stu-id="a894b-521">Once the conversion is complete, it is up to you to load the certificate and private key onto the device.</span></span> <span data-ttu-id="a894b-522">Entre las opciones posibles se incluyen el uso de un sistema de archivos basado en Flash o la generación de una matriz C a partir de los datos (mediante una herramienta como “xxd” desde Linux) y la compilación del certificado y la clave en la aplicación como datos constantes.</span><span class="sxs-lookup"><span data-stu-id="a894b-522">Possible options include using a flash-based file system or generating a C array from the data (using a tool such as "xxd" from Linux) and compiling the certificate and key into your application as constant data.</span></span>

<span data-ttu-id="a894b-523">Una vez que el certificado se carga en el dispositivo, se puede usar la API de TLS para asociar el certificado a una sesión de TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-523">Once your certificate is loaded onto the device, the TLS API can be used to associate your certificate with a TLS session.</span></span>

<span data-ttu-id="a894b-524">Para obtener más información y ejemplos sobre cómo usar los certificados X.509 con el servicio TLS de NetX Secure, consulte la sección “Importación de certificados X.509 en NetX Secure”.</span><span class="sxs-lookup"><span data-stu-id="a894b-524">For details and examples on how to use X.509 certificates with NetX Secure TLS, see the section "Importing X.509 certificates into NetX Secure".</span></span>

<span data-ttu-id="a894b-525">Consulte los siguientes servicios TLS en la referencia de la API para obtener más información:</span><span class="sxs-lookup"><span data-stu-id="a894b-525">Refer to the following TLS services in the API reference for more information:</span></span>

- <span data-ttu-id="a894b-526">nx_secure_x509_certificate_initialize</span><span class="sxs-lookup"><span data-stu-id="a894b-526">nx_secure_x509_certificate_initialize</span></span>
- <span data-ttu-id="a894b-527">nx_secure_tls_local_certificate_add</span><span class="sxs-lookup"><span data-stu-id="a894b-527">nx_secure_tls_local_certificate_add</span></span>
- <span data-ttu-id="a894b-528">nx_secure_tls_local_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="a894b-528">nx_secure_tls_local_certificate_remove</span></span>
- <span data-ttu-id="a894b-529">nx_secure_tls_remote_certificate_allocate</span><span class="sxs-lookup"><span data-stu-id="a894b-529">nx_secure_tls_remote_certificate_allocate</span></span>
- <span data-ttu-id="a894b-530">nx_secure_tls_trusted_certificate_add</span><span class="sxs-lookup"><span data-stu-id="a894b-530">nx_secure_tls_trusted_certificate_add</span></span>
- <span data-ttu-id="a894b-531">nx_secure_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="a894b-531">nx_secure_trusted_certificate_remove</span></span>

### <a name="tls-client-certificate-specifics"></a><span data-ttu-id="a894b-532">Detalles de certificados de cliente TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-532">TLS Client Certificate Specifics</span></span>

<span data-ttu-id="a894b-533">Las implementaciones de cliente TLS generalmente no requieren la carga de un certificado “local”<sup>14</sup> en el dispositivo.</span><span class="sxs-lookup"><span data-stu-id="a894b-533">TLS Client implementations generally do not require a "local" certificate<sup>14</sup> to be loaded onto the device.</span></span> <span data-ttu-id="a894b-534">Hay una excepción: cuando está habilitada la autenticación de certificados de cliente, pero este supuesto es mucho menos frecuente.</span><span class="sxs-lookup"><span data-stu-id="a894b-534">The exception to this is when Client Certificate Authentication is enabled, but this is far less common.</span></span>

<span data-ttu-id="a894b-535">Un cliente TLS requiere que se cargue al menos un certificado “de confianza”<sup>15</sup> (es posible que se carguen más, si es necesario) y espacio para que se asigne un certificado “remoto”<sup>16</sup>.</span><span class="sxs-lookup"><span data-stu-id="a894b-535">A TLS Client requires at least one "trusted" certificate<sup>15</sup> to be loaded (more may be loaded if required), and space for a "remote" certificate<sup>16</sup> to be allocated.</span></span>

<span data-ttu-id="a894b-536">Para obtener más información sobre cómo agregar certificados de confianza y asignar espacio para los certificados remotos, consulte la referencia de la API de TLS para los siguientes servicios: nx_secure_tls_remote_certificate_allocate, nx_secure_tls_trusted_certificate_add.</span><span class="sxs-lookup"><span data-stu-id="a894b-536">For more information on adding trusted certificates and allocating space for remote certificates, see the TLS API reference for the following services: nx_secure_tls_remote_certificate_allocate, nx_secure_tls_trusted_certificate_add.</span></span>

14. <span data-ttu-id="a894b-537">Un certificado “local” es un certificado que identifica el dispositivo local, es decir, proporciona información de identidad para el dispositivo en el que se carga la aplicación TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-537">A “local” certificate is a certificate that identifies the local device – that is, it provides identity information for the device upon which the TLS application is loaded.</span></span>

15. <span data-ttu-id="a894b-538">Un certificado “de confianza” es un certificado que proporciona una base de confianza y autenticación del dispositivo remoto, ya sea directamente o a través de una infraestructura de clave pública (PKI).</span><span class="sxs-lookup"><span data-stu-id="a894b-538">A “trusted” certificate is a certificate that provides a basis for trust and authentication of the remote device, either directly or through a Public Key Infrastructure (PKI).</span></span> <span data-ttu-id="a894b-539">La raíz de la cadena de confianza se denomina normalmente “entidad de certificación” o certificado de CA.</span><span class="sxs-lookup"><span data-stu-id="a894b-539">The root of the chain of trust is usually called a “Certification Authority” or CA certificate.</span></span>

16. <span data-ttu-id="a894b-540">Un certificado “remoto” hace referencia al certificado enviado por el host remoto durante el protocolo de enlace TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-540">A “remote” certificate refers to the certificate sent by the remote host during the TLS handshake.</span></span> <span data-ttu-id="a894b-541">Proporciona identidad para ese host remoto y se autentica mediante su comparación con un certificado “de confianza” en el dispositivo local.</span><span class="sxs-lookup"><span data-stu-id="a894b-541">It provides identity for that remote host and is authenticated by comparing it to a “trusted” certificate on the local device.</span></span>

### <a name="tls-server-certificate-specifics"></a><span data-ttu-id="a894b-542">Detalles de certificados de servidor TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-542">TLS Server Certificate Specifics</span></span>

<span data-ttu-id="a894b-543">Por lo general, las implementaciones de servidor TLS no requieren la carga de certificados de “confianza” en el dispositivo o los certificados remotos que se van a asignar.</span><span class="sxs-lookup"><span data-stu-id="a894b-543">TLS Server implementations generally do not require "trusted" certificates to be loaded onto the device or remote certificates to be allocated.</span></span> <span data-ttu-id="a894b-544">Hay una excepción: cuando está habilitada la autenticación de certificados de cliente (este supuesto es menos frecuente).</span><span class="sxs-lookup"><span data-stu-id="a894b-544">The exception to this being when Client Certificate Authentication is enabled (this is less common).</span></span>

<span data-ttu-id="a894b-545">Un servidor TLS requiere la carga de un certificado “local” para que el servidor pueda proporcionarlo al cliente remoto durante el protocolo de enlace TLS para autenticar el servidor en el cliente.</span><span class="sxs-lookup"><span data-stu-id="a894b-545">A TLS Server requires a "local" certificate to be loaded so the server can provide it to the remote client during the TLS handshake to authenticate the server to the client.</span></span>

<span data-ttu-id="a894b-546">Para obtener más información sobre la carga de certificados locales para su uso con aplicaciones de servidor TLS de NetX, consulte la referencia de la API para los siguientes servicios:</span><span class="sxs-lookup"><span data-stu-id="a894b-546">For more information about loading local certificates for use with NetX TLS server applications, see the API reference for the following services:</span></span> 
- <span data-ttu-id="a894b-547">nx_secure_tls_local_certificate_add,</span><span class="sxs-lookup"><span data-stu-id="a894b-547">nx_secure_tls_local_certificate_add,</span></span> 
- <span data-ttu-id="a894b-548">nx_secure_tls_local_certificate_remove.</span><span class="sxs-lookup"><span data-stu-id="a894b-548">nx_secure_tls_local_certificate_remove.</span></span>

### <a name="pre-shared-keys-psk"></a><span data-ttu-id="a894b-549">Claves precompartidas (PSK)</span><span class="sxs-lookup"><span data-stu-id="a894b-549">Pre-Shared Keys (PSK)</span></span>

<span data-ttu-id="a894b-550">Un mecanismo alternativo para proporcionar autenticación de identificación en TLS es la noción de claves precompartidas (PSK).</span><span class="sxs-lookup"><span data-stu-id="a894b-550">An alternative mechanism for providing identification authentication in TLS is the notion of Pre-Shared Keys (PSK).</span></span> <span data-ttu-id="a894b-551">Usar un conjunto de cifrado PSK elimina la necesidad de realizar las operaciones de cifrado de clave pública de uso intensivo del procesador, una ventaja para los dispositivos integrados con restricción de recursos.</span><span class="sxs-lookup"><span data-stu-id="a894b-551">Using a PSK ciphersuite removes the need to do the processor-intensive public-key encryption operations, a boon for resource-constrained embedded devices.</span></span> <span data-ttu-id="a894b-552">La PSK reemplaza el certificado en el protocolo de enlace DTLS y se usa en lugar del secreto premaestro cifrado para la generación de claves de sesión DTLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-552">The PSK replaces the certificate in the TLS handshake and is used in place of the encrypted Pre-Master Secret for TLS session key generation.</span></span>

<span data-ttu-id="a894b-553">Las conjuntos de PSK están limitados en el sentido de que un secreto compartido debe estar presente en ambos dispositivos antes de que se pueda establecer una sesión de DTLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-553">The PSK ciphersuites are limited in the sense that that a shared secret must be present on both devices before a TLS session can be established.</span></span> <span data-ttu-id="a894b-554">Esto significa que los dispositivos se deben haber cargado con ese secreto mediante el uso de algunos medios seguros distintos, no solo mediante una conexión TLS con PSK. La PSK se puede actualizar a través de una conexión de TLS con PSK, pero el dispositivo debe comenzar con una PSK que se carga a través de otro mecanismo.</span><span class="sxs-lookup"><span data-stu-id="a894b-554">This means that the devices must have been loaded with that secret using some secure means other than a TLS PSK connection - PSKs may be updated over a TLS PSK connection, but the device must necessarily start with a PSK that is loaded through some other mechanism.</span></span> <span data-ttu-id="a894b-555">Por ejemplo, se podría cargar un dispositivo de sensor y su dispositivo de puerta de enlace con PSK en la fábrica antes del envío, o bien se podría usar una conexión TLS estándar (con un certificado) para cargar la PSK.</span><span class="sxs-lookup"><span data-stu-id="a894b-555">For example, a sensor device and its gateway device could be loaded with PSKs in the factory before shipping, or a standard TLS connection (with a certificate) could be used to load the PSK.</span></span>

<span data-ttu-id="a894b-556">Los conjuntos de cifrado PSK se presentan en un par de formatos, que se describe en la RFC 4279.</span><span class="sxs-lookup"><span data-stu-id="a894b-556">PSK ciphersuites come in a couple of forms, described in RFC 4279.</span></span> <span data-ttu-id="a894b-557">El primero usa las claves RSA o Diffie-Hellman que se usan de la misma manera que las claves públicas transmitidas en el certificado en los protocolos de enlace TLS estándar.</span><span class="sxs-lookup"><span data-stu-id="a894b-557">The first uses RSA or Diffie-Hellman keys which are used in the same manner as the public keys transmitted in the certificate in standard TLS handshakes.</span></span> <span data-ttu-id="a894b-558">El segundo, que se usa más en un entorno con restricción de recursos, utiliza una PSK que se utiliza para generar directamente las claves de sesión (para su uso con AES, por ejemplo), evitando así las costosas operaciones de Diffie-Hellman o RSA.</span><span class="sxs-lookup"><span data-stu-id="a894b-558">The second form, which is of more use in a resource-constrained environment, uses a PSK that is used to directly generate the session keys (for use by AES, for example), avoiding the use of the expensive RSA or Diffie-Hellman operations.</span></span>

<span data-ttu-id="a894b-559">NetX Secure admite el segundo formato de conjuntos de cifrado PSK, lo que permite que las aplicaciones quiten todo el código de criptografía de clave pública y el uso de memoria.</span><span class="sxs-lookup"><span data-stu-id="a894b-559">NetX Secure supports the second form of PSK ciphersuites, enabling applications to remove all public-key cryptography code and memory usage.</span></span> <span data-ttu-id="a894b-560">La PSK no es una clave AES, pero se puede considerar como una contraseña de la que se generan las claves reales.</span><span class="sxs-lookup"><span data-stu-id="a894b-560">The PSK itself is not an AES key, but can be considered as being more like a password from which the actual keys are generated.</span></span> <span data-ttu-id="a894b-561">Existen algunas restricciones en lo que puede ser el valor de PSK, aunque los valores más largos proporcionarán más seguridad (igual que con las contraseñas).</span><span class="sxs-lookup"><span data-stu-id="a894b-561">There are few restrictions on what the PSK value can be, though longer values will provide more security (same as with passwords).</span></span>

<span data-ttu-id="a894b-562">Para usar PSK con la aplicación de NetX Secure, primero debe definir la macro global **NX_SECURE_ENABLE_PSK_CIPHERSUITES**.</span><span class="sxs-lookup"><span data-stu-id="a894b-562">To use PSK with your NetX Secure application, you must first define the global macro **NX_SECURE_ENABLE_PSK_CIPHERSUITES**.</span></span> <span data-ttu-id="a894b-563">Normalmente esto se realiza a través de la configuración del compilador, pero la definición también se puede colocar en el archivo de encabezado nx_secure_tls.h.</span><span class="sxs-lookup"><span data-stu-id="a894b-563">This is usually done through your compiler settings, but the definition can also be placed in the nx_secure_tls.h header file.</span></span> <span data-ttu-id="a894b-564">Con la macro definida, la compatibilidad del conjunto de cifrado PSK se compilará en la aplicación TLS de NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="a894b-564">With the macro defined, PSK ciphersuite support will be compiled into your NetX Secure TLS application.</span></span>

<span data-ttu-id="a894b-565">Con la compatibilidad con PSK habilitada, puede usar la API de TLS para configurar PSK para la aplicación.</span><span class="sxs-lookup"><span data-stu-id="a894b-565">With PSK support enabled, you can then use the TLS API to set up PSKs for your application.</span></span> <span data-ttu-id="a894b-566">Cada PSK requerirá un valor de PSK (la “clave” secreta real que debe mantener a salvo), un valor de “identidad” que se usa para identificar la PSK específica y una “sugerencia de identidad” que se usa en un servidor TLS para elegir un valor de PSK determinado.</span><span class="sxs-lookup"><span data-stu-id="a894b-566">Each PSK will require a PSK value (the actual secret "key" – keep this value safe), an "identity" value used to identify the specific PSK, and an "identity hint" that is used by a TLS server to choose a particular PSK value.</span></span>

<span data-ttu-id="a894b-567">La PSK puede ser cualquier valor binario, ya que nunca se envía a través de una conexión de red.</span><span class="sxs-lookup"><span data-stu-id="a894b-567">The PSK itself can be any binary value as it is never sent over a network connection.</span></span> <span data-ttu-id="a894b-568">La PSK puede tener cualquier valor de hasta 64 bytes de longitud.</span><span class="sxs-lookup"><span data-stu-id="a894b-568">The PSK can be any value up to 64 bytes in length.</span></span>

<span data-ttu-id="a894b-569">La identidad y la sugerencia deben ser cadenas de caracteres imprimibles con formato UTF-8.</span><span class="sxs-lookup"><span data-stu-id="a894b-569">The identity and hint must be printable character strings formatted using UTF-8.</span></span> <span data-ttu-id="a894b-570">Los valores de identidad y sugerencia pueden tener una longitud de hasta 128 bytes.</span><span class="sxs-lookup"><span data-stu-id="a894b-570">The identity and hint values may be any length up to 128 bytes.</span></span>

<span data-ttu-id="a894b-571">La identidad y la PSK forman un par único que se carga en todos los dispositivos de la red que necesitan comunicarse entre sí.</span><span class="sxs-lookup"><span data-stu-id="a894b-571">The identity and PSK form a unique pair that is loaded onto every device in the network that need to communicate with one another.</span></span>

<span data-ttu-id="a894b-572">La “sugerencia” se usa principalmente para definir perfiles de aplicación específicos para agrupar PSK por función o servicio.</span><span class="sxs-lookup"><span data-stu-id="a894b-572">The "hint" is primarily used for defining specific application profiles to group PSKs by function or service.</span></span> <span data-ttu-id="a894b-573">Estos valores se deben acordar de antemano y dependen de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="a894b-573">These values must be agreed upon in advance and are application dependent.</span></span> <span data-ttu-id="a894b-574">Por ejemplo, la aplicación de servidor de línea de comandos de OpenSSL (con PSK habilitado) utiliza la cadena predeterminada “Client_identity” que debe proporcionar un cliente TLS para continuar con el protocolo de enlace TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-574">As an example, the OpenSSL command-line server application (with PSK enabled) uses the default string "Client_identity", which must be provided by a TLS client in order to continue with the TLS handshake.</span></span>

<span data-ttu-id="a894b-575">Para obtener más información sobre las PSK, consulte la referencia de la API de NetX Secure para los siguientes servicios: nx_secure_tls_client_psk_set, nx_secure_tls_psk_add.</span><span class="sxs-lookup"><span data-stu-id="a894b-575">For more information on PSKs, see the NetX Secure API reference for the following services: nx_secure_tls_client_psk_set, nx_secure_tls_psk_add.</span></span>

## <a name="importing-x509-certificates-into-netx-secure"></a><span data-ttu-id="a894b-576">Importación de certificados X.509 en NetX Secure</span><span class="sxs-lookup"><span data-stu-id="a894b-576">Importing X.509 certificates into NetX Secure</span></span>

<span data-ttu-id="a894b-577">Los certificados digitales son necesarios para la mayoría de las conexiones TLS en Internet.</span><span class="sxs-lookup"><span data-stu-id="a894b-577">Digital certificates are required for most TLS connections on the Internet.</span></span> <span data-ttu-id="a894b-578">Los certificados proporcionan un método para autenticar hosts desconocidos previamente a través de Internet mediante el uso de intermediarios de confianza, normalmente denominados *entidades de certificación* o CA.</span><span class="sxs-lookup"><span data-stu-id="a894b-578">Certificates provide a method for authenticating previously unknown hosts over the Internet through the use of trusted intermediaries, usually called *Certificate Authorities* or CAs.</span></span> <span data-ttu-id="a894b-579">Para conectar el dispositivo NetX Seguro con un servicio en la nube comercial (por ejemplo, Amazon Web Services), deberá importar los certificados en la aplicación si los carga en el dispositivo.</span><span class="sxs-lookup"><span data-stu-id="a894b-579">To connect your NetX Secure device with a commercial cloud service (such as Amazon Web Services), you will need to import certificates into your application by loading them onto your device.</span></span>

<span data-ttu-id="a894b-580">Además de los certificados, también necesitará una *clave privada* que esté asociada con el certificado.</span><span class="sxs-lookup"><span data-stu-id="a894b-580">Along with certificates, you will also sometimes need a *private key* that is associated with your certificate.</span></span> <span data-ttu-id="a894b-581">En algunas aplicaciones (como el cliente TLS cuando no se utiliza la autenticación de certificados de cliente), bastará con el certificado, pero si el certificado se usa para identificar el dispositivo, necesitará una clave privada.</span><span class="sxs-lookup"><span data-stu-id="a894b-581">In some applications (such as TLS Client when Client Certificate Authentication is not being used) the certificate alone will be sufficient, but if your certificate is being used to identify your device you will need a private key.</span></span> <span data-ttu-id="a894b-582">Las claves privadas normalmente se generan al crear el certificado y se almacenan en un archivo independiente (que a menudo cifrado con una contraseña).</span><span class="sxs-lookup"><span data-stu-id="a894b-582">Private keys are typically generated when you create your certificate and are stored in a separate file, often encrypted with a password.</span></span>

### <a name="certificate-types"></a><span data-ttu-id="a894b-583">Tipos de certificado</span><span class="sxs-lookup"><span data-stu-id="a894b-583">Certificate Types</span></span>

<span data-ttu-id="a894b-584">Los certificados digitales se utilizan normalmente para identificar entidades en una red pero, en función de sus aplicaciones, tendrán propiedades ligeramente diferentes.</span><span class="sxs-lookup"><span data-stu-id="a894b-584">Digital certificates are generally used to identify entities on a network, but depending on what their application they will have slightly different properties.</span></span>

### <a name="local-certificates"></a><span data-ttu-id="a894b-585">Certificados locales</span><span class="sxs-lookup"><span data-stu-id="a894b-585">Local Certificates</span></span>

<span data-ttu-id="a894b-586">Para los fines de esta documentación, “certificados locales” hace referencia a los certificados que proporcionan una identidad para el dispositivo local (otro nombre posible podría ser “certificado de dispositivo”).</span><span class="sxs-lookup"><span data-stu-id="a894b-586">For the purposes of this documentation, we will refer to "local certificates" as those certificates which provide an identity for our local device (another possible name could be "device certificate").</span></span> <span data-ttu-id="a894b-587">Estos certificados se proporcionarán a un host remoto cuando el host remoto desea autenticar el dispositivo local.</span><span class="sxs-lookup"><span data-stu-id="a894b-587">These certificates will be provided to a remote host when the remote host desires to authenticate the local device.</span></span>

### <a name="remote-certificates"></a><span data-ttu-id="a894b-588">Certificados remotos</span><span class="sxs-lookup"><span data-stu-id="a894b-588">Remote Certificates</span></span>

<span data-ttu-id="a894b-589">En esta documentación, “certificados remotos” hace referencia a los certificados proporcionados por un host remoto durante el protocolo de enlace TLS cuando proceda.</span><span class="sxs-lookup"><span data-stu-id="a894b-589">In this documentation, "remote certificates" refers to those certificates provided by a remote host during the TLS handshake when applicable.</span></span> <span data-ttu-id="a894b-590">Si el espacio de estos certificados no está asignado, NetX Secure no podrá analizarlos ni completar el protocolo de enlace TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-590">Space for these certificates must be allocated or NetX Secure will not be able to parse them and complete the TLS handshake.</span></span>

### <a name="signing-certificates"></a><span data-ttu-id="a894b-591">Certificados de firma</span><span class="sxs-lookup"><span data-stu-id="a894b-591">Signing Certificates</span></span>

<span data-ttu-id="a894b-592">Un “certificado de firma” se usa para firmar digitalmente otros certificados o datos con fines de autenticación.</span><span class="sxs-lookup"><span data-stu-id="a894b-592">A "signing certificate" is used to digitally sign other certificates or data for the purpose of authentication.</span></span> <span data-ttu-id="a894b-593">Estos certificados pueden ser certificados intermedios o raíz dentro de una infraestructura de clave pública (PKI) y, por lo general, no se usan para identificar dispositivos o hosts individuales.</span><span class="sxs-lookup"><span data-stu-id="a894b-593">These certificates may be either intermediate or root certificates within a Public Key Infrastructure (PKI) and are generally not used to identify individual devices or hosts.</span></span>

### <a name="root-ca-certificates"></a><span data-ttu-id="a894b-594">Certificados de entidad de certificación raíz</span><span class="sxs-lookup"><span data-stu-id="a894b-594">Root CA Certificates</span></span>

<span data-ttu-id="a894b-595">Los “Certificados de entidad de certificación raíz” son certificados de firma que proporcionan la base de una PKI y son autofirmados, en lugar de estar firmados por otro certificado de firma.</span><span class="sxs-lookup"><span data-stu-id="a894b-595">"Root CA certificates" are signing certificates that provide the basis of a PKI and are self-signed, rather than being signed by another signing certificate.</span></span> <span data-ttu-id="a894b-596">Normalmente, se requiere al menos un certificado de CA raíz para que un cliente de TLS compruebe los servidores remotos.</span><span class="sxs-lookup"><span data-stu-id="a894b-596">At least one Root CA certificate is typically required for a TLS Client to verify remote servers.</span></span>

### <a name="certificate-formats"></a><span data-ttu-id="a894b-597">Formatos de certificado</span><span class="sxs-lookup"><span data-stu-id="a894b-597">Certificate formats</span></span>

<span data-ttu-id="a894b-598">Los certificados digitales son simplemente archivos que contienen datos estructurados codificados mediante la sintaxis ASN.1.</span><span class="sxs-lookup"><span data-stu-id="a894b-598">Digital certificates are simply files containing structured data encoded using the ASN.1 syntax.</span></span> <span data-ttu-id="a894b-599">Sin embargo, hay varios formatos en los que se pueden almacenar los certificados y es importante tener el formato correcto antes de cargar un certificado en una aplicación de NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="a894b-599">However, there are various formats in which certificates may be stored and it is important to have the right format before loading a certificate into a NetX Secure application.</span></span>

<span data-ttu-id="a894b-600">Los formatos más comunes para los certificados son DER y PEM.</span><span class="sxs-lookup"><span data-stu-id="a894b-600">The most common formats for certificates are DER and PEM.</span></span> <span data-ttu-id="a894b-601">DER (*reglas de codificación distinguida*, un formato de ASN.1) es el formato binario que usa TLS al realizar el protocolo de enlace inicial.</span><span class="sxs-lookup"><span data-stu-id="a894b-601">DER (for *Distinguished Encoding Rules*, an ASN.1 format) is the binary format used by TLS when performing the initial handshake.</span></span> <span data-ttu-id="a894b-602">PEM (*correo con privacidad mejorada*) es una versión codificada en base 64 del formato DER adecuada para el correo electrónico o el envío a través de HTTP en la Web.</span><span class="sxs-lookup"><span data-stu-id="a894b-602">PEM (from *Privacy Enhanced Mail*) is a base-64 encoded version of the DER format which is suitable for emailing or sending over HTTP on the web.</span></span> <span data-ttu-id="a894b-603">Los distintos proveedores utilizan extensiones de nombre de archivo diferentes para los certificados, como “.pem” o “.CRT” para los certificados PEM y “.der” para los certificados DER.</span><span class="sxs-lookup"><span data-stu-id="a894b-603">Different vendors use different filename extensions for certificates, such as ".pem" or ".crt" for PEM certificates, and ".der" for DER certificates.</span></span> <span data-ttu-id="a894b-604">Si tiene un certificado y no está claro qué formato se usa, abrir el archivo en un editor de texto le permitirá determinar el tipo, ya que los archivos DER están codificados como binarios y los archivos PEM son texto ASCII normal que empieza con el encabezado “-----BEGIN CERTIFICATE-----”.</span><span class="sxs-lookup"><span data-stu-id="a894b-604">If you have a certificate and it is not clear what format is used, opening the file in a text editor will allow you to determine the type since DER files are encoded  binary, and PEM files are regular ASCII text that start with the header "-----BEGIN CERTIFICATE-----".</span></span>

<span data-ttu-id="a894b-605">NetX Secure requiere que el certificado esté en formato binario DER, por lo que tendrá que convertir el certificado al formato DER antes de la importación.</span><span class="sxs-lookup"><span data-stu-id="a894b-605">NetX Secure requires that your certificate be in binary DER format, so you will need to convert your certificate into DER format before importing.</span></span> <span data-ttu-id="a894b-606">Esto puede hacerse con herramientas disponibles fácilmente, como OpenSSL.</span><span class="sxs-lookup"><span data-stu-id="a894b-606">This can be done with readily available tools such as OpenSSL.</span></span>

<span data-ttu-id="a894b-607">Si necesita una clave privada para la aplicación, el archivo de clave se codificará con PEM o DER en un formato específico (PKCS#1 para RSA, RFC 5915 para ECC).</span><span class="sxs-lookup"><span data-stu-id="a894b-607">If you need a private key for your application, the key file will be encoded using PEM or DER in a specific format (PKCS#1 for RSA, RFC 5915 for ECC).</span></span> <span data-ttu-id="a894b-608">El archivo de clave privada deberá convertirse en DER antes de importarse.</span><span class="sxs-lookup"><span data-stu-id="a894b-608">The private key file will need to be converted into DER before being imported.</span></span>

<span data-ttu-id="a894b-609">Los siguientes comandos de OpenSSL se proporcionan como ejemplo para la conversión de certificados y archivos de clave RSA en el formato DER requerido por NetX Secure (ECC es similar; consulte la documentación de OpenSSL).</span><span class="sxs-lookup"><span data-stu-id="a894b-609">The following OpenSSL commands are given as an example for converting certificates and RSA key files into the DER format required by NetX Secure (ECC is similar – refer to the OpenSSL documentation).</span></span>

```C
openssl x509 -inform PEM -in <certificate> -outform DER -out cert.der
openssl x509 -inform PEM -in <root CA cert> -outform DER -out CA_cert.der
openssl rsa -inform PEM -in <private key> -outform DER -out private.key
```
### <a name="private-keys-and-certificates"></a><span data-ttu-id="a894b-610">Claves privadas y certificados</span><span class="sxs-lookup"><span data-stu-id="a894b-610">Private Keys and Certificates</span></span>

<span data-ttu-id="a894b-611">En el caso de los certificados que identifican un dispositivo, se debe cargar la clave privada asociada junto con el certificado.</span><span class="sxs-lookup"><span data-stu-id="a894b-611">For certificates that identify a device, the associated private key must be loaded along with the certificate.</span></span> <span data-ttu-id="a894b-612">Un servidor TLS usa la clave privada (que puede ser para uno de los algoritmos de clave pública, como RSA, Diffie-Hellman o criptografía de curva elíptica) para descifrar el material de clave entrante (el “secreto premaestro”) de un cliente TLS, con lo que se autentica a sí mismo en el cliente.</span><span class="sxs-lookup"><span data-stu-id="a894b-612">The private key (which may be for one of the public-key algorithms such as RSA, Diffie-Hellman, or Elliptic-Curve Cryptography) is used by a TLS server to decrypt the incoming key material (the "pre-master secret") from a TLS client, thereby authenticating itself to the client.</span></span> <span data-ttu-id="a894b-613">Para un cliente TLS, si se proporciona un certificado de identidad (un certificado con su clave privada asociada) y un servidor solicita un certificado de cliente, la clave privada se usa para autenticar el cliente: en el caso de RSA, el cliente cifra un token mediante la clave privada que luego el servidor descifra mediante la clave pública del cliente que se proporciona en el certificado de cliente (la autenticación Diffie-Hellman y ECC se produce de manera similar; solo varían algunos detalles).</span><span class="sxs-lookup"><span data-stu-id="a894b-613">For a TLS Client, if an identity certificate (a certificate with its associated private key) is provided and a server requests a client certificate, the private key is used to authenticate the client – in the case of RSA the client  encrypts a token using the private key which the server then decrypts using the client's public key, provided in the client certificate (Diffie-Hellman and ECC authentication happens in a similar fashion but the details are a bit different).</span></span>

<span data-ttu-id="a894b-614">En NetX Secure, el servicio *nx_secure_x509_certificate_initialize* se usa para inicializar un certificado X.509 (consulte la sección “Carga de certificados en el dispositivo” para obtener más información) y asociar opcionalmente una clave privada a ese certificado.</span><span class="sxs-lookup"><span data-stu-id="a894b-614">In NetX secure, the service *nx_secure_x509_certificate_initialize* is used to initialize an X.509 certificate (see section "Loading certificates onto your device" for more information) and optionally associate a private key with that certificate.</span></span>

<span data-ttu-id="a894b-615">Si se proporciona una clave privada, el certificado se marca como el certificado de “identidad” que se usa para identificar el dispositivo.</span><span class="sxs-lookup"><span data-stu-id="a894b-615">If a private key is supplied, the certificate is marked as being the "identity" certificate used to identify the device.</span></span> <span data-ttu-id="a894b-616">La clave se pasa como un BLOB binario contiguo y una longitud, con un tipo de clave asociada.</span><span class="sxs-lookup"><span data-stu-id="a894b-616">The key is passed as a contiguous binary blob and a length, with an associated key type.</span></span> <span data-ttu-id="a894b-617">El tipo de clave depende del tipo de la clave (por ejemplo, RSA, ECC, etc.) y el formato (por ejemplo, PKCS#1 DER).</span><span class="sxs-lookup"><span data-stu-id="a894b-617">The key type depends on the type of key (e.g. RSA, ECC, etc.) and the format (e.g. PKCS#1 DER).</span></span> <span data-ttu-id="a894b-618">Si no se proporciona ninguna clave, se puede pasar el valor NX_SECURE_X509_KEY_TYPE_NONE (valor 0X0) para indicar que no se proporciona ninguna clave (una longitud de 0 y un puntero NX_NULL para el parámetro de datos logrará el mismo efecto).</span><span class="sxs-lookup"><span data-stu-id="a894b-618">If no key is supplied, the value NX_SECURE_X509_KEY_TYPE_NONE (value 0x0) can be passed to indicate no key is being supplied (a length of 0 and a NX_NULL pointer for the data parameter will achieve the same effect).</span></span>

<span data-ttu-id="a894b-619">En la tabla siguiente se muestran los tipos de clave conocidos para NetX Secure y el identificador de tipo asociado que se va a pasar a *nx_secure_x509_certificate_initialize*.</span><span class="sxs-lookup"><span data-stu-id="a894b-619">The following table shows the key types known to NetX Secure and the associated type identifier to be passed into *nx_secure_x509_certificate_initialize*.</span></span> <span data-ttu-id="a894b-620">Se agregarán tipos de clave adicionales a medida que se agreguen más algoritmos de cifrado a NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="a894b-620">Additional key types will be added as more encryption algorithms are added to NetX Secure.</span></span>

| <span data-ttu-id="a894b-621">Identificador</span><span class="sxs-lookup"><span data-stu-id="a894b-621">Identifier</span></span>                              | <span data-ttu-id="a894b-622">Algoritmo</span><span class="sxs-lookup"><span data-stu-id="a894b-622">Algorithm</span></span> | <span data-ttu-id="a894b-623">Formato</span><span class="sxs-lookup"><span data-stu-id="a894b-623">Format</span></span>   | <span data-ttu-id="a894b-624">Encoding</span><span class="sxs-lookup"><span data-stu-id="a894b-624">Encoding</span></span> | <span data-ttu-id="a894b-625">Value</span><span class="sxs-lookup"><span data-stu-id="a894b-625">Value</span></span> |
| --------------------------------------- | --------- | -------- | -------- | ----- |
| <span data-ttu-id="a894b-626">NX_SECURE_X509_KEY_TYPE_NONE</span><span class="sxs-lookup"><span data-stu-id="a894b-626">NX_SECURE_X509_KEY_TYPE_NONE</span></span>            | <span data-ttu-id="a894b-627">None</span><span class="sxs-lookup"><span data-stu-id="a894b-627">None</span></span>      | <span data-ttu-id="a894b-628">N/D</span><span class="sxs-lookup"><span data-stu-id="a894b-628">N/A</span></span>      | <span data-ttu-id="a894b-629">N/D</span><span class="sxs-lookup"><span data-stu-id="a894b-629">N/A</span></span>      | <span data-ttu-id="a894b-630">0x0</span><span class="sxs-lookup"><span data-stu-id="a894b-630">0x0</span></span>   |
| <span data-ttu-id="a894b-631">NX_SECURE_X509_KEY_TYPE_RSA_PKCS1_DER</span><span class="sxs-lookup"><span data-stu-id="a894b-631">NX_SECURE_X509_KEY_TYPE_RSA_PKCS1_DER</span></span>   | <span data-ttu-id="a894b-632">RSA</span><span class="sxs-lookup"><span data-stu-id="a894b-632">RSA</span></span>       | <span data-ttu-id="a894b-633">PKCS#1</span><span class="sxs-lookup"><span data-stu-id="a894b-633">PKCS#1</span></span>   | <span data-ttu-id="a894b-634">DER</span><span class="sxs-lookup"><span data-stu-id="a894b-634">DER</span></span>      | <span data-ttu-id="a894b-635">0x1</span><span class="sxs-lookup"><span data-stu-id="a894b-635">0x1</span></span>   |
| <span data-ttu-id="a894b-636">NX_SECURE_X509_KEY_TYPE_EC_DER</span><span class="sxs-lookup"><span data-stu-id="a894b-636">NX_SECURE_X509_KEY_TYPE_EC_DER</span></span>          | <span data-ttu-id="a894b-637">ECDSA</span><span class="sxs-lookup"><span data-stu-id="a894b-637">ECDSA</span></span>     | <span data-ttu-id="a894b-638">RFC 5915</span><span class="sxs-lookup"><span data-stu-id="a894b-638">RFC 5915</span></span> | <span data-ttu-id="a894b-639">DER</span><span class="sxs-lookup"><span data-stu-id="a894b-639">DER</span></span>      | <span data-ttu-id="a894b-640">0x2</span><span class="sxs-lookup"><span data-stu-id="a894b-640">0x2</span></span>   |

### <a name="user-defined-private-key-types"></a><span data-ttu-id="a894b-641">Tipos de clave privada definidos por el usuario</span><span class="sxs-lookup"><span data-stu-id="a894b-641">User-defined private key types</span></span>

<span data-ttu-id="a894b-642">Los valores de los identificadores de tipo de clave para el servicio *nx_secure_x509_certificate_initialize* rigen las acciones que se realizan cuando se proporciona la clave privada.</span><span class="sxs-lookup"><span data-stu-id="a894b-642">The values of the key type identifiers for the *nx_secure_x509_certificate_initialize* service govern the actions taken when the private key is supplied.</span></span> <span data-ttu-id="a894b-643">En el caso de los tipos conocidos, los valores están en el intervalo 0x0000 0000 – 0x0000 FFFF (16 bits inferiores de un entero sin signo de 32 bits).</span><span class="sxs-lookup"><span data-stu-id="a894b-643">For known types, the values are in the range 0x0000 0000 – 0x0000 FFFF (bottom 16 bits of a 32-bit unsigned integer).</span></span> <span data-ttu-id="a894b-644">En el caso de las plataformas con tipos de clave personalizada<sup>17</sup> (como ocurre en algunos motores de cifrado basados en hardware), se puede pasar un tipo de clave definido por el usuario en el intervalo 0x0000 1000-0xFFFF FFFF (16 bits superiores distintos de cero) como tipo de clave.</span><span class="sxs-lookup"><span data-stu-id="a894b-644">For platforms with custom key types<sup>17</sup> (as is the case for some hardware-based encryption engines), a user-defined key type in the range 0x0000 1000-0xFFFF FFFF (top 16 bits non-zero) may be passed as the key type.</span></span> <span data-ttu-id="a894b-645">Si se establece cualquiera de los 16 bits superiores del tipo de clave, los datos de la clave privada se pasan directamente a la rutina criptográfica adecuada (por ejemplo, RSA) suministrada en la tabla de conjuntos de cifrado de TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-645">If any of the top 16 bits of the key type are set, then the private key data is passed directly to the appropriate cryptographic routine (e.g. RSA) supplied in the TLS ciphersuite table.</span></span> <span data-ttu-id="a894b-646">Los tipos de clave definidos por el usuario no se analizan ni se procesan de otra manera antes de pasarse a la rutina criptográfica.</span><span class="sxs-lookup"><span data-stu-id="a894b-646">User-defined key types are not parsed or otherwise processed before being passed to the cryptographic routine.</span></span> <span data-ttu-id="a894b-647">Además, el tipo de clave definido por el usuario también se pasará a la rutina criptográfica para que se pueda controlar cualquier procesamiento adecuado en ese nivel.</span><span class="sxs-lookup"><span data-stu-id="a894b-647">In addition, the user-defined key type will also be passed to the cryptographic routine so that any appropriate processing can be handled at that level.</span></span>

<span data-ttu-id="a894b-648">Tenga en cuenta que los tipos de clave definidos por el usuario se suelen usar en plataformas de hardware específicas que utilizan datos de clave personalizados (posiblemente cifrados).</span><span class="sxs-lookup"><span data-stu-id="a894b-648">Note that user-defined key types are generally used for specific hardware platforms that utilize custom (possibly encrypted) key data.</span></span> <span data-ttu-id="a894b-649">Por lo general, esto implica que los datos clave se generan o se codifican con un mecanismo específico de dicho proveedor de hardware (o, en el caso de una norma como PKCS#11, un estándar específico).</span><span class="sxs-lookup"><span data-stu-id="a894b-649">Generally this implies that the key data is generated or encoded using a mechanism specific to that hardware vendor (or in the case of a standard like PKCS#11, a specific standard).</span></span> <span data-ttu-id="a894b-650">Consulte la documentación del proveedor de la plataforma de hardware para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="a894b-650">Consult your hardware platform documentation for more information.</span></span>

17. <span data-ttu-id="a894b-651">Los tipos de clave definidos por el usuario requieren una rutina criptográfica personalizada correspondiente para controlar el formato de clave personalizada.</span><span class="sxs-lookup"><span data-stu-id="a894b-651">User-defined key types require a corresponding custom cryptographic routine to handle the custom key format.</span></span> <span data-ttu-id="a894b-652">La rutina criptográfica debe tener un algoritmo coincidente (por ejemplo, RSA) y pasarse a TLS en la tabla de conjuntos de cifrado.</span><span class="sxs-lookup"><span data-stu-id="a894b-652">The cryptographic routine must have a matching algorithm (e.g. RSA) and be passed into TLS in the ciphersuite table.</span></span> 

### <a name="loading-certificates-onto-your-device"></a><span data-ttu-id="a894b-653">Carga de certificados en el dispositivo</span><span class="sxs-lookup"><span data-stu-id="a894b-653">Loading certificates onto your device</span></span>

<span data-ttu-id="a894b-654">Cualquier método para cargar un archivo en el dispositivo será suficiente para importar los certificados.</span><span class="sxs-lookup"><span data-stu-id="a894b-654">Any method for loading a file onto your device will be sufficient to import your certificates.</span></span>

<span data-ttu-id="a894b-655">El método más sencillo para cargar un certificado es convertir los datos codificados en DER binarios en una matriz de C y compilarlos en la aplicación como una constante.</span><span class="sxs-lookup"><span data-stu-id="a894b-655">The simplest method for loading a certificate is to convert the binary DER-encoded data into a C array and compile it into your application as a constant.</span></span> <span data-ttu-id="a894b-656">Esto puede hacerse fácilmente con herramientas como “XXD” en Linux (con la opción “-i”).</span><span class="sxs-lookup"><span data-stu-id="a894b-656">This can be easily done with tools such as "xxd" in Linux (with the "-i" option).</span></span>

<span data-ttu-id="a894b-657">Como alternativa, puede cargar el certificado en un sistema de archivos Flash u otras opciones de almacenamiento, siempre y cuando pueda pasar un puntero a los datos del certificado en la API de NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="a894b-657">Alternatively, you can load your certificate into a flash filesystem or other storage options as long as you can pass a pointer to the certificate data into the NetX Secure API.</span></span>

### <a name="certificate-files-needed-for-netx-secure"></a><span data-ttu-id="a894b-658">Archivos de certificado necesarios para NetX Secure</span><span class="sxs-lookup"><span data-stu-id="a894b-658">Certificate files needed for NetX Secure</span></span>

<span data-ttu-id="a894b-659">Los archivos de certificado que necesitará importar dependen de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="a894b-659">The certificate files you will need to import depends on your application.</span></span> <span data-ttu-id="a894b-660">En general, los servidores TLS requieren un certificado para identificar el dispositivo y los clientes TLS requieren uno o más *certificados de confianza* para autenticar los servidores remotos.</span><span class="sxs-lookup"><span data-stu-id="a894b-660">In general, TLS Servers require a certificate to identify the device, and TLS Clients require one or more *Trusted Certificates* to authenticate remote servers.</span></span> <span data-ttu-id="a894b-661">En la tabla siguiente se muestran los certificados necesarios para algunas aplicaciones TLS diferentes.</span><span class="sxs-lookup"><span data-stu-id="a894b-661">The following table illustrates certificates needed for some different TLS applications.</span></span>

| <span data-ttu-id="a894b-662">**Funcionalidad/opciones de TLS**</span><span class="sxs-lookup"><span data-stu-id="a894b-662">**TLS functionality/options**</span></span>                     | <span data-ttu-id="a894b-663">**Certificados/claves que se necesitan (mínimo)**</span><span class="sxs-lookup"><span data-stu-id="a894b-663">**Certificates/keys needed (minimum)**</span></span>              |
| ------------------------------------------------- | --------------------------------------------------- |
| <span data-ttu-id="a894b-664">Cliente TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-664">TLS Client</span></span>                                        | <span data-ttu-id="a894b-665">Certificado de entidad de certificación raíz</span><span class="sxs-lookup"><span data-stu-id="a894b-665">Root CA certificate</span></span>                                 |
| <span data-ttu-id="a894b-666">Servidor TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-666">TLS Server</span></span>                                        | <span data-ttu-id="a894b-667">Certificado local, clave privada para ese certificado</span><span class="sxs-lookup"><span data-stu-id="a894b-667">Local certificate, private key for that certificate</span></span> |
| <span data-ttu-id="a894b-668">Servidor TLS con autenticación de certificados de cliente</span><span class="sxs-lookup"><span data-stu-id="a894b-668">TLS Server with Client Certificate Authentication</span></span> | <span data-ttu-id="a894b-669">Certificado local, clave privada, CA raíz</span><span class="sxs-lookup"><span data-stu-id="a894b-669">Local certificate, private key, Root CA</span></span>             |
| <span data-ttu-id="a894b-670">Cliente TLS con autenticación de certificados de cliente</span><span class="sxs-lookup"><span data-stu-id="a894b-670">TLS Client with Client Certificate Authentication</span></span> | <span data-ttu-id="a894b-671">Certificado local, clave privada, CA raíz</span><span class="sxs-lookup"><span data-stu-id="a894b-671">Local certificate, private key, Root CA</span></span>             |
| <span data-ttu-id="a894b-672">Cliente o servidor TLS solo con claves precompartidas</span><span class="sxs-lookup"><span data-stu-id="a894b-672">TLS Client or Server with Pre-Shared Keys only</span></span>    | <span data-ttu-id="a894b-673">Ninguno (se usó PSK en lugar de certificados)</span><span class="sxs-lookup"><span data-stu-id="a894b-673">None (PSK used instead of certificates)</span></span>             |

<span data-ttu-id="a894b-674">Los servicios relevantes para cargar certificados son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="a894b-674">The relevant services for loading certificates are as follows:</span></span>

| <span data-ttu-id="a894b-675">**API Name** (Nombre de la API)</span><span class="sxs-lookup"><span data-stu-id="a894b-675">**API Name**</span></span>                                   | <span data-ttu-id="a894b-676">**Propósito**</span><span class="sxs-lookup"><span data-stu-id="a894b-676">**Purpose**</span></span>                                            |
| ---------------------------------------------- |------------------------------------------------------- |
| <span data-ttu-id="a894b-677">nx_secure_x509_certificate_initialize</span><span class="sxs-lookup"><span data-stu-id="a894b-677">nx_secure_x509_certificate_initialize</span></span>      | <span data-ttu-id="a894b-678">Se debe llamar a todos los certificados con el fin de rellenar la estructura NX_SECURE_X509_CERT con los datos y la clave privada del certificado.</span><span class="sxs-lookup"><span data-stu-id="a894b-678">Must be called for all certificates to populate the NX_SECURE_X509_CERT structure with your certificate data and private key.</span></span> |
| <span data-ttu-id="a894b-679">nx_secure_tls_local_certificate_add</span><span class="sxs-lookup"><span data-stu-id="a894b-679">nx_secure_tls_local_certificate_add</span></span>       | <span data-ttu-id="a894b-680">Agrega un certificado local a una sesión de TLS para identificar el dispositivo.</span><span class="sxs-lookup"><span data-stu-id="a894b-680">Add a local certificate to a TLS session to identify your device.</span></span>                                                                |
| <span data-ttu-id="a894b-681">nx_secure_tls_local_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="a894b-681">nx_secure_tls_local_certificate_remove</span></span>    | <span data-ttu-id="a894b-682">Quita un certificado local de una sesión de TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-682">Remove a local certificate from a TLS session.</span></span>                                                                                   |
| <span data-ttu-id="a894b-683">nx_secure_tls_remote_certificate_allocate</span><span class="sxs-lookup"><span data-stu-id="a894b-683">nx_secure_tls_remote_certificate_allocate</span></span> | <span data-ttu-id="a894b-684">Asigna espacio para un certificado remoto (llamado con un objeto NX_SECURE_X509_CERT no inicializado).</span><span class="sxs-lookup"><span data-stu-id="a894b-684">Allocate space for a remote certificate (called with an uninitialized NX_SECURE_X509_CERT).</span></span>                                   |
| <span data-ttu-id="a894b-685">nx_secure_tls_trusted_certificate_add</span><span class="sxs-lookup"><span data-stu-id="a894b-685">nx_secure_tls_trusted_certificate_add</span></span>     | <span data-ttu-id="a894b-686">Agrega un certificado a una sesión de TLS como un certificado de confianza para autenticar hosts remotos.</span><span class="sxs-lookup"><span data-stu-id="a894b-686">Add a certificate to a TLS Session as a Trusted Certificate for authenticating remote hosts.</span></span>                                     |
| <span data-ttu-id="a894b-687">nx_secure_tls_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="a894b-687">nx_secure_tls_trusted_certificate_remove</span></span>  | <span data-ttu-id="a894b-688">Quita un certificado de confianza de una sesión de TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-688">Remove a trusted certificate from a TLS Session.</span></span>                                                                                 |

### <a name="working-with-aws-iot-certificates"></a><span data-ttu-id="a894b-689">Trabajo con certificados IoT de AWS</span><span class="sxs-lookup"><span data-stu-id="a894b-689">Working with AWS IoT Certificates</span></span>

<span data-ttu-id="a894b-690">En la interfaz de IoT Amazon Web Services, seleccione “Seguridad” en el menú de la barra lateral y seleccione “Certificados”.</span><span class="sxs-lookup"><span data-stu-id="a894b-690">In the Amazon Web Services IoT interface, select "Security" from the sidebar menu and select "Certificates".</span></span> <span data-ttu-id="a894b-691">Cree un certificado nuevo y siga las instrucciones para descargar el nuevo certificado de dispositivo.</span><span class="sxs-lookup"><span data-stu-id="a894b-691">Create a new certificate and follow the instructions to download your new device certificate.</span></span>

<span data-ttu-id="a894b-692">Una vez que haya descargado los certificados, tendrá que convertirlos al formato DER mediante OpenSSL o una utilidad similar.</span><span class="sxs-lookup"><span data-stu-id="a894b-692">Once you have downloaded your certificates, you will need to convert them into DER format using OpenSSL or a similar utility.</span></span>

<span data-ttu-id="a894b-693">NOTA: AWS también proporcionará un archivo de clave pública.</span><span class="sxs-lookup"><span data-stu-id="a894b-693">NOTE: AWS will also provide a public key file.</span></span> <span data-ttu-id="a894b-694">La clave pública está incluida en el certificado del dispositivo local, por lo que no es necesario importarla a la aplicación.</span><span class="sxs-lookup"><span data-stu-id="a894b-694">The public key is contained within the local device certificate so it does not need to be imported into your application.</span></span>

<span data-ttu-id="a894b-695">Por ejemplo, estos son los comandos para convertir el certificado de dispositivo local y su clave privada en formato DER para su uso con NetX Secure:</span><span class="sxs-lookup"><span data-stu-id="a894b-695">As an example, here are the commands to convert the local device certificate and its private key into DER format for use with NetX Secure:</span></span>

```C
openssl x509 -inform PEM -in <certificate> -outform DER -out cert.der
openssl x509 -inform PEM -in <root CA cert> -outform DER -out CA_cert.der
openssl rsa -inform PEM -in <private key> -outform DER -out private.key
```
<span data-ttu-id="a894b-696">Los archivos convertidos se pueden importar en la aplicación siguiendo las instrucciones anteriores.</span><span class="sxs-lookup"><span data-stu-id="a894b-696">The converted files can be imported into your application following the above instructions.</span></span>

## <a name="x509-certificate-validation-in-netx-secure"></a><span data-ttu-id="a894b-697">Validación del certificado X.509 en NetX Secure</span><span class="sxs-lookup"><span data-stu-id="a894b-697">X.509 Certificate Validation in NetX Secure</span></span> 

<span data-ttu-id="a894b-698">Cuando se usan TLS con certificados X.509 para la identificación y comprobación del host, es importante comprender cómo se validan realmente esos certificados.</span><span class="sxs-lookup"><span data-stu-id="a894b-698">When using TLS with X.509 certificates for host identification and verification, it is important to understand how those certificates are actually validated.</span></span> <span data-ttu-id="a894b-699">Aunque la especificación de TLS no proporciona instrucciones detalladas sobre cómo validar un certificado, hace referencia a la especificación X.509 (RFC 5280).</span><span class="sxs-lookup"><span data-stu-id="a894b-699">While the TLS specification does not provide detailed instructions on how to validate a certificate, it does refer to the X.509 specification (RFC 5280).</span></span> <span data-ttu-id="a894b-700">En general, se espera que TLS realice al menos la validación básica en los certificados de entrada (los certificados proporcionados por el host remoto durante el protocolo de enlace TLS) y lo mismo sucede en el servicio TLS de NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="a894b-700">In general, it is expected that TLS will perform at least basic validation on incoming certificates (those certificates supplied by the remote host during the TLS handshake), and NetX Secure TLS is no different.</span></span>

### <a name="basic-x509-validation"></a><span data-ttu-id="a894b-701">Validación básica de X.509</span><span class="sxs-lookup"><span data-stu-id="a894b-701">Basic X.509 Validation</span></span>

<span data-ttu-id="a894b-702">Para cualquier certificado entrante, el servicio TLS de NetX Secure realizará la validación básica de la ruta de acceso de X.509.</span><span class="sxs-lookup"><span data-stu-id="a894b-702">For any incoming certificate, NetX Secure TLS will perform basic X.509 path validation.</span></span> <span data-ttu-id="a894b-703">El proceso implica comprobar la firma digital de cada certificado con su certificado de emisor, que puede ser proporcionado por el host remoto o ubicarse en el almacén de certificados de confianza (consulte la sección “Importación de certificados X.509 en NetX Secure” para obtener más información sobre la importación de certificados de confianza).</span><span class="sxs-lookup"><span data-stu-id="a894b-703">The process involves checking each certificate's digital signature against its issuer certificate, which may be provided by the remote host or be located in the trusted certificate store (see the section "Importing X.509 certificates into NetX Secure" for more information on importing trusted certificates).</span></span> <span data-ttu-id="a894b-704">El proceso de validación se repite de forma recursiva en los certificados de emisor hasta que se llega a un certificado de confianza o finaliza la cadena (con un certificado autofirmado o un certificado de emisor que falta).</span><span class="sxs-lookup"><span data-stu-id="a894b-704">The validation process is recursively repeated on the issuer certificates until a trusted certificate is reached or the chain ends (with a self-signed certificate or a missing issuer certificate).</span></span> <span data-ttu-id="a894b-705">Si se llega a un certificado de confianza, se comprueba el certificado; en caso contrario, se rechaza.</span><span class="sxs-lookup"><span data-stu-id="a894b-705">If a trusted certificate is reached, the certificate is verified, otherwise it is rejected.</span></span> <span data-ttu-id="a894b-706">Además, en cada fase del proceso de comprobación, se comprueba la fecha de expiración de cada certificado con respecto a la hora proporcionada por la función de marca de tiempo de la aplicación (consulte el servicio “nx_secure_tls_session_time_function_set” para obtener más información).</span><span class="sxs-lookup"><span data-stu-id="a894b-706">Additionally, at each stage in the verification process the expiration date of each certificate is checked against the time provided by the application timestamp function (see the service "nx_secure_tls_session_time_function_set" for more information).</span></span>

<span data-ttu-id="a894b-707">La especificación X.509 también proporciona un algoritmo para admitir “directivas”, que son identificadores que se encuentran en una extensión X.509 que se puede comprobar durante la validación de la ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="a894b-707">The X.509 specification also provides an algorithm for supporting "policies", which are identifiers that are present in an X.509 extension that can be checked during path validation.</span></span> <span data-ttu-id="a894b-708">NetX Secure actualmente trata los certificados X.509 como si se hubiera definido la opción “anyPolicy”, es decir, todas las directivas son aceptables y no se lleva a cabo la comprobación opcional de directivas.</span><span class="sxs-lookup"><span data-stu-id="a894b-708">NetX Secure currently treats X.509 certificates as though the "anyPolicy" option is defined – that is, all policies are acceptable and the optional policy checking is not performed.</span></span> <span data-ttu-id="a894b-709">La implementación de X.509 en NetX Secure puede aumentar con esta característica en una versión futura.</span><span class="sxs-lookup"><span data-stu-id="a894b-709">The NetX Secure X.509 implementation may be augmented with this feature in a future release.</span></span> <span data-ttu-id="a894b-710">Por ahora, la extensión de la directiva se puede obtener a partir de un certificado mediante la API *nx_secure_x509_extension_find*.</span><span class="sxs-lookup"><span data-stu-id="a894b-710">For now, the policy extension may be obtained from a certificate using the *nx_secure_x509_extension_find* API.</span></span>

<span data-ttu-id="a894b-711">Una vez completada la validación básica de la ruta de acceso, TLS invocará la devolución de llamada de comprobación de certificado proporcionada por la aplicación mediante la API *nx_secure_tls_session_certificate_callback_set*.</span><span class="sxs-lookup"><span data-stu-id="a894b-711">Once the basic path validation is complete, TLS will invoke the certificate verification callback supplied by the application using the *nx_secure_tls_session_certificate_callback_set* API.</span></span> <span data-ttu-id="a894b-712">Si no se proporciona ninguna devolución de llamada, se considera que el certificado es de confianza después de validar la ruta de acceso correcta.</span><span class="sxs-lookup"><span data-stu-id="a894b-712">If no callback is supplied, the certificate is considered to be trusted following successful path validation.</span></span> <span data-ttu-id="a894b-713">Si se proporciona una devolución de llamada, esta llevará a cabo cualquier validación adicional del certificado requerido por la aplicación.</span><span class="sxs-lookup"><span data-stu-id="a894b-713">If a callback is supplied, the callback will perform any additional validation of the certificate required by the application.</span></span> <span data-ttu-id="a894b-714">El valor devuelto de la devolución de llamada se usa para determinar si se debe continuar con el protocolo de enlace TLS o anularlo debido a un error de validación.</span><span class="sxs-lookup"><span data-stu-id="a894b-714">The return value from the callback is used to determine whether to continue with the TLS handshake or to abort the handshake due to a validation failure.</span></span>

<span data-ttu-id="a894b-715">La devolución de llamada se invoca con un puntero a la sesión de TLS pertinente y un puntero NX_SECURE_X509_CERT al certificado que se va a validar.</span><span class="sxs-lookup"><span data-stu-id="a894b-715">The callback is invoked with a pointer to the relevant TLS session and an NX_SECURE_X509_CERT pointer to the certificate to be validated.</span></span> <span data-ttu-id="a894b-716">Entre la sesión de TLS y el certificado, la aplicación tiene todos los datos que necesita de TLS para realizar comprobaciones de verificación adicional.</span><span class="sxs-lookup"><span data-stu-id="a894b-716">Between the TLS session and the certificate, the application has all of the data it needs from TLS to perform additional verification checks.</span></span>

<span data-ttu-id="a894b-717">Para ayudar con la validación adicional, NetX Secure proporciona rutinas X.509 para algunas operaciones comunes de validación, incluidas la validación de DNS y la comprobación de la lista de revocación de certificados.</span><span class="sxs-lookup"><span data-stu-id="a894b-717">To help with the additional validation, NetX Secure provides X.509 routines for some common validation operations, including DNS validation and Certificate Revocation List checking.</span></span> <span data-ttu-id="a894b-718">Todas estas rutinas son aptas para su uso dentro de la devolución de llamada de comprobación de certificado, pero también se pueden usar para realizar una comprobación sin conexión de los certificados X.509.</span><span class="sxs-lookup"><span data-stu-id="a894b-718">All of these routines are suitable for use within the certificate verification callback but may also be used to perform off-line checking of X.509 certificates.</span></span>

<span data-ttu-id="a894b-719">En la tabla siguiente se resumen las funciones auxiliares disponibles para el procesamiento de certificados X.509.</span><span class="sxs-lookup"><span data-stu-id="a894b-719">The following table summarizes the available helper functions for X.509 certificate processing.</span></span> <span data-ttu-id="a894b-720">En las secciones siguientes y en el capítulo 4 de la referencia de la API encontrará explicaciones más detalladas sobre las operaciones.</span><span class="sxs-lookup"><span data-stu-id="a894b-720">More detailed explanations for the operations can be found in the following sections and the API reference in Chapter 4</span></span>  
  
<span data-ttu-id="a894b-721">La descripción de los servicios de NetX Secure incluye detalles adicionales sobre las rutinas específicas.</span><span class="sxs-lookup"><span data-stu-id="a894b-721">Description of NetX Secure Services provides additional details on the specific routines.</span></span>

| <span data-ttu-id="a894b-722">**API Name** (Nombre de la API)</span><span class="sxs-lookup"><span data-stu-id="a894b-722">**API Name**</span></span>                             | <span data-ttu-id="a894b-723">**Descripción**</span><span class="sxs-lookup"><span data-stu-id="a894b-723">**Description**</span></span>                               |
| ---------------------------------------- | -------------------------------------- |
| <span data-ttu-id="a894b-724">nx_secure_x509_common_name_dns_check</span><span class="sxs-lookup"><span data-stu-id="a894b-724">nx_secure_x509_common_name_dns_check</span></span>               | <span data-ttu-id="a894b-725">Compara el nombre común del sujeto X.509 y SubjectAltName con un nombre DNS esperado</span><span class="sxs-lookup"><span data-stu-id="a894b-725">Check the X.509 subject Common Name and SubjectAltName against an expected DNS name</span></span> |
| <span data-ttu-id="a894b-726">nx_secure_x509_crl_revocation_check</span><span class="sxs-lookup"><span data-stu-id="a894b-726">nx_secure_x509_crl_revocation_check</span></span>                 | <span data-ttu-id="a894b-727">Busca un certificado revocado en una lista de revocación de certificados X.509 (CRL)</span><span class="sxs-lookup"><span data-stu-id="a894b-727">Check for a revoked certificate in an X.509 Certificate Revocation List (CRL)</span></span>       |
| <span data-ttu-id="a894b-728">nx_secure_x509_extended_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="a894b-728">nx_secure_x509_extended_key_usage_extension_parse</span></span> | <span data-ttu-id="a894b-729">Analiza y busca un OID específico de uso mejorado de clave en un certificado</span><span class="sxs-lookup"><span data-stu-id="a894b-729">Parse and find a specific extended key usage OID in a certificate</span></span>                   |
| <span data-ttu-id="a894b-730">nx_secure_x509_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="a894b-730">nx_secure_x509_key_usage_extension_parse</span></span>           | <span data-ttu-id="a894b-731">Analiza y devuelve el campo de bits de uso de clave en un certificado</span><span class="sxs-lookup"><span data-stu-id="a894b-731">Parse and return the key usage bitfield in a certificate</span></span>                            |
| <span data-ttu-id="a894b-732">nx_secure_x509_extension_find</span><span class="sxs-lookup"><span data-stu-id="a894b-732">nx_secure_x509_extension_find</span></span>                        | <span data-ttu-id="a894b-733">Busca y devuelve los datos ASN.1 sin formato con codificación DER para una extensión específica.</span><span class="sxs-lookup"><span data-stu-id="a894b-733">Find and return the raw DER-encoded ASN.1 data for a specific extension.</span></span>            |

<span data-ttu-id="a894b-734">Funciones auxiliares de X.509 para su uso en la devolución de llamada de comprobación de certificado</span><span class="sxs-lookup"><span data-stu-id="a894b-734">X.509 helper functions for use in the certificate verification callback</span></span>

### <a name="x509-extensions"></a><span data-ttu-id="a894b-735">Extensiones X.509</span><span class="sxs-lookup"><span data-stu-id="a894b-735">X.509 Extensions</span></span>

<span data-ttu-id="a894b-736">La especificación X.509 describe una serie de “extensiones” que se pueden usar para proporcionar información adicional que se puede utilizar en la comprobación de certificados.</span><span class="sxs-lookup"><span data-stu-id="a894b-736">The X.509 specification describes a number of "extensions" that can be used to supply additional information that can be utilized in the verification of certificates.</span></span> <span data-ttu-id="a894b-737">En su mayor parte, estas extensiones son opcionales y no son necesarias para la validación segura de un certificado digital con un certificado raíz de confianza.</span><span class="sxs-lookup"><span data-stu-id="a894b-737">For the most part, these extensions are optional and are not required for secure validation of a digital certificate against a trusted root certificate.</span></span> <span data-ttu-id="a894b-738">Sin embargo, NetX Secure admite algunas extensiones básicas.</span><span class="sxs-lookup"><span data-stu-id="a894b-738">However, NetX Secure does support some basic extensions.</span></span> <span data-ttu-id="a894b-739">Tal vez se agregue compatibilidad con extensiones adicionales en versiones futuras.</span><span class="sxs-lookup"><span data-stu-id="a894b-739">Support for additional extensions may be added in future releases.</span></span>

<span data-ttu-id="a894b-740">Los valores que se admiten actualmente de forma nativa son los de la lista siguiente:</span><span class="sxs-lookup"><span data-stu-id="a894b-740">The currently supported extensions are listed in the following table:</span></span>

| <span data-ttu-id="a894b-741">Nombre de la extensión</span><span class="sxs-lookup"><span data-stu-id="a894b-741">Extension Name</span></span>           | <span data-ttu-id="a894b-742">Descripción</span><span class="sxs-lookup"><span data-stu-id="a894b-742">Description</span></span>                                                                   | <span data-ttu-id="a894b-743">API relevante</span><span class="sxs-lookup"><span data-stu-id="a894b-743">Relevant API</span></span>                                             |
| ------------------------ | ----------------------------------------------------------------------------- | -------------------------------------------------------- |
| <span data-ttu-id="a894b-744">Uso de claves</span><span class="sxs-lookup"><span data-stu-id="a894b-744">Key Usage</span></span>                | <span data-ttu-id="a894b-745">Proporciona un uso aceptable para la clave pública de un certificado en un campo de bits</span><span class="sxs-lookup"><span data-stu-id="a894b-745">Provides acceptable uses for a certificate's public key in a bitfield</span></span>         | <span data-ttu-id="a894b-746">nx_secure_x509_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="a894b-746">nx_secure_x509_key_usage_extension_parse</span></span>           |
| <span data-ttu-id="a894b-747">Uso mejorado de clave</span><span class="sxs-lookup"><span data-stu-id="a894b-747">Extended Key Usage</span></span>       | <span data-ttu-id="a894b-748">Proporciona un uso aceptable adicional para la clave pública de un certificado usando OID</span><span class="sxs-lookup"><span data-stu-id="a894b-748">Provides additional acceptable uses for a certificate's public key using OIDs</span></span> | <span data-ttu-id="a894b-749">nx_secure_x509_extended_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="a894b-749">nx_secure_x509_extended_key_usage_extension_parse</span></span> |
| <span data-ttu-id="a894b-750">Nombre alternativo del sujeto</span><span class="sxs-lookup"><span data-stu-id="a894b-750">Subject Alternative Name</span></span> | <span data-ttu-id="a894b-751">Proporciona nombres DNS alternativos que también están representados por el certificado</span><span class="sxs-lookup"><span data-stu-id="a894b-751">Provides alternative DNS names that are also represented by the certificate</span></span>   | <span data-ttu-id="a894b-752">nx_secure_x509_common_name_dns_check</span><span class="sxs-lookup"><span data-stu-id="a894b-752">nx_secure_x509_common_name_dns_check</span></span>               |

### <a name="unsupported-x509-extensions"></a><span data-ttu-id="a894b-753">Extensiones X.509 no admitidas</span><span class="sxs-lookup"><span data-stu-id="a894b-753">Unsupported X.509 Extensions</span></span>

<span data-ttu-id="a894b-754">La implementación de X.509 en NetX Secure proporciona un servicio para extraer también las extensiones no compatibles: *nx_secure_x509_extension_find*.</span><span class="sxs-lookup"><span data-stu-id="a894b-754">NetX Secure's X.509 implemenation does provide a service to extract unsupported extensions as well: *nx_secure_x509_extension_find*.</span></span> <span data-ttu-id="a894b-755">Esta API está destinada a usuarios avanzados, ya que requiere un conocimiento de ASN.1 con codificación DER para analizar los datos devueltos.</span><span class="sxs-lookup"><span data-stu-id="a894b-755">This API is intended for advanced users as it requires knowledge of DER-encoded ASN.1 in order to parse the data returned.</span></span> <span data-ttu-id="a894b-756">Se usa internamente para extraer las extensiones admitidas, pero se proporciona por comodidad en el desarrollo de la compatibilidad personalizada para las extensiones X.509.</span><span class="sxs-lookup"><span data-stu-id="a894b-756">It it used internally to extract supported extensions but is supplied for convenience in developing customized support for X.509 extensions.</span></span>

<span data-ttu-id="a894b-757">Para usar nx_secure_x509_extension_find, se pasa un objeto NX_SECURE_X509_EXTENSION, junto con el certificado y un identificador de extensión, que es una representación con enteros de la cadena OID de longitud variable para un tipo de extensión conocido.</span><span class="sxs-lookup"><span data-stu-id="a894b-757">To use nx_secure_x509_extension_find, a NX_SECURE_X509_EXTENSION is passed in, along with the certificate and an extension ID, which is an integer representation of the variable-length OID string for a known extension type.</span></span> <span data-ttu-id="a894b-758">En la página 178 de la referencia de la API de nx_secure_x509_extension_find, se proporciona una lista completa de los OID admitidos para las extensiones X.509.</span><span class="sxs-lookup"><span data-stu-id="a894b-758">A complete list of supported OIDs for X.509 extensions is provided in the API reference for nx_secure_x509_extension_find on page 178.</span></span>

<span data-ttu-id="a894b-759">La estructura NX_SECURE_X509_EXTENSION se define de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="a894b-759">The NX_SECURE_X509_EXTENSION structure is defined as follows:</span></span>

```C
typedef struct NX_SECURE_X509_EXTENSION_STRUCT
{
    /* Identifier (maps to OID) for this extension. */
    USHORT nx_secure_x509_extension_id;

    /* Critical flag - boolean value. */
    USHORT nx_secure_x509_extension_critical;

    /* Pointer to DER-encoded extension data. */
    const UCHAR *nx_secure_x509_extension_data;
    ULONG        nx_secure_x509_extension_data_length;
} NX_SECURE_X509_EXTENSION;
```
<span data-ttu-id="a894b-760">Cuando el servicio se devuelve correctamente, la estructura se rellenará con los datos pertinentes del certificado.</span><span class="sxs-lookup"><span data-stu-id="a894b-760">When the service returns successfully, the structure will be populated with the relevant data from the certificate.</span></span> <span data-ttu-id="a894b-761">En general, el campo nx_secure_x509_extension_id se usa para fines internos, pero se rellenará con la representación con enteros correspondiente del OID.</span><span class="sxs-lookup"><span data-stu-id="a894b-761">The nx_secure_x509_extension_id field is generally used for internal purposes but will be populated with the relevant OID integer representation.</span></span> <span data-ttu-id="a894b-762">El campo nx_secure_x509_extension_critical expone el valor de la marca de extensión crítica de X.509 (booleano).</span><span class="sxs-lookup"><span data-stu-id="a894b-762">The nx_secure_x509_extension_critical field exposes the X.509 critical extension flag value (Boolean).</span></span> <span data-ttu-id="a894b-763">Los campos nx_secure_x509_extension_data y nx_secure_x509_extension_data_length contienen un puntero a los datos ASN.1 con codificación DER para la extensión y la longitud de esos datos, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="a894b-763">The nx_secure_x509_extension_data and nx_secure_x509_extension_data_length fields contain a pointer to the DER-encoded ASN.1 data for the extension, and the length of that data, respectively.</span></span>

<span data-ttu-id="a894b-764">El análisis real de los datos de la extensión ASN.1 está fuera del ámbito de este documento, pero si tiene acceso al origen del servicio TLS de NetX Secure, puede ver cómo se realiza el análisis dondequiera que se llame a nx_secure_x509_extension_find para las extensiones admitidas.</span><span class="sxs-lookup"><span data-stu-id="a894b-764">Actual parsing of the extension ASN.1 data is beyond the scope of this document, but if you have access to the NetX Secure TLS source you can see how the parsing is done wherever nx_secure_x509_extension_find is called for supported extensions.</span></span>

### <a name="x509-dns-validation"></a><span data-ttu-id="a894b-765">Validación de DNS de X.509</span><span class="sxs-lookup"><span data-stu-id="a894b-765">X.509 DNS Validation</span></span>

<span data-ttu-id="a894b-766">Una operación de validación de certificados común en TLS implica comprobar el nombre del dominio de primer nivel (TLD) de un host remoto con el certificado X.509 proporcionado por ese host durante el protocolo de enlace TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-766">A common certificate validation operation in TLS involves checking the Top-Level Domain (TLD) name of a remote host against the X.509 certificate provided by that host during the TLS handshake.</span></span> <span data-ttu-id="a894b-767">Esta operación ayuda a garantizar que el certificado coincida realmente con el servidor host que lo proporcionó, suponiendo que se pueda confiar en la búsqueda de DNS.</span><span class="sxs-lookup"><span data-stu-id="a894b-767">This operation helps to ensure that the certificate does indeed match the host server that provided it, assuming the DNS lookup can be trusted.</span></span> <span data-ttu-id="a894b-768">En el servicio TLS de NetX Secure, esta funcionalidad la proporciona el servicio **nx_secure_x509_common_name_dns_check**, que toma el certificado y una cadena que contiene la parte TLD de la dirección URL usada para obtener acceso al host.</span><span class="sxs-lookup"><span data-stu-id="a894b-768">In NetX Secure TLS, this functionality is provided by the service **nx_secure_x509_common_name_dns_check**, which takes the certificate and a string containing the TLD portion of the URL used to access the host.</span></span> <span data-ttu-id="a894b-769">El TLD se compara con el campo de nombre común del certificado y, si coincide, se devuelve NX_SUCCESS.</span><span class="sxs-lookup"><span data-stu-id="a894b-769">The TLD is compared to the certificate's Common Name field and if it matches, NX_SUCCESS is returned.</span></span> <span data-ttu-id="a894b-770">Si el nombre común no coincide, la rutina también comprobará la existencia de la extensión de certificado X.509 *subjectAltName*.</span><span class="sxs-lookup"><span data-stu-id="a894b-770">If the Common Name does not match, the routine will also check for the existence of the X.509 certificate extension *subjectAltName*.</span></span> <span data-ttu-id="a894b-771">Si hay presente un parámetro subjectAltName, las entradas de DNSName de la extensión también se comprueban con el TLD proporcionado.</span><span class="sxs-lookup"><span data-stu-id="a894b-771">If a subjectAltName is present, any DNSName entries in the extension are also checked against the provided TLD.</span></span> <span data-ttu-id="a894b-772">De nuevo, si se encuentra alguna coincidencia, se devuelve NX_SUCCESS.</span><span class="sxs-lookup"><span data-stu-id="a894b-772">Again, if any match, NX_SUCCESS is returned.</span></span> <span data-ttu-id="a894b-773">Si no se encuentra ninguna coincidencia, se devuelve un error adecuado para devolver desde la devolución de llamada de validación de certificado.</span><span class="sxs-lookup"><span data-stu-id="a894b-773">If no match is found, an error suitable for returning from the certificate validation callback is returned.</span></span>

### <a name="x509-key-usage-and-extended-key-usage-extensions"></a><span data-ttu-id="a894b-774">Uso de claves X.509 y extensiones de uso mejorado de clave</span><span class="sxs-lookup"><span data-stu-id="a894b-774">X.509 Key Usage and Extended Key Usage Extensions</span></span>

<span data-ttu-id="a894b-775">Las extensiones de uso de clave y de uso mejorado de clave de X.509 proporcionan información sobre cómo se puede usar la clave pública de un certificado al autenticar el certificado.</span><span class="sxs-lookup"><span data-stu-id="a894b-775">The X.509 Key Usage and Extended Key Usage extensions provide information on how a certificate's public key may be used when authenticating that certificate.</span></span> <span data-ttu-id="a894b-776">El emisor del certificado proporciona el uso de la clave cuando el certificado se firma y se emite.</span><span class="sxs-lookup"><span data-stu-id="a894b-776">The key usage is supplied by the certificate's issuer when the certificate is signed and issued.</span></span> <span data-ttu-id="a894b-777">El uso de clave puede ser utilizado por un host TLS para comprobar que el certificado está autorizado a usarse para autenticar un host TLS remoto y realizar otras operaciones.</span><span class="sxs-lookup"><span data-stu-id="a894b-777">The key usage may be used by a TLS host to check that the certificate is authorized to be used to authenticate a remote TLS host and perform other operations.</span></span>

<span data-ttu-id="a894b-778">La extensión de uso de clave consta de un campo de bits simple en el que cada uno de los bits representa un uso de clave específico.</span><span class="sxs-lookup"><span data-stu-id="a894b-778">The Key Usage extension consists of a simple bitfield where each of the bits represents a specific key usage.</span></span> <span data-ttu-id="a894b-779">En la página 183 de la referencia de la API de *nx_secure_x509_key_usage_extension_parse*, se proporciona una lista completa de estos valores.</span><span class="sxs-lookup"><span data-stu-id="a894b-779">A complete list of these values is provided in the API reference for *nx_secure_x509_key_usage_extension_parse* on page 183.</span></span> <span data-ttu-id="a894b-780">Para obtener una descripción más completa de los bits de uso de clave y sus significados, consulte la sección 4.2.1.3 de la RFC 5280.</span><span class="sxs-lookup"><span data-stu-id="a894b-780">For a more complete description of the key usage bits and their meanings, refer to RFC 5280, section 4.2.1.3.</span></span>

<span data-ttu-id="a894b-781">La extensión de uso mejorado de clave, al igual que la extensión de uso de clave, proporciona información de uso aceptable de claves.</span><span class="sxs-lookup"><span data-stu-id="a894b-781">The Extended Key Usage extension, like the Key Usage extension, provides acceptable key use information.</span></span> <span data-ttu-id="a894b-782">Sin embargo, para admitir usos arbitrarios, la extensión de uso mejorado de clave usa OID en lugar de un campo de bits.</span><span class="sxs-lookup"><span data-stu-id="a894b-782">However, in order to support arbitrary usages, the Extended Key Usage extension utilizes OIDs instead of a bitfield.</span></span> <span data-ttu-id="a894b-783">Al analizar una extensión de uso mejorado de clave de X.509 en NetX Secure, la aplicación proporciona un entero que representa el OID: el servicio *nx_secure_x509_extended_key_usage_extension_parse* devolverá si ese OID está presente.</span><span class="sxs-lookup"><span data-stu-id="a894b-783">When parsing an Extended Key Usage extension in NetX Secure X.509, an integer representing the OID is supplied by the application – the *nx_secure_x509_extended_key_usage_extension_parse* service will then return whether that OID is present.</span></span> <span data-ttu-id="a894b-784">En la página 175 de la referencia de la API de *nx_secure_x509_extended_key_usage_extension_parse*, se proporciona una lista completa de los OID admitidos para el uso mejorado de clave.</span><span class="sxs-lookup"><span data-stu-id="a894b-784">A complete list of supported OIDs for Extended Key usage is provided in the API reference for *nx_secure_x509_extended_key_usage_extension_parse* on page 175.</span></span> <span data-ttu-id="a894b-785">Para obtener una descripción más completa de los OID y sus significados, consulte la sección 4.2.1.12 de la RFC 5280.</span><span class="sxs-lookup"><span data-stu-id="a894b-785">For a more complete description of the OIDs and their meanings, refer to RFC 5280, section 4.2.1.12.</span></span>

### <a name="x509-crl-revocation-status-checking"></a><span data-ttu-id="a894b-786">Comprobación del estado de revocación CRL de X.509</span><span class="sxs-lookup"><span data-stu-id="a894b-786">X.509 CRL Revocation Status Checking</span></span>

<span data-ttu-id="a894b-787">X.509 proporciona un mecanismo denominado *lista de revocación de certificados* (CRL) que permite a una autoridad de firma de certificados digitales revocar la validez de los certificados que ha firmado.</span><span class="sxs-lookup"><span data-stu-id="a894b-787">X.509 provides a mechanism called the *Certificate Revocation List* (CRL) that allows a digital certificate signing authority to revoke the validity of certificates it has signed.</span></span> <span data-ttu-id="a894b-788">Cualquier aplicación que necesite comprobar certificados de una autoridad de firma puede obtener una CRL y comparar los certificados firmados por dicha autoridad (emisor) con la CRL para ver si se ha revocado su estado por algún motivo (por ejemplo, una clave privada en peligro).</span><span class="sxs-lookup"><span data-stu-id="a894b-788">Any application that needs to verify certificates from a signing authority can obtain a CRL and compare any certificates signed by that authority (issuer) against the CRL to see if they have had their status revoked for some reason (such as compromised private key).</span></span> <span data-ttu-id="a894b-789">De esta manera, la aplicación puede evitar el uso de certificados potencialmente peligrosos que superen otras comprobaciones de validación de certificados.</span><span class="sxs-lookup"><span data-stu-id="a894b-789">In this way, the application can avoid using potentially dangerous certificates that pass other certificate validation checks.</span></span>

<span data-ttu-id="a894b-790">La obtención de una CRL se realiza mediante una aplicación mediante la descarga de la lista con codificación DER desde un servidor predefinido o a través de otros medios.</span><span class="sxs-lookup"><span data-stu-id="a894b-790">Obtaining a CRL is done by an application by downloading the DER-encoded list from a pre-defined server or through some other means.</span></span> <span data-ttu-id="a894b-791">La configuración real varía según el emisor, de modo que NetX Secure no proporciona un mecanismo para obtener las CRL, sino una rutina para comprobar un certificado en una CRL, **nx_secure_x509_crl_revocation_check**.</span><span class="sxs-lookup"><span data-stu-id="a894b-791">The actual setup varies from issuer to issuer so NetX Secure does not provide a mechanism for obtaining CRLs, but it does provide a routine to check a certificate against a CRL, **nx_secure_x509_crl_revocation_check**.</span></span>

<span data-ttu-id="a894b-792">La API toma una CRL codificada con DER, un almacén de certificados (como el de una sesión de TLS) con el que se va a realizar la comprobación y el certificado que se va a comprobar.</span><span class="sxs-lookup"><span data-stu-id="a894b-792">The API takes a DER-encoded CRL, a certificate store (such as the one in a TLS session) to check against, and the certificate to be checked.</span></span> <span data-ttu-id="a894b-793">La rutina valida primero la CRL en el almacén de confianza (parte del almacén de certificados proporcionado por la aplicación).</span><span class="sxs-lookup"><span data-stu-id="a894b-793">The routine first validates the CRL itself against the trusted store (part of the certificate store provided by the application).</span></span> <span data-ttu-id="a894b-794">Esto es importante para protegerse frente a las CRL fraudulentas que se usan para los ataques por denegación de servicio y establece que la CRL es realmente del emisor adecuado.</span><span class="sxs-lookup"><span data-stu-id="a894b-794">This is important to protect against fraudulent CRLs being used for Denial-of-Service attacks and establishes that the CRL is actually from the proper issuer.</span></span> <span data-ttu-id="a894b-795">Después de la validación de CRL, se comprueba el emisor: si el emisor de la CRL no coincide con el emisor del certificado, la CRL no es válida para ese certificado y se devuelve un error.</span><span class="sxs-lookup"><span data-stu-id="a894b-795">Following the CRL validation, the issuer is checked – if the issuer of the CRL does not match the issuer of the certificate, then the CRL is not valid for that certificate and an error is returned.</span></span> <span data-ttu-id="a894b-796">Depende de la aplicación determinar si el protocolo de enlace TLS puede continuar en este momento.</span><span class="sxs-lookup"><span data-stu-id="a894b-796">It is up to the application to determine whether the TLS handshake can continue at this point.</span></span> <span data-ttu-id="a894b-797">Si los emisores coinciden, se busca en la CRL el número de serie del certificado que se está validando.</span><span class="sxs-lookup"><span data-stu-id="a894b-797">If the issuers do match, then the CRL is searched for the serial number of the certificate being validated.</span></span> <span data-ttu-id="a894b-798">Si el número de serie está presente en la lista, se devuelve un error que indica que se ha revocado el certificado.</span><span class="sxs-lookup"><span data-stu-id="a894b-798">If the serial number is present in the list, an error indicating that the certificate has been revoked is returned.</span></span> <span data-ttu-id="a894b-799">Si no se encuentra alguna coincidencia, se devuelve NX_SUCCESS.</span><span class="sxs-lookup"><span data-stu-id="a894b-799">If no match is found, NX_SUCCESS is returned.</span></span>

## <a name="client-certificate-authentication-in-netx-secure-tls"></a><span data-ttu-id="a894b-800">Autenticación de certificados de cliente en el servicio TLS de NetX Secure</span><span class="sxs-lookup"><span data-stu-id="a894b-800">Client Certificate Authentication in NetX Secure TLS</span></span>

<span data-ttu-id="a894b-801">Al usar la autenticación de certificados X.509, el protocolo TLS requiere que la instancia del servidor TLS proporcione un certificado para la identificación. Sin embargo, de forma predeterminada, la instancia de cliente TLS no tiene que proporcionar un certificado para la autenticación y puede usar otra forma de autenticación (por ejemplo, una combinación de nombre de usuario/contraseña).</span><span class="sxs-lookup"><span data-stu-id="a894b-801">When using X.509 certificate authentication, the TLS protocol requires that the TLS Server instance provide a certificate for identification, but by default the TLS Client instance does not need to provide a certificate for authentication, using another form of authentication instead (e.g. a username/password combination).</span></span> <span data-ttu-id="a894b-802">Esto coincide con el uso más común de TLS para sitios Web en Internet.</span><span class="sxs-lookup"><span data-stu-id="a894b-802">This matches the most common use of TLS on the Internet for Web sites.</span></span> <span data-ttu-id="a894b-803">Por ejemplo, un sitio de venta directa en línea debe demostrar a un cliente potencial que use un explorador Web que el servidor es legítimo, pero el usuario empleará un inicio de sesión y una contraseña para tener acceso a una cuenta específica.</span><span class="sxs-lookup"><span data-stu-id="a894b-803">For example, an online retail site must prove to a potential customer using a web browser that the server is legitimate, but the user will use a login/password to access a specific account.</span></span>

<span data-ttu-id="a894b-804">Sin embargo, el caso predeterminado no siempre es el aconsejable, por lo que DTLS permite a la instancia del servidor TLS solicitar un certificado del cliente remoto.</span><span class="sxs-lookup"><span data-stu-id="a894b-804">However, the default case is not always desirable, so TLS optionally allows for the TLS Server instance to request a certificate from the remote Client.</span></span> <span data-ttu-id="a894b-805">Cuando esta característica está habilitada, el servidor TLS enviará un mensaje CertificateRequest al cliente TLS durante el protocolo de enlace.</span><span class="sxs-lookup"><span data-stu-id="a894b-805">When this feature is enabled, the TLS Server will send a CertificateRequest message to the TLS Client during the handshake.</span></span> <span data-ttu-id="a894b-806">El cliente debe responder con un certificado propio y un mensaje CertificateVerify que contenga un token criptográfico que demuestre que el cliente posee la clave privada correspondiente asociada a ese certificado.</span><span class="sxs-lookup"><span data-stu-id="a894b-806">The Client must respond with a certificate of its own and a CertificateVerify message which contains a cryptographic token proving that the Client owns the matching private key associated with that certificate.</span></span> <span data-ttu-id="a894b-807">Si se produce un error en la comprobación o el certificado no está conectado a un certificado de confianza en el servidor, se produce un error en el protocolo de enlace TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-807">If the verification fails or the certificate is not connected to a trusted certificate on the Server, the TLS handshake fails.</span></span>

<span data-ttu-id="a894b-808">Hay dos casos independientes para la autenticación de certificados de cliente en TLS: en las secciones siguientes se tratan ambos casos.</span><span class="sxs-lookup"><span data-stu-id="a894b-808">There are two separate cases for Client Certificate Authentication in TLS – the following sections cover both cases.</span></span>

### <a name="client-certificate-authentication-for-tls-clients"></a><span data-ttu-id="a894b-809">Autenticación de certificados de cliente para clientes TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-809">Client Certificate Authentication for TLS Clients</span></span>

<span data-ttu-id="a894b-810">Un cliente TLS puede intentar una conexión a un servidor que solicite un certificado para la autenticación del cliente.</span><span class="sxs-lookup"><span data-stu-id="a894b-810">A TLS Client may attempt a connection to a server that requests a certificate for client authentication.</span></span> <span data-ttu-id="a894b-811">En este caso, el cliente debe proporcionar un certificado al servidor y comprobar que posee la clave privada correspondiente; si no, el servidor finalizará el protocolo de enlace TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-811">In this case the Client must provide a certificate to the server and verify that it owns the matching private key or the Server will terminate the TLS handshake.</span></span>

<span data-ttu-id="a894b-812">En el servicio TLS de NetX Secure, no hay ninguna configuración especial para admitir esta característica, pero la aplicación tendrá que proporcionar un certificado de identificación local para la instancia de cliente TLS mediante el servicio *nx_secure_tls_local_certificate_add*.</span><span class="sxs-lookup"><span data-stu-id="a894b-812">In NetX Secure TLS, there is no special configuration to support this feature but the application will have to provide a local identification certificate for the TLS Client instance using the *nx_secure_tls_local_certificate_add* service.</span></span> <span data-ttu-id="a894b-813">Si la aplicación no proporciona ningún certificado pero el servidor remoto usa la autenticación de certificado de cliente y solicita un certificado, se producirá un error en el protocolo de enlace TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-813">If no certificate is provided by the application but the remote server is using Client Certificate Authentication and requests a certificate, the TLS handshake will fail.</span></span> <span data-ttu-id="a894b-814">El servidor remoto debe reconocer el certificado proporcionado a la sesión TLS con *nx_secure_tls_local_certificate_add* para poder completar el protocolo de enlace TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-814">The certificate provided to the TLS Session with *nx_secure_tls_local_certificate_add* must be recognized by the remote server in order to complete the TLS handshake.</span></span>

### <a name="client-certificate-authentication-for-tls-servers"></a><span data-ttu-id="a894b-815">Autenticación de certificados de cliente para servidores TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-815">Client Certificate Authentication for TLS Servers</span></span>

<span data-ttu-id="a894b-816">El caso del servidor TLS para la autenticación de certificados de cliente es ligeramente más complejo que el caso del cliente TLS, ya que la característica es opcional.</span><span class="sxs-lookup"><span data-stu-id="a894b-816">The TLS Server case for Client Certificate Authentication is slightly more complex than the TLS Client case due to the feature being optional.</span></span> <span data-ttu-id="a894b-817">En este caso, el servidor TLS necesita solicitar específicamente un certificado de cliente TLS remoto y, seguidamente, procesar el mensaje CertificateVerify para comprobar que el cliente remoto es el propietario de la clave privada correspondiente. A continuación, el servidor debe comprobar que se puede realizar un seguimiento del certificado proporcionado por el cliente hasta un certificado del almacén local de certificados de confianza.</span><span class="sxs-lookup"><span data-stu-id="a894b-817">In this case, the TLS Server needs to specifically request a certificate from the remote TLS Client, then process the CertificateVerify message to verify that the remote Client owns the matching private key, and then the Server must check that the certificate provided by the Client can be traced to a certificate in the local trusted certificate store.</span></span>

<span data-ttu-id="a894b-818">En las instancias del servidor TLS de NetX Secure, la autenticación de certificados de cliente se controla mediante</span><span class="sxs-lookup"><span data-stu-id="a894b-818">In NetX Secure TLS Server instances, Client Certificate Authentication is controlled by</span></span> <br>
<span data-ttu-id="a894b-819">los servicios *nx <span class="underline"> _</span>secure <span class="underline">_</span>tls <span class="underline"> _</span>session <span class="underline">_</span>client <span class="underline"> _</span>verify<span class="underline">_</span>enable* y</span><span class="sxs-lookup"><span data-stu-id="a894b-819">the *nx <span class="underline">_</span>secure <span class="underline">_</span>tls <span class="underline">_</span>session <span class="underline">_</span>client <span class="underline">_</span>verify<span class="underline">_</span>enable* and</span></span><br>
<span data-ttu-id="a894b-820">*nx <span class="underline"> _</span>secure <span class="underline">_</span>tls <span class="underline"> _</span>session <span class="underline">_</span>client <span class="underline"> _</span>verify<span class="underline">_</span>disable*.</span><span class="sxs-lookup"><span data-stu-id="a894b-820">*nx <span class="underline">_</span>secure <span class="underline">_</span>tls <span class="underline">_</span>session <span class="underline">_</span>client <span class="underline">_</span>verify<span class="underline">_</span>disable* services.</span></span>

<span data-ttu-id="a894b-821">Para habilitar la autenticación de certificados de cliente, una aplicación debe llamar a</span><span class="sxs-lookup"><span data-stu-id="a894b-821">To enable Client Certificate Authentication, an application must call</span></span><br>
<span data-ttu-id="a894b-822">*nx <span class="underline"> _</span>secure <span class="underline">_</span>tls <span class="underline"> _</span>session <span class="underline">_</span>client <span class="underline"> _</span>verify <span class="underline">_</span>enable* con la instancia de sesión del servidor TLS antes de llamar a *nx_secure_tls_session_start*.</span><span class="sxs-lookup"><span data-stu-id="a894b-822">*nx <span class="underline">_</span>secure <span class="underline">_</span>tls <span class="underline">_</span>session <span class="underline">_</span>client <span class="underline">_</span>verify <span class="underline">_</span>enable* with the TLS Server session instance before calling *nx_secure_tls_session_start*.</span></span> <span data-ttu-id="a894b-823">Tenga en cuenta que llamar a este servicio en una sesión de TLS que se usa para las conexiones de cliente TLS no tendrá ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a894b-823">Note that calling this service on a TLS Session that is used for TLS Client connections will have no effect.</span></span>

<span data-ttu-id="a894b-824">Cuando se habilita la autenticación de certificados de cliente, el servidor TLS solicitará un certificado de cliente TLS remoto durante el protocolo de enlace TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-824">When Client Certificate Authentication is enabled, the TLS Server will request a certificate from the remote TLS Client during the TLS handshake.</span></span> <span data-ttu-id="a894b-825">En el servidor TLS de NetX Secure, el certificado de cliente se compara con el almacén de certificados de confianza creados con *nx <span class="underline"> _</span>secure_tls <span class="underline">_</span>trusted <span class="underline"> _</span>certificate<span class="underline">_</span>add* siguiendo la cadena de emisor X.509.</span><span class="sxs-lookup"><span data-stu-id="a894b-825">In NetX Secure TLS Server, the Client certificate is checked against the store of trusted certificates created with *nx <span class="underline">_</span>secure_tls <span class="underline">_</span>trusted <span class="underline">_</span>certificate<span class="underline">_</span>add* following the X.509 issuer chain.</span></span> <span data-ttu-id="a894b-826">El cliente remoto debe proporcionar una cadena que conecte su certificado de identidad con un certificado en el almacén de confianza; de lo contrario, se producirá un error en el protocolo de enlace TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-826">The remote Client must provide a chain that connects its identity certificate to a certificate in the trusted store or the TLS handshake will fail.</span></span> <span data-ttu-id="a894b-827">Además, si se produce un error en el procesamiento del mensaje CertificateVerify, también se producirá un error en el protocolo de enlace TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-827">Additionally, if the CertificateVerify message processing fails, the TLS handshake will also fail.</span></span>

<span data-ttu-id="a894b-828">Los métodos de firma que se usan para el método CertificateVerify son fijos para la versión de TLS 1.0 y la versión TLS 1.1; se especifican mediante el servidor TLS en la versión TLS 1.2.</span><span class="sxs-lookup"><span data-stu-id="a894b-828">The signature methods used for the CertificateVerify method are fixed for TLS version 1.0 and TLS version 1.1, and are specified by the TLS Server in TLS version 1.2.</span></span> <span data-ttu-id="a894b-829">En el caso de TLS 1.2, los métodos de firma admitidos generalmente siguen los métodos pertinentes suministrados en la tabla de métodos criptográficos, pero normalmente RSA con SHA-256 (consulte la sección “Criptografía el servicio TLS de NetX Secure” para obtener más información sobre cómo inicializar TLS con métodos criptográficos).</span><span class="sxs-lookup"><span data-stu-id="a894b-829">For TLS 1.2, the signature methods supported generally follow the relevant methods supplied in the cryptographic method table, but typically RSA with SHA-256 (see the section "Cryptography in NetX Secure TLS" for more information on initializing TLS with cryptographic methods).</span></span>

## <a name="cryptography-in-netx-secure-tls"></a><span data-ttu-id="a894b-830">Criptografía en el servicio TLS de NetX Secure</span><span class="sxs-lookup"><span data-stu-id="a894b-830">Cryptography in NetX Secure TLS</span></span>

<span data-ttu-id="a894b-831">TLS define un protocolo en el que se puede usar la criptografía para proteger las comunicaciones de red.</span><span class="sxs-lookup"><span data-stu-id="a894b-831">TLS defines a protocol in which cryptography can be used to secure network communications.</span></span> <span data-ttu-id="a894b-832">Como tal, permite que los usuarios de TLS puedan usar el cifrado real de forma bastante amplia.</span><span class="sxs-lookup"><span data-stu-id="a894b-832">As such, it leaves the actual cryptography to be used fairly wide open for TLS users.</span></span> <span data-ttu-id="a894b-833">La especificación solo requiere la implementación de un único conjunto de cifrado. En el caso de TLS 1.2, el conjunto es TLS_RSA_WITH_AES_128_CBC_SHA, que indica el uso de RSA para las operaciones de clave pública, AES en modo CBC con claves de 128 bits para el cifrado de sesión y SHA-1 para los hash de autenticación de mensajes.</span><span class="sxs-lookup"><span data-stu-id="a894b-833">The specification only requires a single ciphersuite to be implemented – in the case of TLS 1.2, that ciphersuite is TLS_RSA_WITH_AES_128_CBC_SHA, indicating the use of RSA for public-key operations, AES in CBC mode with 128-bit keys for session encryption, and SHA-1 for message authentication hashes.</span></span>

<span data-ttu-id="a894b-834">Al ser compatible con TLS 1.2, NetX Secure habilita el conjunto de cifrado obligatorio TLS_RSA_WITH_AES_128_CBC_SHA de forma predeterminada, pero dado el número de implementaciones posibles para cada uno de los métodos criptográficos debido a las capacidades de hardware y otras consideraciones, NetX Secure proporciona una API criptográfica genérica que permite a los usuarios especificar qué métodos criptográficos usar con TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-834">Being TLS 1.2-compliant, NetX Secure enables the mandatory TLS_RSA_WITH_AES_128_CBC_SHA ciphersuite by default, but given the number of possible implementations for each of the cryptographic methods due to hardware capabilities and other considerations, NetX Secure provides a generic cryptographic API that allows a user to specify which cryptographic methods to use with TLS.</span></span>

<span data-ttu-id="a894b-835">NOTA: el mecanismo genérico de la API criptográfica también permite a los usuarios implementar sus propios conjuntos, pero esto solo se recomienda a los usuarios avanzados que están familiarizados con las extensiones y conjuntos de cifrado de TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-835">NOTE: The generic cryptographic API mechanism also allows users to implement their own ciphersuites, but this is recommended for advanced users who are familiar with the TLS ciphersuites and extensions.</span></span> <span data-ttu-id="a894b-836">Póngase en contacto con su representante de Logic Express si está interesado en usar sus propios conjuntos de cifrado.</span><span class="sxs-lookup"><span data-stu-id="a894b-836">Please contact your Express Logic representative if you are interested in supporting your own ciphersuites.</span></span>

### <a name="cryptographic-methods"></a><span data-ttu-id="a894b-837">Métodos criptográficos</span><span class="sxs-lookup"><span data-stu-id="a894b-837">Cryptographic Methods</span></span>

<span data-ttu-id="a894b-838">El servicio TLS de NetX Secure implementa DES, 3DES, AES, MD5, HMAC-MD5, SHA-1, HMAC-SHA1, SHA-256, HMAC-SHA256, RSA y ECC (curvas seleccionadas) en el software con controladores de hardware para determinadas plataformas de hardware.</span><span class="sxs-lookup"><span data-stu-id="a894b-838">NetX Secure TLS implements DES, 3DES, AES, MD5, HMAC-MD5, SHA-1, HMAC-SHA1, SHA-256, HMAC-SHA256, RSA, and ECC (selected curves) in software with hardware drivers for certain hardware platforms.</span></span> <span data-ttu-id="a894b-839">Una aplicación puede usar las rutinas criptográficas proporcionadas con NetX Secure o usar rutinas personalizadas proporcionadas por el usuario final o por terceros.</span><span class="sxs-lookup"><span data-stu-id="a894b-839">An application may use the cryptographic routines provided with NetX Secure, or use custom routines provided by the end user or third parties.</span></span>

<span data-ttu-id="a894b-840">*NX_CRYPTO_METHOD* es un bloque de control diseñado para que una aplicación describa una implementación concreta de un algoritmo criptográfico que se va a usar con el servicio TLS de NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="a894b-840">The *NX_CRYPTO_METHOD* is a control block designed for an application to describe a particular implementation of a cryptographic algorithm to be used with NetX Secure TLS.</span></span> <span data-ttu-id="a894b-841">Con *NX_CRYPTO_METHOD,* una aplicación puede integrar fácilmente su propia implementación de cifrado en NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="a894b-841">With the *NX_CRYPTO_METHOD,* an application can easily integrate their own crypto implementation into NetX Secure.</span></span> <span data-ttu-id="a894b-842">La estructura *NX_CRYPTO_METHOD* se declara como:</span><span class="sxs-lookup"><span data-stu-id="a894b-842">The *NX_CRYPTO_METHOD* structure is declared as:</span></span>

```C
typedef struct NX_CRYPTO_METHOD_STRUCT
{
    /* Symbolic name of the algorithm. */
    USHORT nx_crypto_algorithm;

    /* Size of the key, in bits. */
    USHORT nx_crypto_key_size_in_bits;

    /* Size of the IV block, in bits, used for encryption. */
    USHORT nx_crypto_IV_size_in_bits;

    /* Size of the ICV block, in bits, used for authentication. */
    USHORT nx_crypto_ICV_size_in_bits;

    /* Size of the crypto block, in bytes. */
    ULONG nx_crypto_block_size_in_bytes;

    /* Size of the metadata area. */
    ULONG nx_crypto_metadata_size;

    /* nx_crypto_init function initializes the crypto method with the
        "secret key" or other state  information. The initialization 
        routine should return a handle to the caller.  This handle is 
        used in subsequent crypto operations to identify the session.  
        */

    UINT (*nx_crypto_init) (NX_CRYPTO_METHOD     *method,
                            UCHAR               *key, 
                            NX_CRYPTO_KEY_SIZE   key_size_in_bits,
                            VOID               **handler,
                            VOID                *crypto_metadata,
                            VOID                 crypto_metadata_size);

    /* NetX Secure calls the nx_crypto_cleanup routine when a TLS
       session is to be deleted (or updated).  Resources allocated 
       during the crypto operation should be released in this routine.  
       */
    UINT (*nx_crypto_cleanup) (VOID *handler);

    /* nx_crypto_operation is the actual crypto or hash operation. Note 
       that both input and output buffers are prepared by the caller. 
       For encryption or decryption operations, the crypto operation 
       routine uses the output buffer for encrypted or decrypted data. 
       For authentication operations, the authentication routine shall 
       use the output buffer for the digest. */
    UINT (*nx_crypto_operation)(UINT  op, 
                  VOID              *handler, 
                  NX_CRYPTO_METHOD  *method,
                  UCHAR             *key,
                  NX_CRYPTO_KEY_SIZE key_size_in_bits,
                  UCHAR             *input,
                  ULONG              input_length_in_byte,
                  UCHAR             *iv_ptr,
                  UCHAR             *output,
                  ULONG              output_length_in_byte,
                  VOID              *crypto_metadata,
                  VOID               crypto_metadata_size,
                  NX_PACKET*         packet_ptr,
                  VOID (*nx_crypto_hw_process_callback(NX_PACKET 
                                                       *packet_ptr, 
                                                        UINT status);
} NX_CRYPTO_METHOD;
```

<span data-ttu-id="a894b-843">A continuación se muestra la descripción de cada elemento de la estructura *NX_CRYPTO_METHOD*:</span><span class="sxs-lookup"><span data-stu-id="a894b-843">Below is the description of each element in the *NX_CRYPTO_METHOD* structure:</span></span>

- <span data-ttu-id="a894b-844">nx_crypto_algorithm: este campo identifica el algoritmo descrito en la variable *METHOD*. Algunos valores válidos para el servicio TLS de NetX Secure son los siguientes (consulte nx_crypto_const. h para ver los valores específicos):</span><span class="sxs-lookup"><span data-stu-id="a894b-844">nx_crypto_algorithm: This field identifies the algorithm described in the variable *method* Some valid values for NetX Secure TLS are as follows (refer to nx_crypto_const.h for specific values):</span></span>
    
  - <span data-ttu-id="a894b-845">NX_CRYPTO_NONE</span><span class="sxs-lookup"><span data-stu-id="a894b-845">NX_CRYPTO_NONE</span></span>    
  - <span data-ttu-id="a894b-846">NX_CRYPTO_ENCRYPTION_NULL</span><span class="sxs-lookup"><span data-stu-id="a894b-846">NX_CRYPTO_ENCRYPTION_NULL</span></span>    
  - <span data-ttu-id="a894b-847">NX_CRYPTO_ENCRYPTION_AES_CBC</span><span class="sxs-lookup"><span data-stu-id="a894b-847">NX_CRYPTO_ENCRYPTION_AES_CBC</span></span>    
  - <span data-ttu-id="a894b-848">NX_CRYPTO_AUTHENTICATION_NONE</span><span class="sxs-lookup"><span data-stu-id="a894b-848">NX_CRYPTO_AUTHENTICATION_NONE</span></span>    
  - <span data-ttu-id="a894b-849">TLS_HASH_SHA_1</span><span class="sxs-lookup"><span data-stu-id="a894b-849">TLS_HASH_SHA_1</span></span>    
  - <span data-ttu-id="a894b-850">TLS_HASH_SHA_256</span><span class="sxs-lookup"><span data-stu-id="a894b-850">TLS_HASH_SHA_256</span></span>    
  - <span data-ttu-id="a894b-851">TLS_HASH_MD5</span><span class="sxs-lookup"><span data-stu-id="a894b-851">TLS_HASH_MD5</span></span>    
  - <span data-ttu-id="a894b-852">TLS_CIPHER_RSA</span><span class="sxs-lookup"><span data-stu-id="a894b-852">TLS_CIPHER_RSA</span></span>    
  - <span data-ttu-id="a894b-853">TLS_CIPHER_NULL</span><span class="sxs-lookup"><span data-stu-id="a894b-853">TLS_CIPHER_NULL</span></span>

- <span data-ttu-id="a894b-854">nx_crypto_key_size_in_bits: este campo especifica el tamaño de la clave secreta utilizada por el método.</span><span class="sxs-lookup"><span data-stu-id="a894b-854">nx_crypto_key_size_in_bits: this field specifies the size of the secret key used by the method.</span></span>

- <span data-ttu-id="a894b-855">nx_crypto_IV_size_in_bits: este campo especifica el tamaño del vector de inicialización (IV).</span><span class="sxs-lookup"><span data-stu-id="a894b-855">nx_crypto_IV_size_in_bits: this field specifies the size of the Initialization Vector (IV).</span></span> <span data-ttu-id="a894b-856">Tenga en cuenta que en la mayoría de los casos el bloque IV solo se usa para los algoritmos de cifrado y descifrado.</span><span class="sxs-lookup"><span data-stu-id="a894b-856">Note that in most cases the IV block is only used for encryption/decryption algorithms.</span></span> <span data-ttu-id="a894b-857">Los algoritmos de autenticación y comprobación suelen usar este campo.</span><span class="sxs-lookup"><span data-stu-id="a894b-857">Authentication and verification algorithms rarely use this field.</span></span>

- <span data-ttu-id="a894b-858">nx_crypto_ICV_size_in_bits: este campo especifica el tamaño del bloque de valor de comprobación de integridad (ICV).</span><span class="sxs-lookup"><span data-stu-id="a894b-858">nx_crypto_ICV_size_in_bits: this field specifies the size of the Integrity Check Value (ICV) block.</span></span> <span data-ttu-id="a894b-859">NOTA: este bloque es para uso de IPsec y no se usa en TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-859">NOTE: This block is for IPsec usage and is unused in TLS.</span></span> <span data-ttu-id="a894b-860">Para obtener más información, consulte el servicio IPsec de NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="a894b-860">See NetX Duo IPsec for more information.</span></span>

- <span data-ttu-id="a894b-861">nx_crypto_block_size_in_bytes: este campo especifica el tamaño del bloque de algoritmos criptográficos para los cifrados basados en bloques (en bytes).</span><span class="sxs-lookup"><span data-stu-id="a894b-861">nx_crypto_block_size_in_bytes: this field specifies the size of the cryptographic algorithm block for block-based ciphers, in bytes.</span></span> <span data-ttu-id="a894b-862">En la mayoría de los casos, lo usan las rutinas de cifrado y raramente las rutinas de autenticación.</span><span class="sxs-lookup"><span data-stu-id="a894b-862">In most cases this is used by encryption routines and rarely by authentication routines.</span></span>

- <span data-ttu-id="a894b-863">nx_crypto_metadata_area_size: este campo especifica el tamaño del área de metadatos que requiere este método.</span><span class="sxs-lookup"><span data-stu-id="a894b-863">nx_crypto_metadata_area_size: this field specifies the size of the metadata area this method requires.</span></span> <span data-ttu-id="a894b-864">Cada implementación puede requerir cierta memoria para almacenar su información de estado, para almacenar datos intermedios (como material de transformación de claves) o para usarlos como un área de borrador.</span><span class="sxs-lookup"><span data-stu-id="a894b-864">Each implementation may require certain memory to store its state information, or to store intermediate data (such as key transformation material), or to use as a scratch area.</span></span> <span data-ttu-id="a894b-865">En este campo se especifica la cantidad de espacio necesario para una implementación.</span><span class="sxs-lookup"><span data-stu-id="a894b-865">The amount of space required by an implementation is specified in this field.</span></span> <span data-ttu-id="a894b-866">La aplicación proporciona el espacio de memoria al crear una sesión de TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-866">The application provides the memory space when creating a TLS session.</span></span> <span data-ttu-id="a894b-867">La función criptográfica es responsable de administrar esta área de metadatos.</span><span class="sxs-lookup"><span data-stu-id="a894b-867">The cryptographic function is responsible for managing this metadata area.</span></span>

- <span data-ttu-id="a894b-868">nx_crypto_init: se trata de la función de inicialización para el algoritmo criptográfico.</span><span class="sxs-lookup"><span data-stu-id="a894b-868">nx_crypto_init: This is the initialization function for the cryptographic algorithm.</span></span> <span data-ttu-id="a894b-869">En una implementación que no necesita una rutina de inicialización, este campo se puede establecer en NX_NULL.</span><span class="sxs-lookup"><span data-stu-id="a894b-869">For an implementation that does not need an initialization routine, this field may be set to NX_NULL.</span></span> <span data-ttu-id="a894b-870">Un uso típico de una función de inicialización es inicializar la estructura de datos interna para el algoritmo.</span><span class="sxs-lookup"><span data-stu-id="a894b-870">A typical use of an initialization function is to initialize the internal data structure for the algorithm.</span></span> <span data-ttu-id="a894b-871">El servicio TLS de NetX Secure administrará la inicialización de la rutina criptográfica llamando a esta función internamente.</span><span class="sxs-lookup"><span data-stu-id="a894b-871">NetX Secure TLS will handle initialization of the cryptographic routine by calling this function internally.</span></span>

<span data-ttu-id="a894b-872">El prototipo de la función de inicialización es:</span><span class="sxs-lookup"><span data-stu-id="a894b-872">The prototype for the initialization function is:</span></span>

```C
UINT crypto_init_function(NX_CRYPTO_METHOD *method, 
                          UCHAR *key, 
                          UINT  key_size_in_bits, 
                          VOID  **handle, 
                          VOID  *crypto_metadata_area, 
                          ULONG crypto_metadata_area_size);
```

  - <span data-ttu-id="a894b-873">“method” es un puntero al bloque de control del método criptográfico.</span><span class="sxs-lookup"><span data-stu-id="a894b-873">method is a pointer to the crypto method control block.</span></span>

  - <span data-ttu-id="a894b-874">“key” es la cadena de clave secreta para procesar los paquetes de datos.</span><span class="sxs-lookup"><span data-stu-id="a894b-874">key is the secret key string for processing the data packets.</span></span>

  - <span data-ttu-id="a894b-875">“key_size_in_bits” define el tamaño de la clave secreta en bits.</span><span class="sxs-lookup"><span data-stu-id="a894b-875">key_size_in_bits defines the size of the secret key, in bits.</span></span>

  - <span data-ttu-id="a894b-876">“handle” es un elemento definido por la implementación que identifica una sesión de cifrado determinada.</span><span class="sxs-lookup"><span data-stu-id="a894b-876">handle is an implementation-defined item that identifies a particular crypto session.</span></span> <span data-ttu-id="a894b-877">El valor se genera mediante la rutina de inicialización y se devuelve al autor la llamada.</span><span class="sxs-lookup"><span data-stu-id="a894b-877">The value is generated by the initialization routine, and is passed back to the caller.</span></span> <span data-ttu-id="a894b-878">La siguiente operación de cifrado o rutina de limpieza utiliza este identificador para identificar la sesión.</span><span class="sxs-lookup"><span data-stu-id="a894b-878">The subsequent crypto operation or clean up routine use this handle to identify the session.</span></span>

  - <span data-ttu-id="a894b-879">“crypto_metadata” es un puntero al área de metadatos que requiere la implementación de este algoritmo.</span><span class="sxs-lookup"><span data-stu-id="a894b-879">crypto_metadata is a pointer to the metadata area required by the implementation of this algorithm.</span></span> <span data-ttu-id="a894b-880">En el caso de los algoritmos que no necesitan un área de metadatos, este campo se establece en NX_NULL y la rutina de inicialización no debe tener acceso al área de metadatos.</span><span class="sxs-lookup"><span data-stu-id="a894b-880">For algorithms that do not need a metadata area this field is set to NX_NULL and the initialization routine must not access the metadata area.</span></span>

  - <span data-ttu-id="a894b-881">“crypto_metadata_size” especifica el tamaño del área de metadatos.</span><span class="sxs-lookup"><span data-stu-id="a894b-881">crypto_metadata_size specifies the size of the metadata area.</span></span> <span data-ttu-id="a894b-882">En el caso de los algoritmos que no necesitan un área de metadatos, este campo se establece en NX_NULL y la rutina de inicialización no debe tener acceso al área de metadatos.</span><span class="sxs-lookup"><span data-stu-id="a894b-882">For SAs created without metadata area, this field is set to zero, and the initialization routine must not access the metadata area.</span></span>

  - <span data-ttu-id="a894b-883">Esta rutina devolverá *NX_SUCCESS* si el proceso de inicialización se realiza correctamente.</span><span class="sxs-lookup"><span data-stu-id="a894b-883">This routine shall return *NX_SUCCESS* if the initialization process is successful.</span></span> <span data-ttu-id="a894b-884">El autor de llamada trata cualquier otro valor devuelto como error.</span><span class="sxs-lookup"><span data-stu-id="a894b-884">The caller treats any other return value as failure.</span></span>

- <span data-ttu-id="a894b-885">nx_crypto_cleanup: se trata de la rutina de limpieza definida para la implementación de un algoritmo criptográfico.</span><span class="sxs-lookup"><span data-stu-id="a894b-885">nx_crypto_cleanup: This is the cleanup routine defined for the implementation of a crypto algorithm.</span></span> <span data-ttu-id="a894b-886">Se invoca cuando se elimina o se reinicia una sesión de TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-886">It is invoked when a TLS session is deleted or restarted.</span></span>

<span data-ttu-id="a894b-887">El prototipo de la función de limpieza es:</span><span class="sxs-lookup"><span data-stu-id="a894b-887">The prototype for the cleanup function is:</span></span>

```C
UINT crypto_cleanup_function(VOID *handle);
```
- <span data-ttu-id="a894b-888">El autor de llamada pasa “handle” a la función de limpieza.</span><span class="sxs-lookup"><span data-stu-id="a894b-888">handle is passed to the cleanup function by the caller.</span></span> <span data-ttu-id="a894b-889">La rutina de inicialización de cifrado inicializa “handle” y se usa para identificar el estado del algoritmo criptográfico.</span><span class="sxs-lookup"><span data-stu-id="a894b-889">The handle is initialized by the crypto initialization routine and used to identify cryptographic algorithm state.</span></span>

- <span data-ttu-id="a894b-890">Esta rutina devolverá *NX_SUCCESS* si el proceso de limpieza se realiza correctamente.</span><span class="sxs-lookup"><span data-stu-id="a894b-890">This routine shall return *NX_SUCCESS* if the cleanup process is successful.</span></span> <span data-ttu-id="a894b-891">El autor de llamada trata cualquier otro valor devuelto como error.</span><span class="sxs-lookup"><span data-stu-id="a894b-891">The caller treats any other return value as failure.</span></span>

- <span data-ttu-id="a894b-892">nx_crypto_operation: se trata de la rutina que realiza los servicios de cifrado, descifrado y autenticación reales.</span><span class="sxs-lookup"><span data-stu-id="a894b-892">nx_crypto_operation: This is the routine that performs the actual encryption, decryption, and authentication services.</span></span> <span data-ttu-id="a894b-893">El prototipo de función de la rutina de operación es:</span><span class="sxs-lookup"><span data-stu-id="a894b-893">The function prototype of the operation routine is:</span></span>

```C
UINT crypto_operation_function(UINT   op,
          VOID  *handle,  
          NX_CRYPTO_METHOD* method,
          UCHAR *key,
          UCHAR  key_size_in_bits,
          UCHAR* input,
          ULONG  input_length_in_byte,
          UCHAR* iv_ptr,
          UCHAR* output,
          ULONG  output_length_in_byte,
          VOID *crypto_metadata,
          ULONG crypto_metadata_size,
          NX_PACKET *packet_ptr,
          VOID (*nx_crypto_hw_process_callback)(NX_PACKET 
                          *packet_ptr, UINT status));
```

- <span data-ttu-id="a894b-894">“op” indica el tipo de operación que se espera que lleve a cabo esta rutina. Los valores válidos son:</span><span class="sxs-lookup"><span data-stu-id="a894b-894">op indicates the type of operation this routine is expected to carry out. Valid values are:</span></span>
    
    - <span data-ttu-id="a894b-895">NX_CRYPTO_ENCRYPT</span><span class="sxs-lookup"><span data-stu-id="a894b-895">NX_CRYPTO_ENCRYPT</span></span>
    - <span data-ttu-id="a894b-896">NX_CRYPTO_DECRYPT</span><span class="sxs-lookup"><span data-stu-id="a894b-896">NX_CRYPTO_DECRYPT</span></span>
    - <span data-ttu-id="a894b-897">NX_CRYPTO_AUTHENTICATE</span><span class="sxs-lookup"><span data-stu-id="a894b-897">NX_CRYPTO_AUTHENTICATE</span></span>
    - <span data-ttu-id="a894b-898">NX_CRYPTO_VERIFY</span><span class="sxs-lookup"><span data-stu-id="a894b-898">NX_CRYPTO_VERIFY</span></span>

- <span data-ttu-id="a894b-899">El autor de llamada pasa “handle” a la función de operación.</span><span class="sxs-lookup"><span data-stu-id="a894b-899">handle is passed to the operation function by the caller.</span></span> <span data-ttu-id="a894b-900">Se genera mediante la rutina de inicialización de cifrado.</span><span class="sxs-lookup"><span data-stu-id="a894b-900">It is generated by the crypto initialization routine.</span></span>
- <span data-ttu-id="a894b-901">“method” apunta al bloque de control del método criptográfico.</span><span class="sxs-lookup"><span data-stu-id="a894b-901">method points to the crypto method control block</span></span>
- <span data-ttu-id="a894b-902">“key” apunta a la clave secreta utilizada para esta operación.</span><span class="sxs-lookup"><span data-stu-id="a894b-902">key points to the secret key used for this operation</span></span>
- <span data-ttu-id="a894b-903">“key_size_in_bits” es el tamaño de la clave secreta en bits.</span><span class="sxs-lookup"><span data-stu-id="a894b-903">key_size_in_bits is the size of the secret key in bits</span></span>
- <span data-ttu-id="a894b-904">“input” es un puntero al principio del mensaje en el que se va a operar.</span><span class="sxs-lookup"><span data-stu-id="a894b-904">input is a pointer to the beginning of the message to be operated on.</span></span>
- <span data-ttu-id="a894b-905">el autor de la llamada pasa input_length_in_byte para indicar el tamaño del mensaje en el que se van a realizar operaciones.</span><span class="sxs-lookup"><span data-stu-id="a894b-905">input_length_in_byte is passed by the caller to indicate the size of the message to be operated on.</span></span>
- <span data-ttu-id="a894b-906">El autor de llamada configura “iv_ptr” para que apunte al principio de un bloque IV.</span><span class="sxs-lookup"><span data-stu-id="a894b-906">iv_ptr is setup by the caller to point to the beginning of an IV block.</span></span> <span data-ttu-id="a894b-907">Tenga en cuenta que el autor de llamada proporciona la memoria para el bloque IV.</span><span class="sxs-lookup"><span data-stu-id="a894b-907">Note that the memory for the IV block is provided by the caller.</span></span> <span data-ttu-id="a894b-908">En el cifrado, la función de operación debe escribir la información de IV en este bloque de memoria; en el descifrado, la función de operación debe recuperar la información de IV de este bloque de memoria.</span><span class="sxs-lookup"><span data-stu-id="a894b-908">For encryption, the operation function should write the IV information into this memory block; for decryption, the operation function should retrieve the IV information from this memory block.</span></span> <span data-ttu-id="a894b-909">Normalmente, los algoritmos para la operación de autenticación y comprobación no usan el vector de inicialización.</span><span class="sxs-lookup"><span data-stu-id="a894b-909">Algorithms for authentication and verification operation typically do not use the initialization vector.</span></span>
- <span data-ttu-id="a894b-910">El autor de llamada configura “output” para que apunte a un búfer de salida.</span><span class="sxs-lookup"><span data-stu-id="a894b-910">output is setup by the caller to point to an output buffer.</span></span> <span data-ttu-id="a894b-911">Tenga en cuenta que el autor de llamada proporciona la memoria para el búfer de salida.</span><span class="sxs-lookup"><span data-stu-id="a894b-911">Note that the memory for the output buffer is provided by the caller.</span></span> <span data-ttu-id="a894b-912">En el cifrado, la función de operación debe escribir el texto cifrado en el búfer de salida; en el descifrado, la operación debe escribir el texto descifrado (texto sin cifrar) en el búfer de salida; en la autenticación, el valor hash se escribirá en el búfer de salida.</span><span class="sxs-lookup"><span data-stu-id="a894b-912">For encryption, the operation function should write the cipher text to the output buffer; for decryption, the operation should write the deciphered text (clear text) to the output buffer; for authentication, the hash value shall be written to the output buffer.</span></span> <span data-ttu-id="a894b-913">En la comprobación, el búfer de salida se usa para almacenar información de hash.</span><span class="sxs-lookup"><span data-stu-id="a894b-913">For verification, the output buffer is used to store hash information.</span></span>
- <span data-ttu-id="a894b-914">“output_length_in_byte” indica el tamaño del búfer de salida.</span><span class="sxs-lookup"><span data-stu-id="a894b-914">output_length_in_byte indicates the size of the output buffer</span></span>
- <span data-ttu-id="a894b-915">“crypto_metadata” apunta al área de metadatos que va a usar esta operación de cifrado.</span><span class="sxs-lookup"><span data-stu-id="a894b-915">crypto_metadata points to the metadata area to be used by this crypto operation.</span></span> <span data-ttu-id="a894b-916">Normalmente, “crypto_init_function” inicializa el área de metadatos de cifrado.</span><span class="sxs-lookup"><span data-stu-id="a894b-916">The crypto metadata area is typically initialized by crypto_init_function.</span></span>
- <span data-ttu-id="a894b-917">“crypto_metadata_size” indica el tamaño del área de metadatos.</span><span class="sxs-lookup"><span data-stu-id="a894b-917">crypto_metadata_size indicates the size of the metadata area.</span></span>
- <span data-ttu-id="a894b-918">Esta rutina devolverá *NX_SUCCESS* si el proceso de operación se realiza correctamente.</span><span class="sxs-lookup"><span data-stu-id="a894b-918">This routine shall return *NX_SUCCESS* if the operation process is successful.</span></span> <span data-ttu-id="a894b-919">El autor de llamada trata cualquier otro valor devuelto como error.</span><span class="sxs-lookup"><span data-stu-id="a894b-919">The caller treats any other return value as failure.</span></span>
- <span data-ttu-id="a894b-920">“packet_ptr”: el paquete que contiene los datos que se están procesando.</span><span class="sxs-lookup"><span data-stu-id="a894b-920">packet_ptr: The packet that contains the data being processed.</span></span> <span data-ttu-id="a894b-921">NOTA: TLS no usa este parámetro y debe establecerse en NX_NULL.</span><span class="sxs-lookup"><span data-stu-id="a894b-921">NOTE: This parameter is unused by TLS and should be set to NX_NULL.</span></span>
- <span data-ttu-id="a894b-922">“nx_crypto_hw_process_callback”: una función de devolución de llamada proporcionada por el método de cifrado.</span><span class="sxs-lookup"><span data-stu-id="a894b-922">nx_crypto_hw_process_callback: A callback function provided by the encryption method.</span></span> <span data-ttu-id="a894b-923">Se usa si el hardware proporciona la función de cifrado y requiere una rutina de devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="a894b-923">This is used if the crypto function is provided by hardware and requires a callback routine.</span></span>

<span data-ttu-id="a894b-924">El servicio TLS de NetX Secure proporciona los siguientes métodos de cifrado:</span><span class="sxs-lookup"><span data-stu-id="a894b-924">NetX Secure TLS provides the following encryption methods:</span></span>

- <span data-ttu-id="a894b-925">*AES*</span><span class="sxs-lookup"><span data-stu-id="a894b-925">*AES*</span></span>  
- <span data-ttu-id="a894b-926">*RSA*</span><span class="sxs-lookup"><span data-stu-id="a894b-926">*RSA*</span></span>  
- <span data-ttu-id="a894b-927">*NULL*</span><span class="sxs-lookup"><span data-stu-id="a894b-927">*NULL*</span></span>

<span data-ttu-id="a894b-928">El servicio TLS de NetX Secure proporciona los siguientes métodos de autenticación:</span><span class="sxs-lookup"><span data-stu-id="a894b-928">NetX Secure TLS provides the following authentication methods:</span></span>

- <span data-ttu-id="a894b-929">*HMAC-MD5*</span><span class="sxs-lookup"><span data-stu-id="a894b-929">*HMAC-MD5*</span></span>  
- <span data-ttu-id="a894b-930">*HMAC-SHA1*</span><span class="sxs-lookup"><span data-stu-id="a894b-930">*HMAC-SHA1*</span></span>  
- <span data-ttu-id="a894b-931">*HMAC-SHA256*</span><span class="sxs-lookup"><span data-stu-id="a894b-931">*HMAC-SHA256*</span></span>

<span data-ttu-id="a894b-932">En los siguientes ejemplos se muestra cómo configurar la estructura *NX_CRYPTO_METHOD* para usar los métodos de cifrado y de autenticación proporcionados por el servicio IPSec de NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="a894b-932">The following examples illustrate how to configure the *NX_CRYPTO_METHOD* structure to use the encryption and authentication methods provided by NetX Duo IPsec.</span></span>

<span data-ttu-id="a894b-933">***AES:***</span><span class="sxs-lookup"><span data-stu-id="a894b-933">***AES:***</span></span>

```C
/* AES-CBC 128. */
NX_CRYPTO_METHOD crypto_method_aes_cbc_128 = 
{
    /* AES crypto algorithm                             */
    NX_CRYPTO_ENCRYPTION_AES_CBC,                       

    /* Key size in bits. For AES-128 this value is 128  */
    NX_CRYPTO_AES_128_KEY_LEN_IN_BITS,              
   
    /* IV size in bits.  For AES-128 this value is 128  */
    NX_CRYPTO_AES_IV_LEN_IN_BITS,

    /* ICV size in bits, not used.                      */
    0,                                              

    /* Block size in bytes.  For AES this value is 16   */
    (NX_CRYPTO_AES_BLOCK_SIZE_IN_BITS >> 3),        

    /* Metadata size in bytes, for AES this value is 262*/
    sizeof(NX_CRYPTO_AES),              

    /* AES-CBC initialization routine.                  */
    _nx_secure_crypto_method_aes_init,               

    /* AES-CBC cleanup routine, not used.               */
    NX_NULL,                                        

    /* AES-CBC operation                                */
    _nx_secure_crypto_method_aes_operation           
};

/* RSA. */
NX_CRYPTO_METHOD crypto_method_rsa = 
{
    /* RSA crypto algorithm                             */
    TLS_CIPHER_RSA,                       

    /* Key size. RSA key sizes vary, so set to 0.         */
    0,              
   
    /* IV size in bits.  RSA does not use an IV.         */
    0,

    /* ICV size in bits, not used.                      */
    0,                                              

    /* Block size in bytes.  RSA does not have a block size. */
    0,        

    /* Metadata size in bytes, for RSA use the control block. */
    sizeof(NX_CRYPTO_RSA),              

    /* RSA initialization routine.                  */
    _nx_secure_crypto_method_rsa_init,               

    /* Cleanup routine, not used.                    */
    NX_NULL,                                        

    /* RSA operation                                */
    _nx_secure_crypto_method_rsa_operation           

};
```
<span data-ttu-id="a894b-934">***NULL***</span><span class="sxs-lookup"><span data-stu-id="a894b-934">***NULL***</span></span>

```C
/* NULL encryption method. */
NX_CRYPTO_METHOD crypto_method_null = 
{
    NX_CRYPTO_ENCRYPTION_NULL,/* Name of the crypto algorithm  */
    0,                        /* Key size in bits, not used    */
    0,                        /* IV size in bits, not used     */
    0,                        /* ICV size in bits, not used    */
    4,                        /* Block size in bytes           */
    0,                        /* Metadata size in bytes        */
    NX_NULL,                  /* Initialization routine,unused */
    NX_NULL,                  /* Cleanup routine, not used     */
    _nx_secure_crypto_method_null_operation  /* NULL operation  
*/
}; 
```
<span data-ttu-id="a894b-935">***HMAC-SHA1***</span><span class="sxs-lookup"><span data-stu-id="a894b-935">***HMAC-SHA1***</span></span>
```C
NX_CRYPTO_METHOD crypto_method_hmac_sha1 = 
{
    /* HMAC SHA1 algorithm                               */
    TLS_HASH_SHA1,            


    /* Key size in bits. For HMAC-SHA1 this value is 160 */ 
    NX_CRYPTO_HMAC_SHA1_KEY_LEN_IN_BITS,              

    /* IV size in bits, not used                         */
    0,                                            

    /* Transmitted ICV size in bits. Unused.             */
    0, 

    /* Block size in bytes, not used                     */
    0,                                            

    /* Metadata size in bytes                            */
    sizeof(NX_SHA1_HMAC),                                            

    /* Initialization routine, not used                  */
    NX_NULL,                                      

    /* Cleanup routine, not used                         */
    NX_NULL,                                          

    /* HMAC SHA1 operation                               */
    _nx_secure_crypto_method_hmac_sha1_operation   
};
```
<span data-ttu-id="a894b-936">***NONE***</span><span class="sxs-lookup"><span data-stu-id="a894b-936">***NONE***</span></span>

<span data-ttu-id="a894b-937">Se usa un método especial **NX_CRYPTO_NONE** para indicar al módulo IPsec que el cifrado o el servicio de autenticación no son necesarios.</span><span class="sxs-lookup"><span data-stu-id="a894b-937">A special method **NX_CRYPTO_NONE** is used to signal the IPsec module that the encryption or the authentication service is not required.</span></span> <span data-ttu-id="a894b-938">Se configura de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="a894b-938">It is configured as follows:</span></span>

```C
/* NX_CRYPTO_NONE means encryption or authentication
   method is not needed.  */
NX_CRYPTO_METHOD crypto_method_none = 
{
    NX_CRYPTO_NONE,       /* Name of the crypto algorithm */
    0,                    /* Key size in bits, not used   */
    0,                    /* IV size in bits, not used    */
    0,                    /* ICV size in bits, not used   */
    0,                    /* Block size in bytes          */
    0,                    /* Metadata size in bytes       */
    NX_NULL,              /* Initialization routine, not used */
    NX_NULL,              /* Cleanup routine, not used    */
    NX_NULL               /* NULL operation               */
};                                               
```
### <a name="initializing-tls-with-cryptographic-methods"></a><span data-ttu-id="a894b-939">Inicialización de TLS con métodos criptográficos</span><span class="sxs-lookup"><span data-stu-id="a894b-939">Initializing TLS with Cryptographic Methods</span></span>

<span data-ttu-id="a894b-940">Una vez creadas las rutinas criptográficas conforme a las firmas de métodos criptográficos descritas en la sección anterior, tendrá que pasarlas a TLS al inicializar un bloque de control NX_SECURE_TLS_SESSION.</span><span class="sxs-lookup"><span data-stu-id="a894b-940">Once you have created your cryptographic routines conforming to the cryptographic method signatures described in the previous section, you will need to pass them into TLS when you initialize an NX_SECURE_TLS_SESSION control block.</span></span> <span data-ttu-id="a894b-941">Esto se hace en el servicio TLS nx_secure_tls_session_create:</span><span class="sxs-lookup"><span data-stu-id="a894b-941">This is done in the TLS service nx_secure_tls_session_create:</span></span>

```C
UINT  nx_secure_tls_session_create(
              NX_SECURE_TLS_SESSION*     session_ptr,
              const NX_SECURE_TLS_CRYPTO*    tls_cipher_table,
              VOID*                encryption_metadata_area,
              ULONG                 encryption_metadata_size
);
```
- <span data-ttu-id="a894b-942">“session_pointer” es un puntero al bloque de control NX_SECURE_TLS_SESSION.</span><span class="sxs-lookup"><span data-stu-id="a894b-942">session_pointer is a pointer to your NX_SECURE_TLS_SESSION control block.</span></span>
- <span data-ttu-id="a894b-943">“tls_cipher_table” es un puntero a un bloque de control NX_SECURE_TLS_CRYPTO, que se describe a continuación.</span><span class="sxs-lookup"><span data-stu-id="a894b-943">tls_cipher_table is a pointer to an NX_SECURE_TLS_CRYPTO control block, described below.</span></span>
- <span data-ttu-id="a894b-944">“encryption_metadata_area” apunta al espacio utilizado por las rutinas criptográficas en TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-944">encryption_metadata_area points to space used by cryptographic routines in TLS.</span></span>
- <span data-ttu-id="a894b-945">“encryption_metadata_size” es el tamaño del área de metadatos en bytes.</span><span class="sxs-lookup"><span data-stu-id="a894b-945">encryption_metadata_size is the size of the metadata area in bytes.</span></span>

### <a name="elliptic-curve-cryptography-ecc-in-netx-secure-tls"></a><span data-ttu-id="a894b-946">Criptografía de curva elíptica (ECC) en el servicio TLS de NetX Secure</span><span class="sxs-lookup"><span data-stu-id="a894b-946">Elliptic Curve Cryptography (ECC) in NetX Secure TLS</span></span>

<span data-ttu-id="a894b-947">La criptografía de curva elíptica (ECC) proporciona un esquema de criptografía de clave pública que se puede usar en lugar de RSA.</span><span class="sxs-lookup"><span data-stu-id="a894b-947">Elliptic Curve Cryptography (ECC) provides a public-key cryptography scheme that can be used instead of RSA.</span></span> <span data-ttu-id="a894b-948">ECC suele ser más rápido y usa claves más pequeñas que RSA, por lo que puede ser una opción valiosa para TLS integrado.</span><span class="sxs-lookup"><span data-stu-id="a894b-948">ECC is typically faster and uses smaller keys than RSA so it can be a valuable option for embedded TLS.</span></span> <span data-ttu-id="a894b-949">En las versiones de X-Ware anteriores a Azure RTOS 6.0, ECC se distribuía como un complemento que requería la instalación del código fuente ECC en el proyecto.</span><span class="sxs-lookup"><span data-stu-id="a894b-949">In X-Ware versions prior to Azure RTOS 6.0, ECC was shipped as an add-on, requiring installation of the ECC source code into your project.</span></span> <span data-ttu-id="a894b-950">Azure RTOS 6.0 ha integrado ECC en el código base principal, por lo que ya no es necesario instalar los archivos ECC.</span><span class="sxs-lookup"><span data-stu-id="a894b-950">Azure RTOS 6.0 integrated ECC into the mainline codebase so installation of the ECC files is no longer necessary.</span></span> <span data-ttu-id="a894b-951">Sin embargo, ECC todavía requiere la misma inicialización que las versiones anteriores.</span><span class="sxs-lookup"><span data-stu-id="a894b-951">However, ECC still requires the same initialization as those previous versions.</span></span>

### <a name="supported-ecc-curves"></a><span data-ttu-id="a894b-952">Curvas ECC admitidas</span><span class="sxs-lookup"><span data-stu-id="a894b-952">Supported ECC curves</span></span>

<span data-ttu-id="a894b-953">NetX Secure implementa partes de las curvas según <http://www.secg.org/sec2-v2.pdf>.</span><span class="sxs-lookup"><span data-stu-id="a894b-953">NetX Secure implements parts of the curves as per <http://www.secg.org/sec2-v2.pdf>.</span></span> <span data-ttu-id="a894b-954">Se admiten las siguientes curvas<sup>18</sup>:</span><span class="sxs-lookup"><span data-stu-id="a894b-954">Thefollowing curves are supported<sup>18</sup>:</span></span>

  - <span data-ttu-id="a894b-955">secp256r1</span><span class="sxs-lookup"><span data-stu-id="a894b-955">secp256r1</span></span> 
  - <span data-ttu-id="a894b-956">secp384r1</span><span class="sxs-lookup"><span data-stu-id="a894b-956">secp384r1</span></span> 
  - <span data-ttu-id="a894b-957">secp521r1</span><span class="sxs-lookup"><span data-stu-id="a894b-957">secp521r1</span></span> 

<span data-ttu-id="a894b-958">Si se usan otras curvas ECC, la rutina *nx_secure_tls_session_start ()* devolverá el error NX_SECURE_TLS_NO_SUPPORTED_CIPHERS, que indica que se han usado curvas no compatibles.</span><span class="sxs-lookup"><span data-stu-id="a894b-958">If other ECC curves are used, the *nx_secure_tls_session_start()* routine will return the error NX_SECURE_TLS_NO_SUPPORTED_CIPHERS indicating that unsupported curves were used.</span></span>

<span data-ttu-id="a894b-959">Tenga en cuenta que la cadena de certificados de TLS también se puede cifrar mediante algoritmos ECC.</span><span class="sxs-lookup"><span data-stu-id="a894b-959">Note that TLS certificate chain may be encrypted by ECC-algorithms as well.</span></span> <span data-ttu-id="a894b-960">Aunque se admiten las curvas proporcionadas por el cliente TLS, es posible que no se admita la curva ECC usada en la cadena de certificados.</span><span class="sxs-lookup"><span data-stu-id="a894b-960">Even though the curves provided by the TLS Client are supported, it is possible that the ECC curve used in the certificate chain is not supported.</span></span> <span data-ttu-id="a894b-961">En este caso, la rutina *nx_secure_tls_session_start* devuelve NX_SECURE_TLS_UNSUPPORTED_PUBLIC_CIPHER.</span><span class="sxs-lookup"><span data-stu-id="a894b-961">In this case, *nx_secure_tls_session_start* routine returns NX_SECURE_TLS_UNSUPPORTED_PUBLIC_CIPHER.</span></span>

<span data-ttu-id="a894b-962">En nx_crypto_generic_ciphersuites. c se proporciona un ejemplo de tabla de conjuntos de cifrado predeterminados para ECC.</span><span class="sxs-lookup"><span data-stu-id="a894b-962">A default ciphersuite table example for ECC is provided in nx_crypto_generic_ciphersuites.c.</span></span> <span data-ttu-id="a894b-963">Consulte la sección “Tabla de cifrado criptográfico de TLS” para obtener más información sobre las tablas de conjuntos de cifrado.</span><span class="sxs-lookup"><span data-stu-id="a894b-963">See section "TLS Cryptographic Cipher Table" for more information on ciphersuite tables.</span></span>

18. <span data-ttu-id="a894b-964">Tenga en cuenta que las implementaciones para las curvas secp192r1 y secp224r1are también se proporcionan para las aplicaciones heredadas.</span><span class="sxs-lookup"><span data-stu-id="a894b-964">Note that implementations for the curves secp192r1 and secp224r1are also provided for legacy applications.</span></span> <span data-ttu-id="a894b-965">Sin embargo, estas curvas ahora se consideran débiles y no deben usarse para el desarrollo de nuevas aplicaciones.</span><span class="sxs-lookup"><span data-stu-id="a894b-965">However these curves are now considered weak and SHOULD NOT be used for new application development.</span></span>

### <a name="crypto-methods-for-ecc"></a><span data-ttu-id="a894b-966">Métodos criptográficos para ECC</span><span class="sxs-lookup"><span data-stu-id="a894b-966">Crypto Methods for ECC</span></span>

<span data-ttu-id="a894b-967">Métodos criptográficos para grupos de curva elíptica:</span><span class="sxs-lookup"><span data-stu-id="a894b-967">Crypto methods for Elliptic Curve groups:</span></span>

- <span data-ttu-id="a894b-968">NX_CRYPTO_METHOD crypto_method_ec_secp192<sup>15</sup>;</span><span class="sxs-lookup"><span data-stu-id="a894b-968">NX_CRYPTO_METHOD crypto_method_ec_secp192<sup>15</sup>;</span></span>  
- <span data-ttu-id="a894b-969">NX_CRYPTO_METHOD crypto_method_ec_secp224<sup>15</sup>;</span><span class="sxs-lookup"><span data-stu-id="a894b-969">NX_CRYPTO_METHOD crypto_method_ec_secp224<sup>15</sup>;</span></span>  
- <span data-ttu-id="a894b-970">NX_CRYPTO_METHOD crypto_method_ec_secp256;</span><span class="sxs-lookup"><span data-stu-id="a894b-970">NX_CRYPTO_METHOD crypto_method_ec_secp256;</span></span>  
- <span data-ttu-id="a894b-971">NX_CRYPTO_METHOD crypto_method_ec_secp384;</span><span class="sxs-lookup"><span data-stu-id="a894b-971">NX_CRYPTO_METHOD crypto_method_ec_secp384;</span></span>  
- <span data-ttu-id="a894b-972">NX_CRYPTO_METHOD crypto_method_ec_secp521;</span><span class="sxs-lookup"><span data-stu-id="a894b-972">NX_CRYPTO_METHOD crypto_method_ec_secp521;</span></span>

<span data-ttu-id="a894b-973">Los métodos criptográficos para las curvas ECC se definen en nx_crypto_generic_ciphersuites.c.</span><span class="sxs-lookup"><span data-stu-id="a894b-973">The crypto methods for ECC curves are defined in nx_crypto_generic_ciphersuites.c.</span></span>

<span data-ttu-id="a894b-974">Método criptográfico para ECDHE:</span><span class="sxs-lookup"><span data-stu-id="a894b-974">Crypto method for ECDHE:</span></span>

- <span data-ttu-id="a894b-975">NX_CRYPTO_METHOD crypto_method_ecdhe;</span><span class="sxs-lookup"><span data-stu-id="a894b-975">NX_CRYPTO_METHOD crypto_method_ecdhe;</span></span>

<span data-ttu-id="a894b-976">Crypto method for ECDSA:</span><span class="sxs-lookup"><span data-stu-id="a894b-976">Crypto method for ECDSA:</span></span>

- <span data-ttu-id="a894b-977">NX_CRYPTO_METHOD crypto_method_ecdsa;</span><span class="sxs-lookup"><span data-stu-id="a894b-977">NX_CRYPTO_METHOD crypto_method_ecdsa;</span></span>

<span data-ttu-id="a894b-978">Los métodos criptográficos ECDSA y ECDHE se definen en nx_crypto_generic_ciphersuites.c.</span><span class="sxs-lookup"><span data-stu-id="a894b-978">ECDSA and ECDHE crypto methods are defined in nx_crypto_generic_ciphersuites.c.</span></span>

<span data-ttu-id="a894b-979">Combinado con otros métodos de cifrado, como RSA, SHA, AES, se pueden usar como bloques de creación para la tabla de búsqueda de conjuntos de cifrado.</span><span class="sxs-lookup"><span data-stu-id="a894b-979">Combined with other crypto methods such as RSA, SHA, AES, they can be used as building blocks for the ciphersuite lookup table.</span></span>

### <a name="enabling-ecc-support-for-tls"></a><span data-ttu-id="a894b-980">Habilitación de la compatibilidad con ECC para TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-980">Enabling ECC Support for TLS</span></span>

<span data-ttu-id="a894b-981">ECC está habilitado de forma predeterminada para TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-981">ECC is enabled by default for TLS.</span></span> <span data-ttu-id="a894b-982">Para deshabilitar la compatibilidad con ECC, se debe definir el símbolo NX_SECURE_DISABLE_ECC_CIPHERSUITE.</span><span class="sxs-lookup"><span data-stu-id="a894b-982">To disable ECC support, the symbol NX_SECURE_DISABLE_ECC_CIPHERSUITE must be defined.</span></span>

<span data-ttu-id="a894b-983">Para que el cambio surta efecto, debe volver a generar la biblioteca de NetX Secure y todas las aplicaciones que usen esa biblioteca.</span><span class="sxs-lookup"><span data-stu-id="a894b-983">For the change to take effect, you will need to rebuild the NetX Secure Library and all applications that use that library.</span></span>

<span data-ttu-id="a894b-984">En el código de la aplicación, se debe llamar a la API n *x_secure_tls_ecc_initialize ()* después de crear la sesión de TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-984">In the application code, the API n *x_secure_tls_ecc_initialize()* must be called after the TLS session is created.</span></span> <span data-ttu-id="a894b-985">Esta API notifica a la sesión de TLS el tipo de curvas que se va a usar para las operaciones de intercambio de claves TLS y la comprobación de certificados.</span><span class="sxs-lookup"><span data-stu-id="a894b-985">This API notifies the TLS session of the type of curves to be used for TLS key exchange operations and certificate verification.</span></span> <span data-ttu-id="a894b-986">Durante la fase de protocolo de enlace TLS, si se selecciona un algoritmo de ECC, los parámetros relacionados con la curva ECC de intercambio de cliente y servidor determinan la curva que se usará.</span><span class="sxs-lookup"><span data-stu-id="a894b-986">During the TLS handshake phase, if an ECC algorithm is selected the client and server exchange ECC curve-related parameters to decide which curve to use.</span></span>

<span data-ttu-id="a894b-987">El siguiente fragmento de código muestra cómo se debe usar la API.</span><span class="sxs-lookup"><span data-stu-id="a894b-987">The following code segment illustrates how to use the API.</span></span> <span data-ttu-id="a894b-988">Tenga en cuenta que todos los argumentos (*nx_crypto_ecc_supported_groups, nx_crypto_ecc_supported_groups_size, and nx_crypto_ecc_curves)* se definen en *nx_crypto_generic_ciphersuites.c*.</span><span class="sxs-lookup"><span data-stu-id="a894b-988">Note that the arguments (*nx_crypto_ecc_supported_groups, nx_crypto_ecc_supported_groups_size, and nx_crypto_ecc_curves)* are all defined in *nx_crypto_generic_ciphersuites.c*.</span></span> <span data-ttu-id="a894b-989">Por lo tanto, estos símbolos se pueden usar directamente.</span><span class="sxs-lookup"><span data-stu-id="a894b-989">Therefore these symbols can be used directly.</span></span>

```C
status = nx_secure_tls_ecc_initialize(&tls_session,     
                    nx_crypto_ecc_supported_groups,      
                    nx_crypto_ecc_supported_groups_size,     
                    nx_crypto_ecc_curves);
```
<span data-ttu-id="a894b-990">La configuración de ejemplo de nx_crypto_generic_ciphersuites.c contiene una tabla de búsqueda de conjuntos de cifrado ECC que se utiliza cuando se habilita ECC.</span><span class="sxs-lookup"><span data-stu-id="a894b-990">The example configuration in nx_crypto_generic_ciphersuites.c contains an ECC ciphersuite lookup table that is used when ECC is enabled.</span></span> <span data-ttu-id="a894b-991">Para usar ECC, solo tiene que pasar nx_crypto_tls_ciphers_ecc como el parámetro de la tabla de conjuntos de cifrado al crear sesiones de TLS con nx_secure_tls_session_create.</span><span class="sxs-lookup"><span data-stu-id="a894b-991">To use ECC, simply pass nx_crypto_tls_ciphers_ecc as the ciphersuite table parameter when creating TLS sessions with nx_secure_tls_session_create.</span></span> <span data-ttu-id="a894b-992">La tabla de ejemplo contiene ECC y no conjuntos de cifrado ECC.</span><span class="sxs-lookup"><span data-stu-id="a894b-992">The example table contains both ECC and non-ECC ciphersuites.</span></span>

### <a name="tls-cryptographic-cipher-table"></a><span data-ttu-id="a894b-993">Tabla de cifrado criptográfico de TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-993">TLS Cryptographic Cipher Table</span></span>

<span data-ttu-id="a894b-994">La estructura NX_SECURE_TLS_CRYPTO se define como:</span><span class="sxs-lookup"><span data-stu-id="a894b-994">The NX_SECURE_TLS_CRYPTO structure is defined as:</span></span>

```C
typedef struct NX_SECURE_METHODS_STRUCT
{
    /* Table that maps ciphersuites to crypto methods. */
    NX_SECURE_TLS_CIPHERSUITE_INFO* nx_secure_tls_ciphersuite_lookup_table;
    USHORT nx_secure_tls_ciphersuite_lookup_table_size;

    /* Table that maps X.509 cipher identifiers to crypto methods. */
    NX_SECURE_X509_CRYPTO *nx_secure_tls_x509_cipher_table;
    USHORT nx_secure_tls_x509_cipher_table_size;

    /* Specific routines needed for specific TLS versions. */
#if (NX_SECURE_TLS_TLS_1_0_ENABLED || NX_SECURE_TLS_TLS_1_1_ENABLED)
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_md5_method;
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_sha1_method;
    NX_CRYPTO_METHOD *nx_secure_tls_prf_1_method;
#endif

#if (NX_SECURE_TLS_TLS_1_2_ENABLED)
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_sha256_method;
    NX_CRYPTO_METHOD *nx_secure_tls_prf_sha256_method;
#endif

#if (NX_SECURE_TLS_TLS_1_3_ENABLED)
    const NX_CRYPTO_METHOD *nx_secure_tls_hkdf_method;
    const NX_CRYPTO_METHOD *nx_secure_tls_hmac_method;
    const NX_CRYPTO_METHOD *nx_secure_tls_ecdhe_method;
#endif

} NX_SECURE_TLS_CRYPTO;
```
<span data-ttu-id="a894b-995">La tabla se crea rellenando las entradas de esta estructura en una constante estática ubicada en el proyecto TLS de NetX Secure, que normalmente se encuentra en las rutinas criptográficas y los módulos.</span><span class="sxs-lookup"><span data-stu-id="a894b-995">The table is created by filling in the entries for this structure in a static constant located within the NetX Secure TLS project, usually located with the cryptographic routines and modules.</span></span>

<span data-ttu-id="a894b-996">Por ejemplo, la biblioteca criptográfica de solo software (“genérica”) proporcionada con NetX Secure contiene la siguiente definición de tabla (para la compatibilidad con conjuntos de cifrado que no son ECC<sup>19</sup>):</span><span class="sxs-lookup"><span data-stu-id="a894b-996">As an example, the software-only ("generic") cryptographic library provided with NetX Secure contains the following table definition (for non-ECC ciphersuite support<sup>19</sup>):</span></span>

```C
/* Define the cipher table object we can pass into TLS. */
const NX_SECURE_TLS_CRYPTO nx_crypto_tls_ciphers =
{
    /* TLS Ciphersuite lookup table and size. */
    _nx_crypto_ciphersuite_lookup_table,
    sizeof(_nx_crypto_ciphersuite_lookup_table) / 
    sizeof(NX_SECURE_TLS_CIPHERSUITE_INFO),

    /* X.509 certificate cipher table and size. */
    _nx_crypto_x509_cipher_lookup_table,
    sizeof(_nx_crypto_x509_cipher_lookup_table) / sizeof(NX_SECURE_X509_CRYPTO),

    /* TLS version-specific methods. */
#if (NX_SECURE_TLS_TLS_1_0_ENABLED || NX_SECURE_TLS_TLS_1_1_ENABLED)
    &crypto_method_md5,
    &crypto_method_sha1,
    &crypto_method_tls_prf_1,
#endif

#if (NX_SECURE_TLS_TLS_1_2_ENABLED)
    &crypto_method_sha256,
    &crypto_method_tls_prf_sha_256
#endif

#if (NX_SECURE_TLS_TLS_1_3_ENABLED)
    &crypto_method_hkdf,
    &crypto_method_hmac,
    &crypto_method_ecdhe,
#endif
};
```
<span data-ttu-id="a894b-997">En la estructura, la primera entrada es la tabla de conjuntos de cifrado de TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-997">In the structure, the first entry is the TLS ciphersuite table.</span></span> <span data-ttu-id="a894b-998">La estructura NX_SECURE_TLS_CIPHERSUITE_INFO asigna las rutinas criptográficas (en forma de punteros de NX_CRYPTO_METHOD) a conjuntos de cifrado específicos, tal como se define en las especificaciones de TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-998">The NX_SECURE_TLS_CIPHERSUITE_INFO structure maps cryptographic routines (in the form of NX_CRYPTO_METHOD pointers) to specific ciphersuites as defined in the TLS specifications.</span></span> <span data-ttu-id="a894b-999">El segundo valor es el número de entradas de la tabla a las que apunta el primer campo.</span><span class="sxs-lookup"><span data-stu-id="a894b-999">The second value is the number of entries in the table pointed to by the first field.</span></span>

<span data-ttu-id="a894b-1000">El campo siguiente apunta a una tabla de rutinas que usa X.509 al procesar certificados digitales y el formato de la estructura NX_SECURE_X509_CRYPTO es similar a NX_SECURE_TLS_CIPHERSUITE_INFO.</span><span class="sxs-lookup"><span data-stu-id="a894b-1000">The next field points to a table of routines used by X.509 when processing digital certificates and the structure NX_SECURE_X509_CRYPTO is similar in form to NX_SECURE_TLS_CIPHERSUITE_INFO.</span></span> <span data-ttu-id="a894b-1001">El siguiente campo es el número de entradas de la tabla.</span><span class="sxs-lookup"><span data-stu-id="a894b-1001">The following field is the number of entries in the table.</span></span>

<span data-ttu-id="a894b-1002">Después de la tabla de búsqueda hay una serie de rutinas necesarias para las versiones específicas de TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-1002">Following the lookup table are a number of routines needed for specific versions of TLS.</span></span> <span data-ttu-id="a894b-1003">Por ejemplo, antes de TLS 1.2, las rutinas de generación de claves y hash de protocolo de enlace se corrigieron para usar una combinación de SHA-1 y MD5; los métodos de estas rutinas se llaman específicamente en la estructura de cifrado, ya que no están vinculados a conjuntos de cifrado específicos.</span><span class="sxs-lookup"><span data-stu-id="a894b-1003">For example, prior to TLS version 1.2, the key generation and handshake hashing routines were fixed to use a combination of SHA-1 and MD5 – the methods for these routines are called out specifically in the cipher structure since they are not tied to specific ciphersuites.</span></span> <span data-ttu-id="a894b-1004">En TLS 1.2, las rutinas de generación de claves y hash se eligen mediante el conjunto de cifrado, pero para conjuntos de cifrado que no especifican las rutinas que se van a usar, se usa el método hash SHA-256 y la estructura de cifrado llama específicamente a esa rutina.</span><span class="sxs-lookup"><span data-stu-id="a894b-1004">In TLS version 1.2, the key generation and hashing routines are chosen by the ciphersuite, but for ciphersuites which do not specify the routines to use, the SHA-256 hash method is used, and the cipher structure calls out that routine specifically.</span></span>

<span data-ttu-id="a894b-1005">TLS 1.3 requiere algunos cifrados específicos adicionales para varias operaciones.</span><span class="sxs-lookup"><span data-stu-id="a894b-1005">TLS 1.3 requires a few extra specific ciphers for various operations.</span></span>

19. <span data-ttu-id="a894b-1006">Tenga en cuenta que la compatibilidad con TLS 1.3 requiere ECC: el uso de nx_crypto_tls_ciphers_ecc si TLS 1,3 está habilitado.</span><span class="sxs-lookup"><span data-stu-id="a894b-1006">Note that TLS 1.3 support requires ECC – use nx_crypto_tls_ciphers_ecc if TLS 1.3 is enabled.</span></span>

### <a name="tls-ciphersuite-lookup-table"></a><span data-ttu-id="a894b-1007">Tabla de búsqueda de conjuntos de cifrado de TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-1007">TLS Ciphersuite Lookup Table</span></span>

<span data-ttu-id="a894b-1008">Para rellenar la tabla de cifrado para TLS, también deberá crear una tabla de búsqueda de conjuntos de cifrado que asigne rutinas criptográficas a identificadores de conjuntos de cifrado específicos.</span><span class="sxs-lookup"><span data-stu-id="a894b-1008">To fill in the cipher table for TLS, you will also need to create a ciphersuite lookup table that maps cryptographic routines to specific ciphersuite identifiers.</span></span> <span data-ttu-id="a894b-1009">Los identificadores son valores registrados por IANA que son universales.</span><span class="sxs-lookup"><span data-stu-id="a894b-1009">The identifiers are IANA-registered values that are universal.</span></span> <span data-ttu-id="a894b-1010">Consulte las RFC de TLS para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="a894b-1010">See the TLS RFCs for more information.</span></span> <span data-ttu-id="a894b-1011">Las rutinas representan los 5 métodos independientes usados en cada conjunto de cifrado (algunos conjuntos no pueden usar los 5): cifrado público, autenticación de clave pública, cifrado de sesión, rutina de hash de sesión y función de pseudoaleatoria de TLS (PRF).</span><span class="sxs-lookup"><span data-stu-id="a894b-1011">The routines represent the 5 separate methods used in each ciphersuite (some ciphersuites may not use all 5): public cipher, public-key authentication, session cipher, session hash routine, and TLS Pseudo-Random Function (PRF).</span></span> <span data-ttu-id="a894b-1012">En la tabla siguiente se explica cada uno de los cinco métodos:</span><span class="sxs-lookup"><span data-stu-id="a894b-1012">The following table explains each of the 5 methods:</span></span>

| <span data-ttu-id="a894b-1013">**Categoría de rutina**</span><span class="sxs-lookup"><span data-stu-id="a894b-1013">**Routine category**</span></span>      | <span data-ttu-id="a894b-1014">**Descripción**</span><span class="sxs-lookup"><span data-stu-id="a894b-1014">**Description**</span></span>                                                                                       | <span data-ttu-id="a894b-1015">**Algoritmos de ejemplo**</span><span class="sxs-lookup"><span data-stu-id="a894b-1015">**Example algorithms**</span></span>                                            |
| ------------------------- | ----------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------- |
| <span data-ttu-id="a894b-1016">Cifrado público</span><span class="sxs-lookup"><span data-stu-id="a894b-1016">Public cipher</span></span>             | <span data-ttu-id="a894b-1017">Se usa para intercambiar claves durante el protocolo de enlace TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-1017">Used to exchange keys during the TLS handshake</span></span>                                                        | <span data-ttu-id="a894b-1018">RSA, Diffie-Hellman, ECC</span><span class="sxs-lookup"><span data-stu-id="a894b-1018">RSA, Diffie-Hellman, ECC</span></span>                                          |
| <span data-ttu-id="a894b-1019">Autenticación de clave pública</span><span class="sxs-lookup"><span data-stu-id="a894b-1019">Public-key authentication</span></span> | <span data-ttu-id="a894b-1020">Se usa para autenticar o firmar datos durante el protocolo de enlace TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-1020">Used to authenticate or sign data during the TLS handshake</span></span>                                            | <span data-ttu-id="a894b-1021">RSA, DSS</span><span class="sxs-lookup"><span data-stu-id="a894b-1021">RSA, DSS</span></span>                                                          |
| <span data-ttu-id="a894b-1022">Cifrado de sesión</span><span class="sxs-lookup"><span data-stu-id="a894b-1022">Session cipher</span></span>            | <span data-ttu-id="a894b-1023">Algoritmo de clave simétrica que se usa para cifrar los datos de la aplicación durante la sesión de TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-1023">Symmetric-key algorithm used to encrypt application data during the TLS session</span></span>                       | <span data-ttu-id="a894b-1024">AES, RC4</span><span class="sxs-lookup"><span data-stu-id="a894b-1024">AES, RC4</span></span>                                                          |
| <span data-ttu-id="a894b-1025">Hash de sesión</span><span class="sxs-lookup"><span data-stu-id="a894b-1025">Session hash</span></span>              | <span data-ttu-id="a894b-1026">Se usa para conservar la integridad de los mensajes durante la sesión de TLS (garantiza que los datos no han cambiado)</span><span class="sxs-lookup"><span data-stu-id="a894b-1026">Used to preserve the integrity of messages during the TLS session (assures that data has not changed)</span></span> | <span data-ttu-id="a894b-1027">SHA-1, SHA-256</span><span class="sxs-lookup"><span data-stu-id="a894b-1027">SHA-1, SHA-256</span></span>                                                    |
| <span data-ttu-id="a894b-1028">PRF DE TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-1028">TLS PRF</span></span>                   | <span data-ttu-id="a894b-1029">Se usa para generar material de clave y en el hash de protocolo de enlace del protocolo de enlace TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-1029">Used to generate key material and in the handshake hash in the TLS handshake</span></span>                          | <span data-ttu-id="a894b-1030">La PRF se basa en rutinas hash (SHA-1 + MD5, SHA-256, SHA-512).</span><span class="sxs-lookup"><span data-stu-id="a894b-1030">The PRF is based on hash routines – SHA-1 + MD5, SHA-256, SHA-512</span></span> |

<span data-ttu-id="a894b-1031">La estructura NX_SECURE_TLS_CIPHERSUITE_INFO se define de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="a894b-1031">The NX_SECURE_TLS_CIPHERSUITE_INFO structure is defined as follows:</span></span>

```C
typedef struct NX_SECURE_TLS_CIPHERSUITE_INFO_struct
{
    /* The IANA value of the ciphersuite as defined by the TLS spec.*/
    USHORT nx_secure_tls_ciphersuite;

    /* The Public Key operation in this suite - RSA or DH. */
    NX_CRYPTO_METHOD *nx_secure_tls_public_cipher;

    /* The Public Authentication method used for signing data. */
    NX_CRYPTO_METHOD *nx_secure_tls_public_auth;

    /* The session cipher being used - AES, RC4, etc. */
    NX_CRYPTO_METHOD *nx_secure_tls_session_cipher;

    /* The size of the initialization vectors for the session cipher (bytes).*/
    USHORT nx_secure_tls_iv_size;

    /* The key size for the session cipher (bytes). */
    UCHAR nx_secure_tls_session_key_size;

    /* The hash being used - MD5, SHA-1, SHA-256, etc. */
    NX_CRYPTO_METHOD *nx_secure_tls_hash;

    /* The size of the hash being used. SHA-1 is 20 bytes, MD5 is 16 bytes.*/
    USHORT nx_secure_tls_hash_size;

    /* The TLS PRF being used – this is only for TLSv1.2. */
    NX_CRYPTO_METHOD *nx_secure_tls_prf;

} NX_SECURE_TLS_CIPHERSUITE_INFO;
```
<span data-ttu-id="a894b-1032">El campo nx_secure_tls_ciphersuite contiene el valor de conjunto de cifrado de IANA y los punteros de NX_CRYPTO_METHOD representan los 5 métodos usados por dicho conjunto.</span><span class="sxs-lookup"><span data-stu-id="a894b-1032">The nx_secure_tls_ciphersuite field contains the IANA ciphersuite value, and the NX_CRYPTO_METHOD pointers represent the 5 methods used by that ciphersuite.</span></span> <span data-ttu-id="a894b-1033">Los valores escalares (nx_secure_tls_iv_size, nx_secure_tls_key_size y nx_secure_tls_hash_size) son informativos y proporcionan información que podría no estar disponible en las entradas de NX_CRYPTO_METHOD.</span><span class="sxs-lookup"><span data-stu-id="a894b-1033">The scalar values (nx_secure_tls_iv_size, nx_secure_tls_key_size, and nx_secure_tls_hash_size) are informational, providing information that might not be available in the NX_CRYPTO_METHOD entries.</span></span>

<span data-ttu-id="a894b-1034">Como ejemplo, veremos el valor predeterminado del conjunto de cifrado para TLS, TLS_RSA_WITH_AES_128_CBC_SHA, que especifica el uso de RSA, AES-CBC con claves de 128 bits y SHA-1 para el hash de sesión.</span><span class="sxs-lookup"><span data-stu-id="a894b-1034">As an example, we will look at the default ciphersuite for TLS, TLS_RSA_WITH_AES_128_CBC_SHA, which specifies the use of RSA, AES-CBC with 128-bit keys, and SHA-1 for session hashing.</span></span> <span data-ttu-id="a894b-1035">No se ha especificado ninguna PRF de TLS para este conjunto de cifrado, por lo que en el modo TLSv 1.2 usará el valor predeterminado de PRF SHA-256.</span><span class="sxs-lookup"><span data-stu-id="a894b-1035">No TLS PRF is specified for this ciphersuite, so in TLSv1.2 mode, it will use the default SHA-256 PRF.</span></span> <span data-ttu-id="a894b-1036">Tenga en cuenta que todos los conjuntos de cifrado usan la PRF SHA-1 + MD5 en TLS 1.0 y 1,1, independientemente de la PRF especificada en la tabla.</span><span class="sxs-lookup"><span data-stu-id="a894b-1036">Note that all ciphersuites use the SHA-1+MD5 PRF in TLS 1.0 and 1.1, regardless of the PRF specified in the table.</span></span>

<span data-ttu-id="a894b-1037">La entrada de la tabla NX_SECURE_TLS_CIPHERSUITE_INFO de la biblioteca de cifrado genérica se define de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="a894b-1037">The entry in the NX_SECURE_TLS_CIPHERSUITE_INFO table in the generic cryptographic library is defined as follows:</span></span>

```C
{ 
  TLS_RSA_WITH_AES_128_CBC_SHA,     /* Ciphersuite identifier */
  &crypto_method_rsa,               /* Public-key cipher (NX_CRYPTO_METHOD)*/
  &crypto_method_rsa,               /* Authentication method(NX_CRYPTO_METHOD)*/
  &crypto_method_aes_cbc_128,       /* Session cipher method(NX_CRYPTO_METHOD)*/
  16,                               /* Session cipher IV size in bytes */
  16,                               /* Session cipher key size in bytes */
  &crypto_method_hmac_sha1,         /* Session hash routine(NX_CRYPTO_METHOD) */
  20,                               /* Session hash output size in bytes */
  &crypto_method_tls_prf_sha_256    /* TLSv1.2 PRF */
},
```

<span data-ttu-id="a894b-1038">Tenga en cuenta que para el cifrado de la sesión el tamaño de la clave viene determinado por el conjunto de cifrado, pero para los métodos de clave pública no se conoce el tamaño de la clave hasta que el protocolo de enlace TLS está en curso, ya que las claves públicas están contenidas en los certificados digitales intercambiados durante el protocolo de enlace.</span><span class="sxs-lookup"><span data-stu-id="a894b-1038">Note that for the session cipher the key size is determined by the ciphersuite, but for the public-key methods the key size is not known until the TLS handshake is underway since the public keys are contained in the digital certificates exchanged during the handshake.</span></span>

### <a name="x509-cipher-lookup-table"></a><span data-ttu-id="a894b-1039">Tabla de búsqueda de cifrado de X.509</span><span class="sxs-lookup"><span data-stu-id="a894b-1039">X.509 Cipher Lookup Table</span></span>

<span data-ttu-id="a894b-1040">Al igual que la tabla NX_SECURE_TLS_CIPHERSUITE_INFO, la estructura NX_SECURE_X509_CRYPTO asigna rutinas criptográficas a valores conocidos.</span><span class="sxs-lookup"><span data-stu-id="a894b-1040">Like the NX_SECURE_TLS_CIPHERSUITE_INFO table, the NX_SECURE_X509_CRYPTO structure maps cryptographic routines to known values.</span></span> <span data-ttu-id="a894b-1041">En el caso de X.509, los identificadores son, en realidad, los OID definidos por X.509 y se registran con los cuerpos de los estándares ISO e ITU.</span><span class="sxs-lookup"><span data-stu-id="a894b-1041">In the case of X.509, the identifiers are actually OIDs defined by X.509 and registered with the ISO and ITU standards bodies.</span></span> <span data-ttu-id="a894b-1042">Los OID son valores multibyte de longitud variable diseñados para identificar de forma exclusiva diversa información en diversos estándares de telecomunicación, incluidas las rutinas criptográficas utilizadas en los certificados digitales.</span><span class="sxs-lookup"><span data-stu-id="a894b-1042">OIDs are variable-length multi-byte values designed to uniquely identify various information in various telecommunication standards, including cryptographic routines used in digital certificates.</span></span> <span data-ttu-id="a894b-1043">Debido al hecho de que los OID son de longitud variable, el servicio TLS de NetX Secure asigna los valores de OID oficiales a las constantes de longitud fija que se usan internamente (consulte nx_secure_x509.h).</span><span class="sxs-lookup"><span data-stu-id="a894b-1043">Due to the fact that OIDs are variable length, NetX Secure TLS maps the official OID values to fixed-length constants that are used internally (see nx_secure_x509.h).</span></span> <span data-ttu-id="a894b-1044">Estas constantes se utilizan en la estructura NX_SECURE_X509_CRYPTO, que se define de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="a894b-1044">These constants are used in the NX_SECURE_X509_CRYPTO structure, which is defined as follows:</span></span>

```C
/* Structure to hold X.509 cryptographic routine information. */
typedef struct NX_SECURE_X509_CRYPTO_struct
{
    /* Internal NetX Secure identifier for certificate "ciphersuite" which consists
       of a hash and a public key operation. These can be mapped to OIDs in X.509.
        */
    USHORT nx_secure_x509_crypto_identifier;

    /* Public-Key Cryptographic method used by certificates. */
    NX_CRYPTO_METHOD *nx_secure_x509_public_cipher_method;

    /* Hash method used by certificates. */
    NX_CRYPTO_METHOD *nx_secure_x509_hash_method;
} NX_SECURE_X509_CRYPTO;
```

<span data-ttu-id="a894b-1045">El primer campo, *nx_secure_x509_crypto_identifier*, es la representación interna de OID usada por NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="a894b-1045">The first field, *nx_secure_x509_crypto_identifier*, is the internal OID representation used by NetX Secure.</span></span>

<span data-ttu-id="a894b-1046">Los campos segundo y tercero apuntan a objetos NX_CRYPTO_METHOD que representan los métodos criptográficos identificados por el OID, una operación de clave pública emparejada con una rutina hash.</span><span class="sxs-lookup"><span data-stu-id="a894b-1046">The second and third fields point to NX_CRYPTO_METHOD objects that represent the cryptographic methods identified by the OID, a public-key operation paired with a hash routine.</span></span> <span data-ttu-id="a894b-1047">Tenga en cuenta que cada certificado digital puede tener más de un OID para las rutinas criptográficas.</span><span class="sxs-lookup"><span data-stu-id="a894b-1047">Note that each digital certificate may have more than one OID for cryptographic routines.</span></span>

<span data-ttu-id="a894b-1048">La tabla de métodos de X.509 se construye de la misma manera que la tabla de búsqueda de conjuntos de cifrado.</span><span class="sxs-lookup"><span data-stu-id="a894b-1048">The method table for X.509 is constructed in the same manner as the ciphersuite lookup table.</span></span> <span data-ttu-id="a894b-1049">Como ejemplo, veremos el OID de RSA_SHA1.</span><span class="sxs-lookup"><span data-stu-id="a894b-1049">As an example, we will look at the OID for RSA_SHA1.</span></span> <span data-ttu-id="a894b-1050">El OID real para RSA_SHA1 es el siguiente:</span><span class="sxs-lookup"><span data-stu-id="a894b-1050">The actual OID for RSA_SHA1 is as follows:</span></span>

```C
{iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-1(1) sha1-with-rsa-
signature(5)}
```
<span data-ttu-id="a894b-1051">El OID se representa en la sintaxis ASN.1 y tiene un valor numérico de 1.2.840.113549.1.1.5.</span><span class="sxs-lookup"><span data-stu-id="a894b-1051">The OID is represented in ASN.1 syntax and has a numeric value of 1.2.840.113549.1.1.5.</span></span> <span data-ttu-id="a894b-1052">A continuación, este valor se codifica en formato binario y crea los siguientes bytes:</span><span class="sxs-lookup"><span data-stu-id="a894b-1052">This value is then encoded in binary format, creating the following bytes:</span></span>

```C
UCHAR RSA_SHA1_OID = { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05 };
```
<span data-ttu-id="a894b-1053">La conversión real de ASN.1 al formato binario está fuera del ámbito de este documento.</span><span class="sxs-lookup"><span data-stu-id="a894b-1053">The actual conversion from ASN.1 to the binary format is beyond the scope of this document.</span></span> <span data-ttu-id="a894b-1054">Busque las codificaciones ASN.1 de OID para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="a894b-1054">Search for ASN.1 encodings for OIDs for more information.</span></span> <span data-ttu-id="a894b-1055">La representación binaria de los OID admitidos por NetX Secure puede encontrarse en el archivo *nx_secure_x509.c*.</span><span class="sxs-lookup"><span data-stu-id="a894b-1055">The binary representation of the OIDs supported by NetX Secure can be found in the file *nx_secure_x509.c*.</span></span>

<span data-ttu-id="a894b-1056">Una vez que tenemos una asignación del OID real a una constante reconocida internamente, podemos crear una entrada para RSA_SHA1 en la tabla NX_SECURE_X509_CRYPTO:</span><span class="sxs-lookup"><span data-stu-id="a894b-1056">Once we have a mapping of the actual OID to an internally-recognized constant, we can create an entry for RSA_SHA1 in the NX_SECURE_X509_CRYPTO table:</span></span>

```C
{ 
    NX_SECURE_TLS_X509_TYPE_RSA_SHA_1,    /* Internal OID constant. */
    &crypto_method_rsa,                   /* RSA method (NX_CRYPTO_METHOD). */ 
    &crypto_method_sha1                   /* SHA-1 method (NX_CRYPTO_METHOD). */
}, 
```
### <a name="default-tls-routines"></a><span data-ttu-id="a894b-1057">Rutinas de TLS predeterminadas</span><span class="sxs-lookup"><span data-stu-id="a894b-1057">Default TLS Routines</span></span>

<span data-ttu-id="a894b-1058">Como se mencionó anteriormente, TLS requiere algunas rutinas predeterminadas para la generación de claves y la comprobación de mensajes durante el protocolo de enlace.</span><span class="sxs-lookup"><span data-stu-id="a894b-1058">As mentioned above, TLS requires some default routines for key generation and message verification during the handshake.</span></span> <span data-ttu-id="a894b-1059">La rutina principal es la función pseudoaleatoria de TLS o PRF.</span><span class="sxs-lookup"><span data-stu-id="a894b-1059">The primary routine is the TLS Pseudo-Random Function, or PRF.</span></span> <span data-ttu-id="a894b-1060">La PRF se basa en rutinas hash y se puede usar para generar una cantidad arbitraria de datos pseudoaleatorios<sup>20</sup> para la generación de claves u otros fines.</span><span class="sxs-lookup"><span data-stu-id="a894b-1060">The PRF is based on hash routines and can be used to generate an arbitrary amount of pseudo-random data<sup>20</sup> for key generation or other purposes.</span></span>

<span data-ttu-id="a894b-1061">Además de la PRF, cada versión de TLS utiliza rutinas hash predeterminadas que también se deben proporcionar.</span><span class="sxs-lookup"><span data-stu-id="a894b-1061">In addition to the PRF, each version of TLS utilizes default hash routines that also need to be provided.</span></span> <span data-ttu-id="a894b-1062">En TLS 1.0 y 1.1, esas rutinas hash son MD5 y SHA-1.</span><span class="sxs-lookup"><span data-stu-id="a894b-1062">For TLS versions 1.0 and 1.1, those hash routines are MD5 and SHA-1.</span></span> <span data-ttu-id="a894b-1063">TLS 1.2 solo requiere SHA-256.</span><span class="sxs-lookup"><span data-stu-id="a894b-1063">TLS version 1.2 requires only SHA-256.</span></span>

<span data-ttu-id="a894b-1064">En la estructura NX_SECURE_TLS_CRYPTO, hay punteros NX_CRYPTO_METHOD para MD5, SHA-1, SHA-256, PRF de TLS 1.0/1.1 y PRF predeterminada de TLS 1.2.</span><span class="sxs-lookup"><span data-stu-id="a894b-1064">In the NX_SECURE_TLS_CRYPTO structure, there are NX_CRYPTO_METHOD pointers for MD5, SHA-1, SHA-256, the TLS version 1.0/1.1 PRF, and the default TLS 1.2 PRF.</span></span>

<span data-ttu-id="a894b-1065">La compatibilidad con TLS 1.3 agrega campos para HKDF (generación de claves), HMAC (para operaciones de hash específicas que se usan durante el protocolo de enlace) y ECDHE (necesario para la funcionalidad TLS 1.3).</span><span class="sxs-lookup"><span data-stu-id="a894b-1065">TLS 1.3 support adds fields for HKDF (key generation), HMAC (for specific hashing operations used during the handshake) and ECDHE (required for TLS 1.3 functionality).</span></span>

<span data-ttu-id="a894b-1066">En la biblioteca de criptografía de software genérico se incluyen las versiones de software de la PRF de TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-1066">Provided in the generic software cryptography library are software versions of the TLS PRF.</span></span> <span data-ttu-id="a894b-1067">Para TLS 1.0/1.1, esta función se denomina *nx_crypto_tls_prf_1*.</span><span class="sxs-lookup"><span data-stu-id="a894b-1067">For TLS 1.0/1.1, this function is called *nx_crypto_tls_prf_1*.</span></span> <span data-ttu-id="a894b-1068">Para TLS 1.2, la función se denomina *nx_secure_tls_prf_sha256*.</span><span class="sxs-lookup"><span data-stu-id="a894b-1068">For TLS 1.2, the function is called *nx_secure_tls_prf_sha256*.</span></span> <span data-ttu-id="a894b-1069">El sufijo “1” representa la PRF de TLS 1.0 heredada y el sufijo “SHA256” hace referencia al hecho de que la PRF predeterminada de TLS 1.2 se basa en SHA-256.</span><span class="sxs-lookup"><span data-stu-id="a894b-1069">The suffix "1" represents the legacy TLS 1.0 PRF, and the "sha256" suffix refers to the fact that the TLS 1.2 default PRF is based on SHA-256.</span></span> <span data-ttu-id="a894b-1070">Cuando se necesita compatibilidad con otras rutinas PRF, el sufijo de dichas rutinas reflejará el método hash que se usa.</span><span class="sxs-lookup"><span data-stu-id="a894b-1070">When support for other PRF routines is needed, the suffix for those routines will reflect the hash method used.</span></span> <span data-ttu-id="a894b-1071">Dado que las rutinas PRF se basan en métodos hash, las rutinas hash subyacentes pueden acelerar el hardware de forma independiente en distintas plataformas de destino.</span><span class="sxs-lookup"><span data-stu-id="a894b-1071">Since the PRF routines are based on hash methods, the underlying hash routines may be hardware-accelerated independently on different target platforms.</span></span>

<span data-ttu-id="a894b-1072">Además de las tablas de búsqueda de conjuntos de cifrado de TLS y X.509, con las rutinas PRF y hash predeterminadas rellenadas se puede usar la estructura NX_SECURE_TLS_CRYPTO y usarla para inicializar una sesión de TLS.</span><span class="sxs-lookup"><span data-stu-id="a894b-1072">In addition to the TLS ciphersuite and X.509 lookup tables, with the default PRF and hash routines filled in the NX_SECURE_TLS_CRYPTO structure can be populated and used to initialize a TLS session.</span></span>

20. <span data-ttu-id="a894b-1073">“Pseudoaleatorio” hace referencia al hecho de que la PRF es determinista, lo que significa que siempre producirá la misma salida con la misma entrada; pero es aleatoria en el sentido de que la salida no es predecible.</span><span class="sxs-lookup"><span data-stu-id="a894b-1073">“Pseudo-random” refers to the fact that the PRF is deterministic, meaning it will always produce the same output given the same input, but random in the fact that the output is not predictable.</span></span> <span data-ttu-id="a894b-1074">TLS usa esta propiedad de PRF para generar las claves de sesión a partir de varios datos públicos combinados con el secreto maestro intercambiado durante el protocolo de enlace mediante un cifrado de clave pública como RSA.</span><span class="sxs-lookup"><span data-stu-id="a894b-1074">TLS uses this property of the PRF to generate the session keys from various public data combined with the master secret exchanged during the handshake using a public-key cipher like RSA.</span></span>

### <a name="cryptographic-metadata"></a><span data-ttu-id="a894b-1075">Metadatos criptográficos</span><span class="sxs-lookup"><span data-stu-id="a894b-1075">Cryptographic Metadata</span></span>

<span data-ttu-id="a894b-1076">Antes de que podamos inicializar la sesión de TLS con la tabla NX_SECURE_TLS_CRYPTO, necesitamos asignar espacio en el búfer para los metadatos de rutina criptográfica.</span><span class="sxs-lookup"><span data-stu-id="a894b-1076">Before we can initialize the TLS session with the NX_SECURE_TLS_CRYPTO table, we need to allocate buffer space for the cryptographic routine metadata.</span></span> <span data-ttu-id="a894b-1077">Los metadatos se usan para almacenar todo el estado asociado a una rutina determinada, representada por su bloque de control.</span><span class="sxs-lookup"><span data-stu-id="a894b-1077">The metadata is used to store all the state associated with a particular routine, represented by its control block.</span></span> <span data-ttu-id="a894b-1078">El campo *nx_crypto_metadata_area_size* de cada objeto NX_CRYPTO_METHOD debe establecerse en el tamaño de la estructura de control asociada a esa rutina. En caso contrario, la inicialización de TLS no podrá tener en cuenta correctamente el espacio necesario, lo que podría provocar problemas de saturación del búfer.</span><span class="sxs-lookup"><span data-stu-id="a894b-1078">The *nx_crypto_metadata_area_size* field of each NX_CRYPTO_METHOD must be set to the size of the control structure associated with that routine or the TLS initialization will fail to properly account for the space needed, possibly causing buffer overrun issues.</span></span>

<span data-ttu-id="a894b-1079">Antes de crear la sesión de TLS, se debe asignar el búfer de metadatos.</span><span class="sxs-lookup"><span data-stu-id="a894b-1079">Before the TLS session is created, the metadata buffer must be allocated.</span></span> <span data-ttu-id="a894b-1080">El servicio nx_secure_tls_session_create divide automáticamente el búfer y el espacio se reserva para cada una de las rutinas que se proporcionan en la tabla de métodos criptográficos.</span><span class="sxs-lookup"><span data-stu-id="a894b-1080">The buffer is automatically divided up by nx_secure_tls_session_create and space is reserved for each of the routines that are provided in the cryptographic method table.</span></span> <span data-ttu-id="a894b-1081">Tenga en cuenta que, puesto que solo hay un conjunto de cifrado activo a la vez en una sesión de TLS, el número de conjuntos admitidos no afecta al espacio de metadatos necesario: el espacio se reserva para cada una de las 5 rutinas de conjunto de cifrado con el tamaño máximo de bloque de control de esa categoría en la tabla de búsqueda de conjuntos de cifrado.</span><span class="sxs-lookup"><span data-stu-id="a894b-1081">Note that since only one ciphersuite is active at a time in a TLS session, the number of supported ciphersuites does not affect the needed metadata space – space is reserved for each of the 5 ciphersuite routines using the maximum control block size for that category in the ciphersuite lookup table.</span></span>

<span data-ttu-id="a894b-1082">Con el fin de facilitar el cálculo del tamaño del búfer de metadatos, el servicio *nx_secure_metadata_size_calculate* realiza los mismos cálculos que nx_secure_tls_session_create, pero simplemente devuelve el tamaño del búfer de metadatos total requerido en bytes.</span><span class="sxs-lookup"><span data-stu-id="a894b-1082">In order to make calculating the metadata buffer size easy, the service *nx_secure_metadata_size_calculate* performs the same calculations as nx_secure_tls_session_create but simply returns the total required metadata buffer size in bytes.</span></span>

### <a name="initializing-the-tls-session"></a><span data-ttu-id="a894b-1083">Inicialización de la sesión de TLS</span><span class="sxs-lookup"><span data-stu-id="a894b-1083">Initializing the TLS session</span></span>

<span data-ttu-id="a894b-1084">Una vez creados los objetos NX_CRYPTO_METHOD y NX_SECURE_TLS_CRYPTO y reservada el área de metadatos, se puede inicializar una sesión de TLS como se indica a continuación (valores tomados de los ejemplos anteriores):</span><span class="sxs-lookup"><span data-stu-id="a894b-1084">Once the NX_CRYPTO_METHOD and NX_SECURE_TLS_CRYPTO objects are created and the metadata area reserved, we can initialize a TLS session as follows (values taken from the above examples):</span></span>

```C
/* Pointer to the platform-specific cipher table. */
extern nx_crypto_tls_ciphers;

/* Cryptographic routine metadata buffer. Size is determined by calling 
nx_secure_tls_metadata_size_calculate with the nx_crypto_tls_ciphers table referenced 
above. */
UCHAR crypto_metadata[4500];

/* Initialize our TLS session using our cipher table and metadata area. Note that we can 
use sizeof for the metadata array because the size parameter expects the size in bytes.*/

nx_secure_tls_session_create(
    &tls_session,            /* Pointer to TLS session.      */
    &nx_crypto_tls_ciphers,  /* Pointer to cipher table.     */
    crypto_metadata,         /* Cryptography metadata buffer.*/
    sizeof(crypto_metadata), /* Size of metadata buffer.     */
);
```
